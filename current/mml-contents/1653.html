<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<title>REAL</title>
</head>
<body>
<div class='mml-summary'>
<h1>func REAL</h1>
<h2>List of Definitions (3)</h2>
<ol>
<li><span data-link='1653.html#ELM4168'>REAL</span> [<span data-href='chain_1.html'>chain_1</span>]</li>
<li><span data-link='1653.html#ELM6324'>REAL</span> [<span data-href='euclid.html#K1'>euclid</span>]</li>
<li><span data-link='1653.html#ELM18624'>REAL</span> [<span data-href='numbers.html#K1'>numbers</span>]</li>
</ol>
</div>
<div class='mml-element' id='ELM4168'>
<h2>1.   <span data-link='1653.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='chain_1.html'>chain_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">n</font> be   <span title="NAT_1:NM.1" data-link="5402.html#ELM17446">Nat</span>;<br><div about="#D9" typeof="oo:Definition" class="main-sentence">
<span class="kw">redefine </span><span class="kw">func</span>  <span title="EUCLID:func.1" data-link="1653.html#ELM6324">REAL</span> <font color="Maroon" title="c1">n</font><span class="kw"> means </span>:<span class="lab"><font color="Green" title="E9">Def3</font></span>: <a name="D3"><span class="comment"><font color="firebrick">:: CHAIN_1:def 3</font></span><br></a> for <font color="Olive" title="b1">x</font> being    <span title="HIDDEN:mode.1" data-link="4140.html#ELM11935">object</span>  holds <br> ( <font color="Olive" title="b1">x</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span> <span class="kw">it</span> iff <font color="Olive" title="b1">x</font> is   <span title="FUNCT_2:NM.1" data-link="3155.html#ELM8873">Function</span> of <span class="p1">(<span class="default"><span title="FINSEQ_1:func.2" data-link="2722.html#ELM7094">Seg</span> <font color="Maroon" title="c1">n</font></span>)</span>,<span title="NUMBERS:func.1" data-link="1653.html#ELM18624">REAL</span> );<br>
</div>
<span class="kw">compatibility</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM6324'>
<h2>2.   <span data-link='1653.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='euclid.html#K1'>euclid</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">n</font> be   <span title="NAT_1:NM.1" data-link="5402.html#ELM17446">Nat</span>;<br><div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K1"><span class="kw">func</span> </a> <span title="EUCLID:func.1" data-link="1653.html#ELM6324">REAL</span> <font color="Maroon" title="c1">n</font><span class="kw"> -&gt; </span>   <span title="FINSEQ_2:mode.1" data-link="2729.html#ELM7176">FinSequenceSet</span> of  <span title="NUMBERS:func.1" data-link="1653.html#ELM18624">REAL</span> <span class="kw"> equals </span><a name="D1"><span class="comment"><font color="firebrick">:: EUCLID:def 1</font></span><br></a><font color="Maroon" title="c1">n</font> <span title="FINSEQ_2:func.4" data-link="2732.html#ELM7182">-tuples_on</span> <span title="NUMBERS:func.1" data-link="1653.html#ELM18624">REAL</span>;<br>
</div>
<span class="kw">coherence</span> <br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  non  empty   functional   FinSequence-membered   open   for    Element of K16((REAL m));
</td><td><span data-href='ckspace1.html#RC1'>ckspace1</span></td></tr>
<tr><td>
cluster  Ck_Functions (k,X) ->  non  empty   multiplicatively-closed   additively-linearly-closed  ;
</td><td><span data-href='ckspace1.html#FC1'>ckspace1</span></td></tr>
<tr><td>
cluster  R_Algebra_of_Ck_Functions (k,X) ->  right_complementable   Abelian   add-associative   right_zeroed   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   right-distributive   right_unital   associative   commutative   vector-associative  ;
</td><td><span data-href='ckspace1.html#FC2'>ckspace1</span></td></tr>
<tr><td>
cluster  REAL n ->  non  empty  ;
</td><td><span data-href='euclid.html#FC1'>euclid</span></td></tr>
<tr><td>
cluster   -> n -element   for    Element of  REAL n;
</td><td><span data-href='euclid.html#CC1'>euclid</span></td></tr>
<tr><td>
cluster |.(x1 - x1).| ->  zero  ;
</td><td><span data-href='euclid.html#FC3'>euclid</span></td></tr>
<tr><td>
cluster  REAL n ->  FinSequence-membered  ;
</td><td><span data-href='euclid.html#FC9'>euclid</span></td></tr>
<tr><td>
cluster  REAL n ->  real-functions-membered  ;
</td><td><span data-href='euclid.html#FC10'>euclid</span></td></tr>
<tr><td>
cluster  Line (x1,x2) ->  non  empty  ;
</td><td><span data-href='euclid_4.html#FC1'>euclid_4</span></td></tr>
<tr><td>
cluster  functional   FinSequence-membered   R-orthonormal   for    Element of  bool (REAL n);
</td><td><span data-href='euclid_7.html#RC3'>euclid_7</span></td></tr>
<tr><td>
cluster  orthogonal_basis   ->  R-orthonormal   complete   for    Element of  bool (REAL n);
</td><td><span data-href='euclid_7.html#CC5'>euclid_7</span></td></tr>
<tr><td>
cluster  R-orthonormal   complete   ->  orthogonal_basis   for    Element of  bool (REAL n);
</td><td><span data-href='euclid_7.html#CC6'>euclid_7</span></td></tr>
<tr><td>
cluster  [#] (REAL n) ->  linear_manifold  ;
</td><td><span data-href='euclid_7.html#FC4'>euclid_7</span></td></tr>
<tr><td>
cluster {(0* n)} ->  linear_manifold   for  Subset of (REAL n);
</td><td><span data-href='euclid_7.html#FC5'>euclid_7</span></td></tr>
<tr><td>
cluster  L_Span X ->  linear_manifold  ;
</td><td><span data-href='euclid_7.html#FC6'>euclid_7</span></td></tr>
<tr><td>
cluster  functional   FinSequence-membered   orthogonal_basis   for    Element of  bool (REAL n);
</td><td><span data-href='euclid_7.html#RC4'>euclid_7</span></td></tr>
<tr><td>
cluster  orthogonal_basis   ->  non  empty   for    Element of  bool (REAL n);
</td><td><span data-href='euclid_7.html#CC7'>euclid_7</span></td></tr>
<tr><td>
cluster  plane (x1,x2,x3) ->  non  empty  ;
</td><td><span data-href='euclidlp.html#FC2'>euclidlp</span></td></tr>
<tr><td>
cluster REAL --> (0* n) ->  differentiable   for  Function of REAL,(REAL n);
</td><td><span data-href='ndiff_4.html#FC1'>ndiff_4</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL n -valued   non  empty   Function-like   total   quasi_total   Function-yielding  V237() V238() V239()  differentiable   for    Element of K16(K17(REAL,(REAL n)));
</td><td><span data-href='ndiff_4.html#RC1'>ndiff_4</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC1'>nfcont_4</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL n -valued   Function-like  V158() V231() V232() V233()  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#RC1'>nfcont_4</span></td></tr>
<tr><td>
cluster f | X ->  continuous   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC1'>nfcont_4</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC2'>nfcont_4</span></td></tr>
<tr><td>
cluster f | X ->  continuous   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC2'>nfcont_4</span></td></tr>
<tr><td>
cluster f1 + f2 ->  continuous   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC3'>nfcont_4</span></td></tr>
<tr><td>
cluster r (#) f ->  continuous   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC4'>nfcont_4</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  Lipschitzian   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC3'>nfcont_4</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL n -valued   empty   Function-like  V158() V231() V232() V233()  for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#RC2'>nfcont_4</span></td></tr>
<tr><td>
cluster f | X ->  Lipschitzian   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC5'>nfcont_4</span></td></tr>
<tr><td>
cluster f1 + f2 ->  Lipschitzian   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC6'>nfcont_4</span></td></tr>
<tr><td>
cluster f1 - f2 ->  Lipschitzian   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC7'>nfcont_4</span></td></tr>
<tr><td>
cluster p (#) f ->  Lipschitzian   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC8'>nfcont_4</span></td></tr>
<tr><td>
cluster |.f.| ->  Lipschitzian   for  PartFunc of REAL,REAL;
</td><td><span data-href='nfcont_4.html#FC9'>nfcont_4</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  Lipschitzian   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC4'>nfcont_4</span></td></tr>
<tr><td>
cluster  Function-like   Lipschitzian   ->  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC5'>nfcont_4</span></td></tr>
<tr><td>
cluster (REAL m) --> (0* n) ->  additive   homogeneous   for  Function of (REAL m),(REAL n);
</td><td><span data-href='pdiff_6.html#FC1'>pdiff_6</span></td></tr>
<tr><td>
cluster  Relation-like   REAL m -defined   REAL n -valued   non  empty   Function-like   total  V30( REAL m, REAL n)  Function-yielding   complex-functions-valued   ext-real-functions-valued   real-functions-valued   additive   homogeneous   for    Element of K16(K17((REAL m),(REAL n)));
</td><td><span data-href='pdiff_6.html#RC1'>pdiff_6</span></td></tr>
<tr><td>
cluster  Function-like  V30( REAL m, REAL n)  additive   homogeneous   ->  Lipschitzian   for    Element of K16(K17((REAL m),(REAL n)));
</td><td><span data-href='pdiff_6.html#CC1'>pdiff_6</span></td></tr>
<tr><td>
cluster  [#] (REAL 2) ->  open  ;
</td><td><span data-href='pdiffeq1.html#FC2'>pdiffeq1</span></td></tr>
<tr><td>
cluster  ClosedHyperInterval (a,a) ->  trivial  ;
</td><td><span data-href='srings_5.html#FC19'>srings_5</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM18624'>
<h2>3.   <span data-link='1653.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='numbers.html#K1'>numbers</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K1"><span class="kw">func</span> </a> <span title="NUMBERS:func.1" data-link="1653.html#ELM18624">REAL</span> <span class="kw"> -&gt; </span>   <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> <span class="kw"> equals </span><a name="D1"><span class="comment"><font color="firebrick">:: NUMBERS:def 1</font></span><br></a><span class="p1">(<span class="default"><span title="ARYTM_2:func.2" data-link="843.html#ELM2078">REAL+</span> <span title="XBOOLE_0:func.2" data-link="1743.html#ELM29649">\/</span> <span class="p2"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><span class="p3"><span title="TARSKI:func.1" data-link="857.html#ELM26065">{</span><span class="default"><span title="ORDINAL1:func.5" data-link="6192.html#ELM19065">0</span></span><span title="TARSKI:func.1" data-link="857.html#ELM26065">}</span></span>,<span title="ARYTM_2:func.2" data-link="843.html#ELM2078">REAL+</span></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span></span>)</span> <span title="SUBSET_1:func.6" data-link="724.html#ELM25875">\</span> <span class="p1"><span title="TARSKI:func.1" data-link="857.html#ELM26065">{</span><span class="default"><span class="p2"><span title="TARSKI:func.4" data-link="802.html#ELM26068">[</span><span class="default"><span title="ORDINAL1:func.5" data-link="6192.html#ELM19065">0</span>,<span title="ORDINAL1:func.5" data-link="6192.html#ELM19065">0</span></span><span title="TARSKI:func.4" data-link="802.html#ELM26068">]</span></span></span><span title="TARSKI:func.1" data-link="857.html#ELM26065">}</span></span>;<br>
</div>
<span class="kw">coherence</span> <br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  Relation-like   REAL  -valued   Sequence-like   Function-like   finite   ->  real-valued   for    set ;
</td><td><span data-href='afinsq_1.html#CC4'>afinsq_1</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( REAL )  non  empty   Function-like  V28( NAT )  quasi_total  V39() V40() V41()  eventually-nonnegative   positive   eventually-positive   eventually-nonzero   eventually-nondecreasing   for    Element of K16(K17(NAT,REAL));
</td><td><span data-href='asympt_0.html#RC7'>asympt_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   positive   ->  eventually-positive   for    Element of K16(K17(NAT,REAL));
</td><td><span data-href='asympt_0.html#CC1'>asympt_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   eventually-positive   ->  eventually-nonnegative   eventually-nonzero   for    Element of K16(K17(NAT,REAL));
</td><td><span data-href='asympt_0.html#CC2'>asympt_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   eventually-nonnegative   eventually-nonzero   ->  eventually-positive   for    Element of K16(K17(NAT,REAL));
</td><td><span data-href='asympt_0.html#CC3'>asympt_0</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   Sequence-like   Function-like  V39() V40() V41()  finite   positive-yielding  V183()  for    set ;
</td><td><span data-href='asympt_3.html#RC1'>asympt_3</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   REAL  -valued   non  empty   Sequence-like   Function-like  V39() V40() V41()  finite   positive-yielding   nonnegative-yielding  V183()  for    set ;
</td><td><span data-href='asympt_3.html#RC2'>asympt_3</span></td></tr>
<tr><td>
cluster a (#) c ->  finite   for  Sequence of  REAL ;
</td><td><span data-href='asympt_3.html#FC1'>asympt_3</span></td></tr>
<tr><td>
cluster a (#) c ->  non  empty   positive-yielding   for  XFinSequence of  REAL ;
</td><td><span data-href='asympt_3.html#FC2'>asympt_3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   polynomially-bounded   ->  polynomially-abs-bounded   for    Element of  bool [:omega,REAL:];
</td><td><span data-href='asympt_3.html#CC1'>asympt_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   non  empty   Function-like  V28( NAT )  quasi_total  V39() V40() V41()  polynomially-abs-bounded   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='asympt_3.html#RC3'>asympt_3</span></td></tr>
<tr><td>
cluster f + g ->  polynomially-abs-bounded   for  Function of NAT,REAL;
</td><td><span data-href='asympt_3.html#FC3'>asympt_3</span></td></tr>
<tr><td>
cluster f (#) g ->  polynomially-abs-bounded   for  Function of NAT,REAL;
</td><td><span data-href='asympt_3.html#FC4'>asympt_3</span></td></tr>
<tr><td>
cluster a (#) f ->  polynomially-abs-bounded   for  Function of NAT,REAL;
</td><td><span data-href='asympt_3.html#FC5'>asympt_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   non  empty   Function-like  V28( NAT )  quasi_total  V39() V40() V41()  negligible   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='asympt_3.html#RC4'>asympt_3</span></td></tr>
<tr><td>
cluster |.f.| ->  negligible   for  Function of NAT,REAL;
</td><td><span data-href='asympt_3.html#FC10'>asympt_3</span></td></tr>
<tr><td>
cluster a (#) f ->  negligible   for  Function of NAT,REAL;
</td><td><span data-href='asympt_3.html#FC11'>asympt_3</span></td></tr>
<tr><td>
cluster f + g ->  negligible   for  Function of NAT,REAL;
</td><td><span data-href='asympt_3.html#FC12'>asympt_3</span></td></tr>
<tr><td>
cluster f (#) g ->  negligible   for  Function of NAT,REAL;
</td><td><span data-href='asympt_3.html#FC13'>asympt_3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   negligible   ->  polynomially-abs-bounded   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='asympt_3.html#CC2'>asympt_3</span></td></tr>
<tr><td>
cluster a (#) b ->  nonnegative-yielding  ;
</td><td><span data-href='asympt_3.html#FC15'>asympt_3</span></td></tr>
<tr><td>
cluster a ^ b ->  nonnegative-yielding  ;
</td><td><span data-href='asympt_3.html#FC16'>asympt_3</span></td></tr>
<tr><td>
cluster (polynom c) (#) f ->  negligible   for  Function of NAT,REAL;
</td><td><span data-href='asympt_3.html#FC18'>asympt_3</span></td></tr>
<tr><td>
cluster g (#) f ->  negligible   for  Function of NAT,REAL;
</td><td><span data-href='asympt_3.html#FC19'>asympt_3</span></td></tr>
<tr><td>
cluster f | n ->  REAL  -valued  ;
</td><td><span data-href='basel_1.html#FC1'>basel_1</span></td></tr>
<tr><td>
cluster  dom tan ->  open   for  Subset of REAL;
</td><td><span data-href='basel_1.html#FC15'>basel_1</span></td></tr>
<tr><td>
cluster  cot f ->  REAL  -valued  ;
</td><td><span data-href='basel_1.html#FC16'>basel_1</span></td></tr>
<tr><td>
cluster  cosec f ->  REAL  -valued  ;
</td><td><span data-href='basel_1.html#FC17'>basel_1</span></td></tr>
<tr><td>
cluster  x_r-seq m ->  REAL  -valued  ;
</td><td><span data-href='basel_1.html#FC22'>basel_1</span></td></tr>
<tr><td>
cluster  UNITSTR(# D,Z,a,m,s #) ->  non  empty  ;
</td><td><span data-href='bhsp_1.html#FC1'>bhsp_1</span></td></tr>
<tr><td>
cluster A /\ B ->  open   for  Subset of REAL;
</td><td><span data-href='borsuk_5.html#FC14'>borsuk_5</span></td></tr>
<tr><td>
cluster A \/ B ->  open   for  Subset of REAL;
</td><td><span data-href='borsuk_5.html#FC15'>borsuk_5</span></td></tr>
<tr><td>
cluster  ConjNormAlgStr(# D,m,a,M,O,Z,n,c #) ->  real-membered  ;
</td><td><span data-href='cayldick.html#FC7'>cayldick</span></td></tr>
<tr><td>
cluster  ConjNormAlgStr(# D,m,a,M,O,Z,n,c #) ->  add-associative  ;
</td><td><span data-href='cayldick.html#FC8'>cayldick</span></td></tr>
<tr><td>
cluster  ConjNormAlgStr(# D,m,a,M,O,Z,n,c #) ->  Abelian  ;
</td><td><span data-href='cayldick.html#FC9'>cayldick</span></td></tr>
<tr><td>
cluster  ConjNormAlgStr(# D,m,a,M,O,Z,n,c #) ->  associative  ;
</td><td><span data-href='cayldick.html#FC10'>cayldick</span></td></tr>
<tr><td>
cluster  ConjNormAlgStr(# D,m,a,M,O,Z,n,c #) ->  commutative  ;
</td><td><span data-href='cayldick.html#FC11'>cayldick</span></td></tr>
<tr><td>
cluster V10() V13( the carrier of V) V14( REAL )  Function-like   quasi_total  V60() V61() V62()  circled   for    Linear_Combination of V;
</td><td><span data-href='circled1.html#RC1'>circled1</span></td></tr>
<tr><td>
cluster V10() V13( the carrier of V) V14( REAL )  Function-like   quasi_total  V60() V61() V62()  circled   for    Linear_Combination of M;
</td><td><span data-href='circled1.html#RC2'>circled1</span></td></tr>
<tr><td>
cluster  Function-like  V19( NAT , REAL )  summable   ->  convergent   for    Element of K20(K21(NAT,REAL));
</td><td><span data-href='comseq_3.html#CC1'>comseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V19( NAT , REAL )  absolutely_summable   ->  summable   for    Element of K20(K21(NAT,REAL));
</td><td><span data-href='comseq_3.html#CC2'>comseq_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like  V12()  total  V19( NAT , REAL )  complex-valued   ext-real-valued   real-valued   absolutely_summable   for    Element of K20(K21(NAT,REAL));
</td><td><span data-href='comseq_3.html#RC1'>comseq_3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   REAL  -valued   Function-like   quasi_total  V130() V131() V132()  convex   for    Linear_Combination of V;
</td><td><span data-href='convex2.html#RC1'>convex2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   REAL  -valued   Function-like   quasi_total  V130() V131() V132()  convex   for    Linear_Combination of M;
</td><td><span data-href='convex2.html#RC2'>convex2</span></td></tr>
<tr><td>
cluster  set_of_tagged_Division D ->  non  empty  ;
</td><td><span data-href='cousin.html#FC2'>cousin</span></td></tr>
<tr><td>
cluster   ->  non  empty   for    Element of  set_of_tagged_Division D;
</td><td><span data-href='cousin.html#CC1'>cousin</span></td></tr>
<tr><td>
cluster jauge -fine   for    tagged_division of I;
</td><td><span data-href='cousin.html#RC1'>cousin</span></td></tr>
<tr><td>
cluster  min (f,g) ->  positive-yielding  ;
</td><td><span data-href='cousin2.html#FC1'>cousin2</span></td></tr>
<tr><td>
cluster  max (f,g) ->  positive-yielding  ;
</td><td><span data-href='cousin2.html#FC2'>cousin2</span></td></tr>
<tr><td>
cluster  tagged_divs A ->  non  empty  ;
</td><td><span data-href='cousin2.html#FC3'>cousin2</span></td></tr>
<tr><td>
cluster V1() V4(I) V5( REAL )  Function-like   non  empty   total  V55(I, REAL )  complex-valued   ext-real-valued   real-valued   HK-integrable   for    Element of  bool [:I,REAL:];
</td><td><span data-href='cousin2.html#RC1'>cousin2</span></td></tr>
<tr><td>
cluster V1() V4(I) V5( REAL )  Function-like   non  empty   total  V55(I, REAL )  complex-valued   ext-real-valued   real-valued   integrable   for    Element of  bool [:I,REAL:];
</td><td><span data-href='cousin2.html#RC2'>cousin2</span></td></tr>
<tr><td>
cluster V1() V4(X) V5( REAL )  Function-like   non  empty   total  V55(X, REAL )  complex-valued   ext-real-valued   real-valued   bounded   for    Element of  bool [:X,REAL:];
</td><td><span data-href='cousin2.html#RC3'>cousin2</span></td></tr>
<tr><td>
cluster V1() V4(I) V5( REAL )  Function-like   non  empty   total  V55(I, REAL )  complex-valued   ext-real-valued   real-valued   bounded   integrable   for    Element of  bool [:I,REAL:];
</td><td><span data-href='cousin2.html#RC4'>cousin2</span></td></tr>
<tr><td>
cluster  Function-like  V55(I, REAL )  bounded   integrable   ->  HK-integrable   for    Element of  bool [:I,REAL:];
</td><td><span data-href='cousin2.html#CC1'>cousin2</span></td></tr>
<tr><td>
cluster  CNORMSTR(# X,Z,A,M,N #) ->  non  empty  ;
</td><td><span data-href='csspace3.html#FC4'>csspace3</span></td></tr>
<tr><td>
cluster  Function-like  V32([:NAT,NAT:], REAL )  P-convergent   non-decreasing   ->  bounded_above   bounded_below   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#CC1'>dblseq_1</span></td></tr>
<tr><td>
cluster  Function-like  V32([:NAT,NAT:], REAL )  P-convergent   non-increasing   ->  bounded_above   bounded_below   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#CC2'>dblseq_1</span></td></tr>
<tr><td>
cluster [:NAT,NAT:] --> r ->  P-convergent   convergent_in_cod1   convergent_in_cod2   for  Function of [:NAT,NAT:],REAL;
</td><td><span data-href='dblseq_1.html#FC1'>dblseq_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [:NAT,NAT:] -defined   REAL  -valued   Function-like  V28([:NAT,NAT:]) V32([:NAT,NAT:], REAL ) V109() V110() V111()  P-convergent   convergent_in_cod1   convergent_in_cod2   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#RC1'>dblseq_1</span></td></tr>
<tr><td>
cluster  lim_in_cod2 Pseq2 ->  convergent  ;
</td><td><span data-href='dblseq_1.html#FC2'>dblseq_1</span></td></tr>
<tr><td>
cluster  lim_in_cod1 Pseq1 ->  convergent  ;
</td><td><span data-href='dblseq_1.html#FC3'>dblseq_1</span></td></tr>
<tr><td>
cluster  Function-like  V32([:NAT,NAT:], REAL )  bounded_above   non-decreasing   ->  P-convergent   convergent_in_cod1   convergent_in_cod2   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#CC3'>dblseq_1</span></td></tr>
<tr><td>
cluster  Function-like  V32([:NAT,NAT:], REAL )  bounded_below   non-increasing   ->  P-convergent   convergent_in_cod1   convergent_in_cod2   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#CC4'>dblseq_1</span></td></tr>
<tr><td>
cluster   ->  P-convergent   for    subsequence of Pseq;
</td><td><span data-href='dblseq_1.html#CC5'>dblseq_1</span></td></tr>
<tr><td>
cluster   ->  convergent_in_cod1   for    subsequence of Rseq;
</td><td><span data-href='dblseq_1.html#CC6'>dblseq_1</span></td></tr>
<tr><td>
cluster   ->  convergent_in_cod2   for    subsequence of Rseq;
</td><td><span data-href='dblseq_1.html#CC7'>dblseq_1</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10(X) V11( REAL )  Function-like   total  V32(X, REAL )  complex-valued   ext-real-valued   real-valued   nonnegative   nonpositive   for    Element of  bool [:X,REAL:];
</td><td><span data-href='dblseq_3.html#RC1'>dblseq_3</span></td></tr>
<tr><td>
cluster  fD (f,h) ->  quasi_total  ;
</td><td><span data-href='diff_1.html#FC1'>diff_1</span></td></tr>
<tr><td>
cluster  bD (f,h) ->  quasi_total  ;
</td><td><span data-href='diff_1.html#FC2'>diff_1</span></td></tr>
<tr><td>
cluster  cD (f,h) ->  quasi_total  ;
</td><td><span data-href='diff_1.html#FC3'>diff_1</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( PFuncs (REAL,REAL))  non  empty   Function-like   total   quasi_total   Sequence-yielding   for    Element of  bool [:NAT,(PFuncs (REAL,REAL)):];
</td><td><span data-href='diff_1.html#RC1'>diff_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   non  empty   Function-like   constant   finite  V47() V48() V49()  FinSequence-like   FinSubsequence-like  V77()  ProbFinS   for    distProbFinS of S;
</td><td><span data-href='dist_1.html#RC1'>dist_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of X -defined   REAL  -valued   non  empty   Function-like  V25( the carrier of X)  quasi_total  V156() V157() V158()  subadditive   additive   homogeneous   positively_homogeneous   Lipschitzian   for    Element of  bool [: the carrier of X,REAL:];
</td><td><span data-href='dualsp01.html#RC1'>dualsp01</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of X) V5( REAL )  non  empty   Function-like   total   quasi_total   additive   homogeneous  V166() V167() V168()  Lipschitzian   for    Element of  bool [: the carrier of X,REAL:];
</td><td><span data-href='dualsp04.html#RC1'>dualsp04</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like  V50()  FinSequence-like   FinSubsequence-like  V165() V166() V167()  nonnegative   for    FinSequence of  REAL ;
</td><td><span data-href='entropy1.html#RC1'>entropy1</span></td></tr>
<tr><td>
cluster  ProbFinS   ->  non  empty   nonnegative   for    FinSequence of  REAL ;
</td><td><span data-href='entropy1.html#CC1'>entropy1</span></td></tr>
<tr><td>
cluster  tabular   with_sum=1   -> V3()  for    FinSequence of REAL * ;
</td><td><span data-href='entropy1.html#CC2'>entropy1</span></td></tr>
<tr><td>
cluster  tabular   Joint_Probability   -> V3()  for    FinSequence of REAL * ;
</td><td><span data-href='entropy1.html#CC3'>entropy1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined  REAL *  -valued   Function-like  V50()  FinSequence-like   FinSubsequence-like   tabular  V118( REAL ,n,n)  diagonal   for    FinSequence of REAL * ;
</td><td><span data-href='entropy1.html#RC2'>entropy1</span></td></tr>
<tr><td>
cluster   ->  REAL  -valued   for    Element of  the carrier of (Euclid n);
</td><td><span data-href='euclid_9.html#CC1'>euclid_9</span></td></tr>
<tr><td>
cluster  Function-like  V8()  ->  continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC1'>fcont_1</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL  -valued   Function-like   complex-valued   ext-real-valued   real-valued   continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#RC1'>fcont_1</span></td></tr>
<tr><td>
cluster f | X ->  continuous   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC1'>fcont_1</span></td></tr>
<tr><td>
cluster  Function-like   empty   ->  continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC2'>fcont_1</span></td></tr>
<tr><td>
cluster f | X ->  continuous   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC2'>fcont_1</span></td></tr>
<tr><td>
cluster f1 + f2 ->  continuous   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC3'>fcont_1</span></td></tr>
<tr><td>
cluster f1 - f2 ->  continuous   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC4'>fcont_1</span></td></tr>
<tr><td>
cluster f1 (#) f2 ->  continuous   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC5'>fcont_1</span></td></tr>
<tr><td>
cluster r (#) f ->  continuous   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC6'>fcont_1</span></td></tr>
<tr><td>
cluster f1 (#) f2 ->  continuous   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC7'>fcont_1</span></td></tr>
<tr><td>
cluster  Function-like   empty   ->  Lipschitzian   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC3'>fcont_1</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL  -valued   Function-like   empty   complex-valued   ext-real-valued   real-valued   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#RC2'>fcont_1</span></td></tr>
<tr><td>
cluster f | X ->  Lipschitzian   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC8'>fcont_1</span></td></tr>
<tr><td>
cluster f1 + f2 ->  Lipschitzian   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC9'>fcont_1</span></td></tr>
<tr><td>
cluster f1 - f2 ->  Lipschitzian   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC10'>fcont_1</span></td></tr>
<tr><td>
cluster f1 (#) f2 ->  Lipschitzian   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC11'>fcont_1</span></td></tr>
<tr><td>
cluster p (#) f ->  Lipschitzian   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC12'>fcont_1</span></td></tr>
<tr><td>
cluster |.f.| ->  Lipschitzian   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC13'>fcont_1</span></td></tr>
<tr><td>
cluster  Function-like  V8()  ->  Lipschitzian   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC4'>fcont_1</span></td></tr>
<tr><td>
cluster  id Y ->  Lipschitzian   for  PartFunc of REAL,REAL;
</td><td><span data-href='fcont_1.html#FC14'>fcont_1</span></td></tr>
<tr><td>
cluster  Function-like   Lipschitzian   ->  continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC5'>fcont_1</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL  -valued   Function-like   non  empty   total   quasi_total   complex-valued   ext-real-valued   real-valued   continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#RC3'>fcont_1</span></td></tr>
<tr><td>
cluster  [#] REAL ->  closed  ;
</td><td><span data-href='fcont_3.html#FC1'>fcont_3</span></td></tr>
<tr><td>
cluster  empty   ->  closed   for    Element of K19(REAL);
</td><td><span data-href='fcont_3.html#CC1'>fcont_3</span></td></tr>
<tr><td>
cluster  [#] REAL ->  open  ;
</td><td><span data-href='fcont_3.html#FC2'>fcont_3</span></td></tr>
<tr><td>
cluster  empty   ->  open   for    Element of K19(REAL);
</td><td><span data-href='fcont_3.html#CC2'>fcont_3</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( REAL )  Function-like   non  empty   total   non-zero   quasi_total   complex-valued   ext-real-valued   real-valued   0  -convergent   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='fdiff_1.html#RC1'>fdiff_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   0  -convergent   ->  convergent   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='fdiff_1.html#CC1'>fdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL )  Function-like   complex-valued   ext-real-valued   real-valued   RestFunc-like   for    Element of K19(K20(REAL,REAL));
</td><td><span data-href='fdiff_1.html#RC2'>fdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL )  Function-like   complex-valued   ext-real-valued   real-valued   linear   for    Element of K19(K20(REAL,REAL));
</td><td><span data-href='fdiff_1.html#RC3'>fdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL )  Function-like   non  empty   total   quasi_total   complex-valued   ext-real-valued   real-valued   differentiable   for    Element of K19(K20(REAL,REAL));
</td><td><span data-href='fdiff_1.html#RC4'>fdiff_1</span></td></tr>
<tr><td>
cluster REAL \ RAT ->  non  empty  ;
</td><td><span data-href='finance2.html#FC1'>finance2</span></td></tr>
<tr><td>
cluster REAL \ INT ->  non  empty  ;
</td><td><span data-href='finance2.html#FC2'>finance2</span></td></tr>
<tr><td>
cluster REAL \ NAT ->  non  empty  ;
</td><td><span data-href='finance2.html#FC3'>finance2</span></td></tr>
<tr><td>
cluster  GoCross_Seq_REAL (pm,k) ->  Borel_Sets  -valued  ;
</td><td><span data-href='finance2.html#FC4'>finance2</span></td></tr>
<tr><td>
cluster  GoCross_Partial_Union (pm,k) ->  Borel_Sets  -valued  ;
</td><td><span data-href='finance2.html#FC5'>finance2</span></td></tr>
<tr><td>
cluster  GoCross_Partial_Union (pm,k) ->  non-descending  ;
</td><td><span data-href='finance2.html#FC6'>finance2</span></td></tr>
<tr><td>
cluster  GoCross_Union pm ->  Borel_Sets  -valued  ;
</td><td><span data-href='finance2.html#FC7'>finance2</span></td></tr>
<tr><td>
cluster  GoCross_Union pm ->  non-descending  ;
</td><td><span data-href='finance2.html#FC8'>finance2</span></td></tr>
<tr><td>
cluster  In (I,(bool REAL)) ->  non  empty  ;
</td><td><span data-href='finance3.html#FC1'>finance3</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  Omega -defined  [.0,+infty.] -valued   Function-like   total  V34(Omega,[.0,+infty.])  ext-real-valued  Sigma, ExtBorelsubsets  -random_variable-like  MyFunc -StoppingTime-like   for    Element of K10(K11(Omega,[.0,+infty.]));
</td><td><span data-href='finance5.html#RC3'>finance5</span></td></tr>
<tr><td>
cluster  Relation-like  Omega -defined   REAL  -valued   Function-like   non  empty  V14(Omega) V18(Omega, REAL ) V39() V40() V41() F, Borel_Sets  -random_variable-like   for    Element of  Trivial-SigmaField K20(Omega,REAL);
</td><td><span data-href='finance6.html#RC1'>finance6</span></td></tr>
<tr><td>
cluster  dom f ->  real-membered  ;
</td><td><span data-href='finseq_9.html#FC43'>finseq_9</span></td></tr>
<tr><td>
cluster  complex-membered   ext-real-membered   real-membered   symmetrical   for    Element of K16(REAL);
</td><td><span data-href='funct_8.html#RC2'>funct_8</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like   complex-valued   ext-real-valued   real-valued   periodic   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='funct_9.html#RC2'>funct_9</span></td></tr>
<tr><td>
cluster REAL --> t -> t -periodic  ;
</td><td><span data-href='funct_9.html#FC1'>funct_9</span></td></tr>
<tr><td>
cluster REAL --> a ->  periodic  ;
</td><td><span data-href='funct_9.html#FC19'>funct_9</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like  V30( REAL , REAL )  complex-valued   ext-real-valued   real-valued  t -periodic   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='funct_9.html#RC4'>funct_9</span></td></tr>
<tr><td>
cluster V5([.0,1.])  Function-like  V30(C, REAL )  strictly-normalized   ->  normalized   for    Element of K16(K17(C,REAL));
</td><td><span data-href='fuznum_1.html#CC1'>fuznum_1</span></td></tr>
<tr><td>
cluster V1() V4(C) V5( REAL ) V5([.0,1.])  non  empty   Function-like   total  V30(C, REAL ) V39() V40() V41()  normalized   for    Element of K16(K17(C,REAL));
</td><td><span data-href='fuznum_1.html#RC1'>fuznum_1</span></td></tr>
<tr><td>
cluster  UMF REAL ->  f-convex  ;
</td><td><span data-href='fuznum_1.html#FC3'>fuznum_1</span></td></tr>
<tr><td>
cluster  EMF REAL ->  f-convex  ;
</td><td><span data-href='fuznum_1.html#FC4'>fuznum_1</span></td></tr>
<tr><td>
cluster  non  trivial  V49() V50() V51()  closed   closed_interval   for    Element of K16(REAL);
</td><td><span data-href='fuznum_1.html#RC2'>fuznum_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL ) V5([.0,1.])  non  empty   Function-like   total  V30( REAL , REAL ) V39() V40() V41()  triangular   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='fuznum_1.html#RC3'>fuznum_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL ) V5([.0,1.])  non  empty   Function-like   total  V30( REAL , REAL ) V39() V40() V41()  trapezoidal   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='fuznum_1.html#RC4'>fuznum_1</span></td></tr>
<tr><td>
cluster  Relation-like  C -defined   REAL  -valued  [.0,1.] -valued   non  empty   Function-like   total  V30(C, REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K16(K17(C,REAL));
</td><td><span data-href='fuzzy_1.html#RC1'>fuzzy_1</span></td></tr>
<tr><td>
cluster [.0,1.] -valued   Function-like  V30(X, REAL )  ->  real-valued   for    Element of K16(K17(X,REAL));
</td><td><span data-href='fuzzy_1.html#CC1'>fuzzy_1</span></td></tr>
<tr><td>
cluster V5([.0,1.])  Function-like   quasi_total   ->   for    Element of  bool [:C,REAL:];
</td><td><span data-href='fuzzy_2.html#CC1'>fuzzy_2</span></td></tr>
<tr><td>
cluster G .set (WeightSelector,X) ->  real-weighted  ;
</td><td><span data-href='glib_003.html#FC42'>glib_003</span></td></tr>
<tr><td>
cluster G .set (ELabelSelector,X) ->  real-elabeled  ;
</td><td><span data-href='glib_003.html#FC43'>glib_003</span></td></tr>
<tr><td>
cluster G .set (VLabelSelector,X) ->  real-vlabeled  ;
</td><td><span data-href='glib_003.html#FC45'>glib_003</span></td></tr>
<tr><td>
cluster  GoB (v1,v2) -> V3()  X_equal-in-line   Y_equal-in-column  ;
</td><td><span data-href='goboard2.html#FC3'>goboard2</span></td></tr>
<tr><td>
cluster  GoB (v1,v2) ->  Y_increasing-in-line   X_increasing-in-column  ;
</td><td><span data-href='goboard2.html#FC4'>goboard2</span></td></tr>
<tr><td>
cluster  UnusedVx (f,n) ->  finite  ;
</td><td><span data-href='graphsp.html#FC2'>graphsp</span></td></tr>
<tr><td>
cluster  OuterVx (f,n) ->  finite  ;
</td><td><span data-href='graphsp.html#FC3'>graphsp</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  additive   ->  subadditive   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC1'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  homogeneous   ->  positively_homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC2'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  semi-homogeneous   ->  positively_homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC3'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  semi-homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC4'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  absolutely_homogeneous   ->  semi-homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC5'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  positively_homogeneous   0-preserving   ->  semi-homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC6'>hahnban</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   REAL  -valued   Function-like   non  empty   total  V18( the carrier of V, REAL )  additive   homogeneous   absolutely_homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#RC1'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V33( the carrier of V, REAL )  additive   ->  subadditive   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban1.html#CC2'>hahnban1</span></td></tr>
<tr><td>
cluster  Function-like  V33( the carrier of V, REAL )  Real_homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban1.html#CC3'>hahnban1</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( REAL )  Function-like  V33( the carrier of V, REAL )  additive   0-preserving   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban1.html#RC2'>hahnban1</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( REAL )  Function-like  V33( the carrier of V, REAL )  additive   Real_homogeneous   homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban1.html#RC3'>hahnban1</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   COMPLEX  -valued   Function-like   complex-valued   C1-curve-like   for    Element of  bool [:REAL,COMPLEX:];
</td><td><span data-href='integr1c.html#RC1'>integr1c</span></td></tr>
<tr><td>
cluster  Re f ->  quasi_total   for  PartFunc of A,REAL;
</td><td><span data-href='integr16.html#FC3'>integr16</span></td></tr>
<tr><td>
cluster  Im f ->  quasi_total   for  PartFunc of A,REAL;
</td><td><span data-href='integr16.html#FC4'>integr16</span></td></tr>
<tr><td>
cluster  closed_interval   ->  compact   for    Element of  bool REAL;
</td><td><span data-href='integra1.html#CC1'>integra1</span></td></tr>
<tr><td>
cluster  non  empty   closed_interval   ->  real-bounded   for    Element of  bool REAL;
</td><td><span data-href='integra1.html#CC2'>integra1</span></td></tr>
<tr><td>
cluster  divs A ->  non  empty  ;
</td><td><span data-href='integra1.html#FC1'>integra1</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   for    Element of  divs A;
</td><td><span data-href='integra1.html#CC3'>integra1</span></td></tr>
<tr><td>
cluster   ->  FinSequence-like   real-valued   for    Element of  divs A;
</td><td><span data-href='integra1.html#CC4'>integra1</span></td></tr>
<tr><td>
cluster  upper_volume (f,D) ->  non  empty  ;
</td><td><span data-href='integra1.html#FC2'>integra1</span></td></tr>
<tr><td>
cluster  lower_volume (f,D) ->  non  empty  ;
</td><td><span data-href='integra1.html#FC3'>integra1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   complex-valued   ext-real-valued   real-valued   non-decreasing  V56()  FinSequence-like   FinSubsequence-like   for    FinSequence of  REAL ;
</td><td><span data-href='integra2.html#RC1'>integra2</span></td></tr>
<tr><td>
cluster  SgmX (RealOrd,A) ->  increasing  ;
</td><td><span data-href='jordan1h.html#FC3'>jordan1h</span></td></tr>
<tr><td>
cluster   ->  REAL  -valued   for    Element of  the carrier of (TOP-REAL n);
</td><td><span data-href='jordan2b.html#CC1'>jordan2b</span></td></tr>
<tr><td>
cluster  non  empty  V52() V53() V54()  finite   real-bounded   for    Element of K16(REAL);
</td><td><span data-href='jordan5a.html#RC2'>jordan5a</span></td></tr>
<tr><td>
cluster K275(a,b) ->  compact   for  Subset of REAL;
</td><td><span data-href='jordan5a.html#FC2'>jordan5a</span></td></tr>
<tr><td>
cluster  finite   ->  compact   for    Element of K16(REAL);
</td><td><span data-href='jordan5a.html#CC1'>jordan5a</span></td></tr>
<tr><td>
cluster [.0,1.] -valued   Function-like   quasi_total   ->  real-valued   for    Element of  bool [:X,REAL:];
</td><td><span data-href='lfuzzy_1.html#CC1'>lfuzzy_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [:X,X:] -defined   REAL  -valued  [.0,1.] -valued   Function-like   total   quasi_total   complex-valued   ext-real-valued   real-valued   reflexive   symmetric   transitive   antisymmetric   for    Element of  bool [:[:X,X:],REAL:];
</td><td><span data-href='lfuzzy_1.html#RC1'>lfuzzy_1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   NAT  -valued   REAL  -valued   INT  -valued   non  empty   Function-like  V28( omega ) V32( omega , REAL ) V39() V40() V41()  for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#RC1'>liouvil1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   NAT  -valued   REAL  -valued   non  empty   Function-like  V28( omega ) V32( omega , REAL ) V39() V40() V41()  positive-yielding   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#RC2'>liouvil1</span></td></tr>
<tr><td>
cluster  Function-like  V32( omega , REAL )  eventually-nonzero   ->  eventually-non-zero   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#CC1'>liouvil1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   non  empty   Function-like  V28( omega ) V32( omega , REAL ) V39() V40() V41()  eventually-non-zero   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#RC3'>liouvil1</span></td></tr>
<tr><td>
cluster  non-zero   Function-like   constant  V32( omega , REAL )  ->  eventually-non-zero   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#CC2'>liouvil1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   non  empty   Function-like  V28( omega ) V32( omega , REAL ) V39() V40() V41()  nonnegative-yielding   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#RC4'>liouvil1</span></td></tr>
<tr><td>
cluster K687(a,b) ->  closed_interval   for  Subset of REAL;
</td><td><span data-href='liouvil2.html#FC3'>liouvil2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   the carrier of F_Complex -valued   Function-like  V44( NAT , the carrier of F_Complex)  complex-valued   finite-Support   monic   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='liouvil2.html#RC5'>liouvil2</span></td></tr>
<tr><td>
cluster |.f.| ->  nonnegative  ;
</td><td><span data-href='lpspace2.html#FC1'>lpspace2</span></td></tr>
<tr><td>
cluster (n,n) --> 1 ->  Positive   for  Matrix of n,REAL;
</td><td><span data-href='matrix10.html#FC1'>matrix10</span></td></tr>
<tr><td>
cluster (n,n) --> (- 1) ->  Negative   for  Matrix of n,REAL;
</td><td><span data-href='matrix10.html#FC2'>matrix10</span></td></tr>
<tr><td>
cluster (n,n) --> (- 1) ->  Nonpositive   for  Matrix of n,REAL;
</td><td><span data-href='matrix10.html#FC3'>matrix10</span></td></tr>
<tr><td>
cluster (n,n) --> 1 ->  Nonnegative   for  Matrix of n,REAL;
</td><td><span data-href='matrix10.html#FC4'>matrix10</span></td></tr>
<tr><td>
cluster V4() V7( NAT ) V8(K227(REAL)) V23()  FinSequence-like   tabular  V125( REAL ,n,n)  Positive   Nonnegative   for    FinSequence of K227(REAL);
</td><td><span data-href='matrix10.html#RC1'>matrix10</span></td></tr>
<tr><td>
cluster V4() V7( NAT ) V8(K227(REAL)) V23()  FinSequence-like   tabular  V125( REAL ,n,n)  Negative   Nonpositive   for    FinSequence of K227(REAL);
</td><td><span data-href='matrix10.html#RC2'>matrix10</span></td></tr>
<tr><td>
cluster V4() V7( NAT ) V8(K227(REAL)) V23()  FinSequence-like   tabular   Positive   Nonnegative   for    FinSequence of K227(REAL);
</td><td><span data-href='matrix10.html#RC3'>matrix10</span></td></tr>
<tr><td>
cluster V4() V7( NAT ) V8(K227(REAL)) V23()  FinSequence-like   tabular   Negative   Nonpositive   for    FinSequence of K227(REAL);
</td><td><span data-href='matrix10.html#RC4'>matrix10</span></td></tr>
<tr><td>
cluster M @  ->  Positive  ;
</td><td><span data-href='matrix10.html#FC5'>matrix10</span></td></tr>
<tr><td>
cluster M @  ->  Negative  ;
</td><td><span data-href='matrix10.html#FC6'>matrix10</span></td></tr>
<tr><td>
cluster M @  ->  Nonpositive  ;
</td><td><span data-href='matrix10.html#FC7'>matrix10</span></td></tr>
<tr><td>
cluster M @  ->  Nonnegative  ;
</td><td><span data-href='matrix10.html#FC8'>matrix10</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   non  empty   Function-like  V36()  FinSequence-like   FinSubsequence-like   complex-valued   ext-real-valued   real-valued   ProbFinS   for    FinSequence of  REAL ;
</td><td><span data-href='matrprob.html#RC1'>matrprob</span></td></tr>
<tr><td>
cluster  tabular   Joint_Probability   ->  m-nonnegative   with_sum=1   for    FinSequence of REAL * ;
</td><td><span data-href='matrprob.html#CC1'>matrprob</span></td></tr>
<tr><td>
cluster  tabular   m-nonnegative   with_sum=1   ->  Joint_Probability   for    FinSequence of REAL * ;
</td><td><span data-href='matrprob.html#CC2'>matrprob</span></td></tr>
<tr><td>
cluster  Relation-like  V3()  NAT  -defined  REAL *  -valued   Function-like  V36()  FinSequence-like   FinSubsequence-like  V110()  tabular  V191()  Joint_Probability   for    FinSequence of REAL * ;
</td><td><span data-href='matrprob.html#RC3'>matrprob</span></td></tr>
<tr><td>
cluster  tabular   Conditional_Probability   ->  m-nonnegative   with_line_sum=1   for    FinSequence of REAL * ;
</td><td><span data-href='matrprob.html#CC3'>matrprob</span></td></tr>
<tr><td>
cluster  tabular   m-nonnegative   with_line_sum=1   ->  Conditional_Probability   for    FinSequence of REAL * ;
</td><td><span data-href='matrprob.html#CC4'>matrprob</span></td></tr>
<tr><td>
cluster  Relation-like  V3()  NAT  -defined  REAL *  -valued   Function-like  V36()  FinSequence-like   FinSubsequence-like  V110()  tabular  V191()  Conditional_Probability   for    FinSequence of REAL * ;
</td><td><span data-href='matrprob.html#RC4'>matrprob</span></td></tr>
<tr><td>
cluster  Sum M ->  non  empty   ProbFinS  ;
</td><td><span data-href='matrprob.html#FC1'>matrprob</span></td></tr>
<tr><td>
cluster  ColSum M ->  non  empty   ProbFinS  ;
</td><td><span data-href='matrprob.html#FC2'>matrprob</span></td></tr>
<tr><td>
cluster M @  -> V3() ;
</td><td><span data-href='matrprob.html#FC3'>matrprob</span></td></tr>
<tr><td>
cluster M @  ->  Joint_Probability  ;
</td><td><span data-href='matrprob.html#FC4'>matrprob</span></td></tr>
<tr><td>
cluster F | Y ->  positive-yielding  ;
</td><td><span data-href='matrtop1.html#FC1'>matrtop1</span></td></tr>
<tr><td>
cluster F | Y ->  negative-yielding  ;
</td><td><span data-href='matrtop1.html#FC2'>matrtop1</span></td></tr>
<tr><td>
cluster F | Y ->  nonpositive-yielding  ;
</td><td><span data-href='matrtop1.html#FC3'>matrtop1</span></td></tr>
<tr><td>
cluster F | Y ->  nonnegative-yielding  ;
</td><td><span data-href='matrtop1.html#FC4'>matrtop1</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   open_interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#RC1'>measure5</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   closed_interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#RC2'>measure5</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   right_open_interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#RC3'>measure5</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   left_open_interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#RC4'>measure5</span></td></tr>
<tr><td>
cluster  open_interval   ->  interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#CC1'>measure5</span></td></tr>
<tr><td>
cluster  closed_interval   ->  interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#CC2'>measure5</span></td></tr>
<tr><td>
cluster  right_open_interval   ->  interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#CC3'>measure5</span></td></tr>
<tr><td>
cluster  left_open_interval   ->  interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#CC4'>measure5</span></td></tr>
<tr><td>
cluster  empty   ->  open_interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#CC5'>measure5</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   interval   for    Element of  bool REAL;
</td><td><span data-href='measure6.html#RC1'>measure6</span></td></tr>
<tr><td>
cluster  REAL  ->  with_zero  ;
</td><td><span data-href='measure6.html#FC1'>measure6</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   without_zero   for    Element of  bool REAL;
</td><td><span data-href='measure6.html#RC4'>measure6</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   with_zero   for    Element of  bool REAL;
</td><td><span data-href='measure6.html#RC5'>measure6</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   real-bounded   closed   for    Element of  bool REAL;
</td><td><span data-href='measure6.html#RC6'>measure6</span></td></tr>
<tr><td>
cluster  Inv X ->  non  empty  ;
</td><td><span data-href='measure6.html#FC4'>measure6</span></td></tr>
<tr><td>
cluster  Inv X ->  without_zero  ;
</td><td><span data-href='measure6.html#FC5'>measure6</span></td></tr>
<tr><td>
cluster  Svc A ->  non  empty  ;
</td><td><span data-href='measure7.html#FC1'>measure7</span></td></tr>
<tr><td>
cluster  REAL  ->  real-membered  ;
</td><td><span data-href='membered.html#FC3'>membered</span></td></tr>
<tr><td>
cluster  REAL  ->  add-closed  ;
</td><td><span data-href='membered.html#FC56'>membered</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   REAL  -valued   Function-like  V54() V55() V56()  nonnegative   for    Element of K16(K17(X,REAL));
</td><td><span data-href='mesfun6c.html#RC1'>mesfun6c</span></td></tr>
<tr><td>
cluster f to_power k ->  nonnegative  ;
</td><td><span data-href='mesfun6c.html#FC1'>mesfun6c</span></td></tr>
<tr><td>
cluster  R_EAL f ->  total  ;
</td><td><span data-href='mesfun7c.html#FC1'>mesfun7c</span></td></tr>
<tr><td>
cluster  R_EAL f ->  with_the_same_dom  ;
</td><td><span data-href='mesfun7c.html#FC2'>mesfun7c</span></td></tr>
<tr><td>
cluster  MetrStruct(# A,r #) ->  non  empty  ;
</td><td><span data-href='metric_3.html#FC1'>metric_3</span></td></tr>
<tr><td>
cluster f | A -> A -defined   for  PartFunc of Z,REAL;
</td><td><span data-href='moebius3.html#FC1'>moebius3</span></td></tr>
<tr><td>
cluster  non  empty   ordinal   for    Element of  bool REAL;
</td><td><span data-href='nat_1.html#RC4'>nat_1</span></td></tr>
<tr><td>
cluster   ->  real   for    Element of D;
</td><td><span data-href='nat_lat.html#CC1'>nat_lat</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( the carrier of F)  Function-like   RestFunc-like   for    Element of K16(K17(REAL, the carrier of F));
</td><td><span data-href='ndiff_3.html#RC1'>ndiff_3</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( the carrier of F) V6()  Function-like   total   quasi_total   linear   for    Element of K16(K17(REAL, the carrier of F));
</td><td><span data-href='ndiff_3.html#RC2'>ndiff_3</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( the carrier of F) V6()  Function-like   total   quasi_total   differentiable   for    Element of K16(K17(REAL, the carrier of F));
</td><td><span data-href='ndiff_3.html#RC3'>ndiff_3</span></td></tr>
<tr><td>
cluster REAL --> (0* n) ->  differentiable   for  Function of REAL,(REAL n);
</td><td><span data-href='ndiff_4.html#FC1'>ndiff_4</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL n -valued   non  empty   Function-like   total   quasi_total   Function-yielding  V237() V238() V239()  differentiable   for    Element of K16(K17(REAL,(REAL n)));
</td><td><span data-href='ndiff_4.html#RC1'>ndiff_4</span></td></tr>
<tr><td>
cluster <*s*> ->  REAL  -valued  ;
</td><td><span data-href='newton02.html#FC2'>newton02</span></td></tr>
<tr><td>
cluster (f | n) /^ n ->  empty  ;
</td><td><span data-href='newton02.html#FC6'>newton02</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -valued   ->  COMPLEX  -valued   for    set ;
</td><td><span data-href='newton04.html#CC1'>newton04</span></td></tr>
<tr><td>
cluster  Relation-like   RAT  -valued   ->  REAL  -valued   for    set ;
</td><td><span data-href='newton04.html#CC2'>newton04</span></td></tr>
<tr><td>
cluster  Relation-like   INT  -valued   ->  REAL  -valued   for    set ;
</td><td><span data-href='newton04.html#CC5'>newton04</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -valued   ->  REAL  -valued   for    set ;
</td><td><span data-href='newton04.html#CC9'>newton04</span></td></tr>
<tr><td>
cluster  Relation-like   real-valued   ->  REAL  -valued   for    set ;
</td><td><span data-href='newton04.html#CC11'>newton04</span></td></tr>
<tr><td>
cluster f . i ->  non  negative  ;
</td><td><span data-href='newton04.html#FC12'>newton04</span></td></tr>
<tr><td>
cluster f . i ->  non  positive  ;
</td><td><span data-href='newton04.html#FC13'>newton04</span></td></tr>
<tr><td>
cluster (f | j) . i ->  non  negative  ;
</td><td><span data-href='newton04.html#FC14'>newton04</span></td></tr>
<tr><td>
cluster (f /^ j) . i ->  non  negative  ;
</td><td><span data-href='newton04.html#FC15'>newton04</span></td></tr>
<tr><td>
cluster  Sum f ->  non  negative  ;
</td><td><span data-href='newton04.html#FC17'>newton04</span></td></tr>
<tr><td>
cluster  Product f ->  non  negative  ;
</td><td><span data-href='newton04.html#FC18'>newton04</span></td></tr>
<tr><td>
cluster  Sum f ->  non  positive  ;
</td><td><span data-href='newton04.html#FC19'>newton04</span></td></tr>
<tr><td>
cluster f . a ->  non  negative  ;
</td><td><span data-href='newton04.html#FC20'>newton04</span></td></tr>
<tr><td>
cluster f . a ->  non  positive  ;
</td><td><span data-href='newton04.html#FC21'>newton04</span></td></tr>
<tr><td>
cluster (f | n) /^ n ->  empty  ;
</td><td><span data-href='newton04.html#FC23'>newton04</span></td></tr>
<tr><td>
cluster f /^ (max ((len f),n)) ->  empty  ;
</td><td><span data-href='newton04.html#FC24'>newton04</span></td></tr>
<tr><td>
cluster f | n ->  nonnegative-yielding  ;
</td><td><span data-href='newton04.html#FC27'>newton04</span></td></tr>
<tr><td>
cluster f /^ n ->  nonnegative-yielding  ;
</td><td><span data-href='newton04.html#FC28'>newton04</span></td></tr>
<tr><td>
cluster f - (min f) ->  nonnegative-yielding  ;
</td><td><span data-href='newton04.html#FC29'>newton04</span></td></tr>
<tr><td>
cluster f - (max f) ->  nonpositive-yielding  ;
</td><td><span data-href='newton04.html#FC30'>newton04</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  continuous   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC1'>nfcont_3</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   the carrier of S -valued   Function-like   continuous   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#RC1'>nfcont_3</span></td></tr>
<tr><td>
cluster f | X ->  continuous   for  PartFunc of REAL, the carrier of S;
</td><td><span data-href='nfcont_3.html#FC1'>nfcont_3</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  continuous   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC2'>nfcont_3</span></td></tr>
<tr><td>
cluster f | X ->  continuous   for  PartFunc of REAL, the carrier of S;
</td><td><span data-href='nfcont_3.html#FC2'>nfcont_3</span></td></tr>
<tr><td>
cluster f1 + f2 ->  continuous   for  PartFunc of REAL, the carrier of S;
</td><td><span data-href='nfcont_3.html#FC3'>nfcont_3</span></td></tr>
<tr><td>
cluster f1 - f2 ->  continuous   for  PartFunc of REAL, the carrier of S;
</td><td><span data-href='nfcont_3.html#FC4'>nfcont_3</span></td></tr>
<tr><td>
cluster r (#) f ->  continuous   for  PartFunc of REAL, the carrier of S;
</td><td><span data-href='nfcont_3.html#FC5'>nfcont_3</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  Lipschitzian   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC3'>nfcont_3</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   the carrier of S -valued   empty   Function-like   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#RC2'>nfcont_3</span></td></tr>
<tr><td>
cluster f | X ->  Lipschitzian   for  PartFunc of REAL, the carrier of S;
</td><td><span data-href='nfcont_3.html#FC6'>nfcont_3</span></td></tr>
<tr><td>
cluster f1 + f2 ->  Lipschitzian   for  PartFunc of REAL, the carrier of S;
</td><td><span data-href='nfcont_3.html#FC7'>nfcont_3</span></td></tr>
<tr><td>
cluster f1 - f2 ->  Lipschitzian   for  PartFunc of REAL, the carrier of S;
</td><td><span data-href='nfcont_3.html#FC8'>nfcont_3</span></td></tr>
<tr><td>
cluster p (#) f ->  Lipschitzian   for  PartFunc of REAL, the carrier of S;
</td><td><span data-href='nfcont_3.html#FC9'>nfcont_3</span></td></tr>
<tr><td>
cluster ||.f.|| ->  Lipschitzian   for  PartFunc of REAL,REAL;
</td><td><span data-href='nfcont_3.html#FC10'>nfcont_3</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  Lipschitzian   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC4'>nfcont_3</span></td></tr>
<tr><td>
cluster  Function-like   Lipschitzian   ->  continuous   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC5'>nfcont_3</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC1'>nfcont_4</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL n -valued   Function-like  V158() V231() V232() V233()  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#RC1'>nfcont_4</span></td></tr>
<tr><td>
cluster f | X ->  continuous   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC1'>nfcont_4</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC2'>nfcont_4</span></td></tr>
<tr><td>
cluster f | X ->  continuous   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC2'>nfcont_4</span></td></tr>
<tr><td>
cluster f1 + f2 ->  continuous   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC3'>nfcont_4</span></td></tr>
<tr><td>
cluster r (#) f ->  continuous   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC4'>nfcont_4</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  Lipschitzian   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC3'>nfcont_4</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL n -valued   empty   Function-like  V158() V231() V232() V233()  for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#RC2'>nfcont_4</span></td></tr>
<tr><td>
cluster f | X ->  Lipschitzian   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC5'>nfcont_4</span></td></tr>
<tr><td>
cluster f1 + f2 ->  Lipschitzian   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC6'>nfcont_4</span></td></tr>
<tr><td>
cluster f1 - f2 ->  Lipschitzian   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC7'>nfcont_4</span></td></tr>
<tr><td>
cluster p (#) f ->  Lipschitzian   for  PartFunc of REAL,(REAL n);
</td><td><span data-href='nfcont_4.html#FC8'>nfcont_4</span></td></tr>
<tr><td>
cluster |.f.| ->  Lipschitzian   for  PartFunc of REAL,REAL;
</td><td><span data-href='nfcont_4.html#FC9'>nfcont_4</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  Lipschitzian   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC4'>nfcont_4</span></td></tr>
<tr><td>
cluster  Function-like   Lipschitzian   ->  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC5'>nfcont_4</span></td></tr>
<tr><td>
cluster ||.f.|| ->  REAL  -valued  ;
</td><td><span data-href='normsp_0.html#FC1'>normsp_0</span></td></tr>
<tr><td>
cluster  REAL  ->  non  empty  ;
</td><td><span data-href='numbers.html#FC1'>numbers</span></td></tr>
<tr><td>
cluster  REAL  ->  infinite  ;
</td><td><span data-href='numbers.html#FC8'>numbers</span></td></tr>
<tr><td>
cluster  ContinuousFunctions (X,Y) ->  non  empty  ;
</td><td><span data-href='ordeq_01.html#FC2'>ordeq_01</span></td></tr>
<tr><td>
cluster  ContinuousFunctions (X,Y) ->  linearly-closed  ;
</td><td><span data-href='ordeq_01.html#FC3'>ordeq_01</span></td></tr>
<tr><td>
cluster  R_VectorSpace_of_ContinuousFunctions (X,Y) ->  strict  ;
</td><td><span data-href='ordeq_01.html#FC4'>ordeq_01</span></td></tr>
<tr><td>
cluster  R_NormSpace_of_ContinuousFunctions (X,Y) ->  non  empty   right_complementable   Abelian   add-associative   right_zeroed   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   discerning   reflexive   strict   RealNormSpace-like  ;
</td><td><span data-href='ordeq_01.html#FC5'>ordeq_01</span></td></tr>
<tr><td>
cluster  closed   for    Element of K16( the carrier of (R_NormSpace_of_BoundedFunctions (X,Y)));
</td><td><span data-href='ordeq_01.html#RC1'>ordeq_01</span></td></tr>
<tr><td>
cluster  R_NormSpace_of_ContinuousFunctions (X,Y) ->  non  empty   strict   complete  ;
</td><td><span data-href='ordeq_01.html#FC6'>ordeq_01</span></td></tr>
<tr><td>
cluster f * g ->  positive-yielding  ;
</td><td><span data-href='orders_5.html#FC4'>orders_5</span></td></tr>
<tr><td>
cluster f * g ->  negative-yielding  ;
</td><td><span data-href='orders_5.html#FC5'>orders_5</span></td></tr>
<tr><td>
cluster f * g ->  nonpositive-yielding  ;
</td><td><span data-href='orders_5.html#FC6'>orders_5</span></td></tr>
<tr><td>
cluster f * g ->  nonnegative-yielding  ;
</td><td><span data-href='orders_5.html#FC7'>orders_5</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   REAL  -valued   Function-like   total   quasi_total  V53() V54() V55()  nonnegative-yielding   finite-support   for    Element of K16(K17(X,REAL));
</td><td><span data-href='orders_5.html#RC3'>orders_5</span></td></tr>
<tr><td>
cluster  - f ->  finite-support  ;
</td><td><span data-href='orders_5.html#FC9'>orders_5</span></td></tr>
<tr><td>
cluster  eqSupport (f,X) ->  trivial  ;
</td><td><span data-href='orders_5.html#FC24'>orders_5</span></td></tr>
<tr><td>
cluster  eqSumOf f ->  nonnegative-yielding  ;
</td><td><span data-href='orders_5.html#FC25'>orders_5</span></td></tr>
<tr><td>
cluster D eqSumOf f ->  nonnegative-yielding  ;
</td><td><span data-href='orders_5.html#FC26'>orders_5</span></td></tr>
<tr><td>
cluster  eqSumOf f ->  finite-support  ;
</td><td><span data-href='orders_5.html#FC27'>orders_5</span></td></tr>
<tr><td>
cluster D eqSumOf f ->  finite-support  ;
</td><td><span data-href='orders_5.html#FC28'>orders_5</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   REAL  -valued   Function-like   total  V36(X, REAL )  complex-valued   ext-real-valued   real-valued   negative-yielding   for    Element of K16(K17(X,REAL));
</td><td><span data-href='partfun3.html#RC1'>partfun3</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   REAL  -valued   Function-like   total  V36(X, REAL )  complex-valued   ext-real-valued   real-valued   positive-yielding   for    Element of K16(K17(X,REAL));
</td><td><span data-href='partfun3.html#RC2'>partfun3</span></td></tr>
<tr><td>
cluster f + g ->  nonpositive-yielding  ;
</td><td><span data-href='partfun3.html#FC12'>partfun3</span></td></tr>
<tr><td>
cluster f + g ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC13'>partfun3</span></td></tr>
<tr><td>
cluster f + g ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC14'>partfun3</span></td></tr>
<tr><td>
cluster f + g ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC15'>partfun3</span></td></tr>
<tr><td>
cluster f + g ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC16'>partfun3</span></td></tr>
<tr><td>
cluster f + g ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC17'>partfun3</span></td></tr>
<tr><td>
cluster f - g ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC18'>partfun3</span></td></tr>
<tr><td>
cluster f - g ->  nonpositive-yielding  ;
</td><td><span data-href='partfun3.html#FC19'>partfun3</span></td></tr>
<tr><td>
cluster f - g ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC20'>partfun3</span></td></tr>
<tr><td>
cluster f - g ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC21'>partfun3</span></td></tr>
<tr><td>
cluster f - g ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC22'>partfun3</span></td></tr>
<tr><td>
cluster f - g ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC23'>partfun3</span></td></tr>
<tr><td>
cluster f (#) g ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC24'>partfun3</span></td></tr>
<tr><td>
cluster f (#) g ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC25'>partfun3</span></td></tr>
<tr><td>
cluster f (#) g ->  nonpositive-yielding  ;
</td><td><span data-href='partfun3.html#FC26'>partfun3</span></td></tr>
<tr><td>
cluster f (#) g ->  nonpositive-yielding  ;
</td><td><span data-href='partfun3.html#FC27'>partfun3</span></td></tr>
<tr><td>
cluster f (#) g ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC28'>partfun3</span></td></tr>
<tr><td>
cluster f (#) g ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC29'>partfun3</span></td></tr>
<tr><td>
cluster f (#) g ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC30'>partfun3</span></td></tr>
<tr><td>
cluster f (#) g ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC31'>partfun3</span></td></tr>
<tr><td>
cluster f (#) g ->  non-empty  ;
</td><td><span data-href='partfun3.html#FC32'>partfun3</span></td></tr>
<tr><td>
cluster f (#) f ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC33'>partfun3</span></td></tr>
<tr><td>
cluster r (#) f ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC34'>partfun3</span></td></tr>
<tr><td>
cluster r (#) f ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC35'>partfun3</span></td></tr>
<tr><td>
cluster r (#) f ->  nonpositive-yielding  ;
</td><td><span data-href='partfun3.html#FC36'>partfun3</span></td></tr>
<tr><td>
cluster r (#) f ->  nonpositive-yielding  ;
</td><td><span data-href='partfun3.html#FC37'>partfun3</span></td></tr>
<tr><td>
cluster r (#) f ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC38'>partfun3</span></td></tr>
<tr><td>
cluster r (#) f ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC39'>partfun3</span></td></tr>
<tr><td>
cluster r (#) f ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC40'>partfun3</span></td></tr>
<tr><td>
cluster r (#) f ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC41'>partfun3</span></td></tr>
<tr><td>
cluster r (#) f ->  non-empty  ;
</td><td><span data-href='partfun3.html#FC42'>partfun3</span></td></tr>
<tr><td>
cluster f / g ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC43'>partfun3</span></td></tr>
<tr><td>
cluster f / g ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC44'>partfun3</span></td></tr>
<tr><td>
cluster f / g ->  nonpositive-yielding  ;
</td><td><span data-href='partfun3.html#FC45'>partfun3</span></td></tr>
<tr><td>
cluster f / g ->  nonpositive-yielding  ;
</td><td><span data-href='partfun3.html#FC46'>partfun3</span></td></tr>
<tr><td>
cluster f / g ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC47'>partfun3</span></td></tr>
<tr><td>
cluster f / g ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC48'>partfun3</span></td></tr>
<tr><td>
cluster f / g ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC49'>partfun3</span></td></tr>
<tr><td>
cluster f / g ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC50'>partfun3</span></td></tr>
<tr><td>
cluster f / f ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC51'>partfun3</span></td></tr>
<tr><td>
cluster f / g ->  non-empty  ;
</td><td><span data-href='partfun3.html#FC52'>partfun3</span></td></tr>
<tr><td>
cluster  Inv f ->  nonpositive-yielding  ;
</td><td><span data-href='partfun3.html#FC53'>partfun3</span></td></tr>
<tr><td>
cluster  Inv f ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC54'>partfun3</span></td></tr>
<tr><td>
cluster  Inv f ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC55'>partfun3</span></td></tr>
<tr><td>
cluster  Inv f ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC56'>partfun3</span></td></tr>
<tr><td>
cluster  Inv f ->  non-empty  ;
</td><td><span data-href='partfun3.html#FC57'>partfun3</span></td></tr>
<tr><td>
cluster  - f ->  non-empty  ;
</td><td><span data-href='partfun3.html#FC58'>partfun3</span></td></tr>
<tr><td>
cluster  - f ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC59'>partfun3</span></td></tr>
<tr><td>
cluster  - f ->  nonpositive-yielding  ;
</td><td><span data-href='partfun3.html#FC60'>partfun3</span></td></tr>
<tr><td>
cluster  - f ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC61'>partfun3</span></td></tr>
<tr><td>
cluster  - f ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC62'>partfun3</span></td></tr>
<tr><td>
cluster |.f.| ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC63'>partfun3</span></td></tr>
<tr><td>
cluster |.f.| ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC64'>partfun3</span></td></tr>
<tr><td>
cluster f ^  ->  nonpositive-yielding  ;
</td><td><span data-href='partfun3.html#FC65'>partfun3</span></td></tr>
<tr><td>
cluster f ^  ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC66'>partfun3</span></td></tr>
<tr><td>
cluster f ^  ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC67'>partfun3</span></td></tr>
<tr><td>
cluster f ^  ->  negative-yielding  ;
</td><td><span data-href='partfun3.html#FC68'>partfun3</span></td></tr>
<tr><td>
cluster f ^  ->  non-empty  ;
</td><td><span data-href='partfun3.html#FC69'>partfun3</span></td></tr>
<tr><td>
cluster  sqrt f ->  nonnegative-yielding  ;
</td><td><span data-href='partfun3.html#FC71'>partfun3</span></td></tr>
<tr><td>
cluster  sqrt f ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC72'>partfun3</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of T) V5( REAL )  non  empty   Function-like  V32( the carrier of T) V36( the carrier of T, REAL ) V145() V146() V147()  continuous   positive-yielding   for    Element of K16(K17( the carrier of T,REAL));
</td><td><span data-href='partfun4.html#RC1'>partfun4</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of T) V5( REAL )  non  empty   Function-like  V32( the carrier of T) V36( the carrier of T, REAL ) V145() V146() V147()  continuous   negative-yielding   for    Element of K16(K17( the carrier of T,REAL));
</td><td><span data-href='partfun4.html#RC2'>partfun4</span></td></tr>
<tr><td>
cluster  Function-like   RestFunc-like   ->  total   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='pdiff_3.html#CC1'>pdiff_3</span></td></tr>
<tr><td>
cluster  [#] REAL ->  open  ;
</td><td><span data-href='pdiffeq1.html#FC1'>pdiffeq1</span></td></tr>
<tr><td>
cluster  Function-like  V28( REAL , REAL )  differentiable   ->  continuous   for    Element of K10(K11(REAL,REAL));
</td><td><span data-href='polydiff.html#CC1'>polydiff</span></td></tr>
<tr><td>
cluster  Function-like   constant  V28( REAL , REAL )  ->  differentiable   for    Element of K10(K11(REAL,REAL));
</td><td><span data-href='polydiff.html#CC2'>polydiff</span></td></tr>
<tr><td>
cluster  id REAL ->  differentiable   for  Function of REAL,REAL;
</td><td><span data-href='polydiff.html#FC1'>polydiff</span></td></tr>
<tr><td>
cluster f + g ->  differentiable   for  Function of REAL,REAL;
</td><td><span data-href='polydiff.html#FC3'>polydiff</span></td></tr>
<tr><td>
cluster f - g ->  differentiable   for  Function of REAL,REAL;
</td><td><span data-href='polydiff.html#FC4'>polydiff</span></td></tr>
<tr><td>
cluster f (#) g ->  differentiable   for  Function of REAL,REAL;
</td><td><span data-href='polydiff.html#FC5'>polydiff</span></td></tr>
<tr><td>
cluster r + f ->  differentiable   for  Function of REAL,REAL;
</td><td><span data-href='polydiff.html#FC6'>polydiff</span></td></tr>
<tr><td>
cluster r (#) f ->  differentiable   for  Function of REAL,REAL;
</td><td><span data-href='polydiff.html#FC7'>polydiff</span></td></tr>
<tr><td>
cluster f - r ->  differentiable   for  Function of REAL,REAL;
</td><td><span data-href='polydiff.html#FC8'>polydiff</span></td></tr>
<tr><td>
cluster  - f ->  differentiable   for  Function of REAL,REAL;
</td><td><span data-href='polydiff.html#FC9'>polydiff</span></td></tr>
<tr><td>
cluster f ^2  ->  differentiable   for  Function of REAL,REAL;
</td><td><span data-href='polydiff.html#FC10'>polydiff</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   RAT  -valued   Function-like  V11() V14( omega ) V18( omega , REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K19(K20(omega,REAL));
</td><td><span data-href='prepower.html#RC1'>prepower</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of T -defined   REAL  -valued   Function-like  V31( the carrier of T) V32( the carrier of T, REAL )  complex-valued   ext-real-valued   real-valued   bounded   for    Element of K32(K33( the carrier of T,REAL));
</td><td><span data-href='pscomp_1.html#RC1'>pscomp_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of T -defined   REAL  -valued   Function-like  V31( the carrier of T) V32( the carrier of T, REAL )  complex-valued   ext-real-valued   real-valued   continuous   for    Element of K32(K33( the carrier of T,REAL));
</td><td><span data-href='pscomp_1.html#RC2'>pscomp_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of S -defined   REAL  -valued   Function-like  V31( the carrier of S) V32( the carrier of S, REAL )  complex-valued   ext-real-valued   real-valued   continuous   for    Element of K32(K33( the carrier of S,REAL));
</td><td><span data-href='pscomp_1.html#RC3'>pscomp_1</span></td></tr>
<tr><td>
cluster  Function-like  V32( the carrier of T, REAL )  continuous   ->  with_max   with_min   bounded   for    Element of K32(K33( the carrier of T,REAL));
</td><td><span data-href='pscomp_1.html#CC2'>pscomp_1</span></td></tr>
<tr><td>
cluster  Relation-like  Omega -defined   REAL  -valued   Function-like   non  empty   total   quasi_total  V153() V154() V155()  nonnegative   for    Real-Valued-Random-Variable of Sigma;
</td><td><span data-href='random_2.html#RC1'>random_2</span></td></tr>
<tr><td>
cluster ].p,q.[ ->  open   for  Subset of REAL;
</td><td><span data-href='rcomp_1.html#FC1'>rcomp_1</span></td></tr>
<tr><td>
cluster [.p,q.] ->  closed   for  Subset of REAL;
</td><td><span data-href='rcomp_1.html#FC2'>rcomp_1</span></td></tr>
<tr><td>
cluster  compact   ->  closed   for    Element of K19(REAL);
</td><td><span data-href='rcomp_1.html#CC1'>rcomp_1</span></td></tr>
<tr><td>
cluster V57() V58() V59()  open   for    Element of K19(REAL);
</td><td><span data-href='rcomp_1.html#RC1'>rcomp_1</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   open   real-bounded   interval   for    Element of K34(REAL);
</td><td><span data-href='rcomp_3.html#RC1'>rcomp_3</span></td></tr>
<tr><td>
cluster  [#] REAL ->  non  bounded_below   non  bounded_above   interval  ;
</td><td><span data-href='rcomp_3.html#FC11'>rcomp_3</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   closed   open   non  real-bounded   interval   for    Element of K34(REAL);
</td><td><span data-href='rcomp_3.html#RC2'>rcomp_3</span></td></tr>
<tr><td>
cluster  R^1 A ->  interval  ;
</td><td><span data-href='rcomp_3.html#FC13'>rcomp_3</span></td></tr>
<tr><td>
cluster   ->  real-membered   for    Element of X;
</td><td><span data-href='rcomp_3.html#CC4'>rcomp_3</span></td></tr>
<tr><td>
cluster   ->  real   for    Element of  REAL ;
</td><td><span data-href='real_1.html#CC1'>real_1</span></td></tr>
<tr><td>
cluster V19()  ext-real   positive   real   for    Element of  REAL ;
</td><td><span data-href='real_1.html#RC2'>real_1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   INT  -valued  V6()  Function-like  V29( omega ) V33( omega , REAL ) V67() V68() V69()  for    Element of K16(K17(omega,REAL));
</td><td><span data-href='real_3.html#RC1'>real_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   finite   FinSequence-like   FinSubsequence-like   complex-valued   ext-real-valued   real-valued   non-increasing   for    FinSequence of  REAL ;
</td><td><span data-href='rfinseq.html#RC1'>rfinseq</span></td></tr>
<tr><td>
cluster  chi (X,C) ->  total   for  PartFunc of C,REAL;
</td><td><span data-href='rfunct_1.html#FC5'>rfunct_1</span></td></tr>
<tr><td>
cluster f1 + f2 ->  constant  ;
</td><td><span data-href='rfunct_1.html#FC18'>rfunct_1</span></td></tr>
<tr><td>
cluster f1 - f2 ->  constant  ;
</td><td><span data-href='rfunct_1.html#FC19'>rfunct_1</span></td></tr>
<tr><td>
cluster f1 (#) f2 ->  constant  ;
</td><td><span data-href='rfunct_1.html#FC20'>rfunct_1</span></td></tr>
<tr><td>
cluster  - f ->  constant  ;
</td><td><span data-href='rfunct_1.html#FC21'>rfunct_1</span></td></tr>
<tr><td>
cluster |.f.| ->  constant  ;
</td><td><span data-href='rfunct_1.html#FC22'>rfunct_1</span></td></tr>
<tr><td>
cluster p (#) f ->  constant  ;
</td><td><span data-href='rfunct_1.html#FC23'>rfunct_1</span></td></tr>
<tr><td>
cluster  Function-like   non-decreasing   ->  monotone   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC1'>rfunct_2</span></td></tr>
<tr><td>
cluster  Function-like   non-increasing   ->  monotone   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC2'>rfunct_2</span></td></tr>
<tr><td>
cluster  Function-like   non  monotone   ->  non  non-decreasing   non  non-increasing   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC3'>rfunct_2</span></td></tr>
<tr><td>
cluster  Function-like   non-decreasing   non-increasing   -> V8()  for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC4'>rfunct_2</span></td></tr>
<tr><td>
cluster  Function-like  V8()  ->  non-decreasing   non-increasing   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC5'>rfunct_2</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL  -valued   Function-like   trivial   complex-valued   ext-real-valued   real-valued   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#RC1'>rfunct_2</span></td></tr>
<tr><td>
cluster h | X ->  increasing   for  PartFunc of REAL,REAL;
</td><td><span data-href='rfunct_2.html#FC2'>rfunct_2</span></td></tr>
<tr><td>
cluster h | X ->  decreasing   for  PartFunc of REAL,REAL;
</td><td><span data-href='rfunct_2.html#FC3'>rfunct_2</span></td></tr>
<tr><td>
cluster h | X ->  non-decreasing   for  PartFunc of REAL,REAL;
</td><td><span data-href='rfunct_2.html#FC4'>rfunct_2</span></td></tr>
<tr><td>
cluster  max+ F ->  finite  ;
</td><td><span data-href='rfunct_3.html#FC1'>rfunct_3</span></td></tr>
<tr><td>
cluster  max- F ->  finite  ;
</td><td><span data-href='rfunct_3.html#FC2'>rfunct_3</span></td></tr>
<tr><td>
cluster  RLTopStruct(# X,O,F,G,T #) ->  non  empty  ;
</td><td><span data-href='rltopsp1.html#FC5'>rltopsp1</span></td></tr>
<tr><td>
cluster  RLSStruct(# ZS,O,F,G #) ->  non  empty  ;
</td><td><span data-href='rlvect_1.html#FC1'>rlvect_1</span></td></tr>
<tr><td>
cluster  NORMSTR(# X,Z,A,M,N #) ->  non  empty  ;
</td><td><span data-href='rsspace3.html#FC4'>rsspace3</span></td></tr>
<tr><td>
cluster F1 (#) F ->  FinSequence-like  ;
</td><td><span data-href='rvsum_1.html#FC1'>rvsum_1</span></td></tr>
<tr><td>
cluster  Relation-like   empty-yielding   omega  -defined   REAL  -valued   non  empty   Function-like  V32( omega ) V33( omega , REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K16(K17(omega,REAL));
</td><td><span data-href='rvsum_4.html#RC2'>rvsum_4</span></td></tr>
<tr><td>
cluster  empty-yielding   Function-like  V33( omega , REAL )  ->  absolutely_summable   for    Element of K16(K17(omega,REAL));
</td><td><span data-href='rvsum_4.html#CC3'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   Sequence-like   Function-like   finite  n -element  V61()  complex-valued   ext-real-valued   real-valued   natural-valued   for    set ;
</td><td><span data-href='rvsum_4.html#RC5'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   empty-yielding   omega  -defined   REAL  -valued   non  empty   Function-like  V32( omega ) V33( omega , REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K16(K17(omega,REAL));
</td><td><span data-href='rvsum_4.html#RC7'>rvsum_4</span></td></tr>
<tr><td>
cluster  Function-like  V33( omega , REAL )  ->  Sequence-like   for    Element of K16(K17(omega,REAL));
</td><td><span data-href='rvsum_4.html#CC5'>rvsum_4</span></td></tr>
<tr><td>
cluster  Shift (f,1) ->  FinSequence-like  ;
</td><td><span data-href='rvsum_4.html#FC28'>rvsum_4</span></td></tr>
<tr><td>
cluster (Sequel f) ^\ (dom f) ->  empty-yielding  ;
</td><td><span data-href='rvsum_4.html#FC29'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   non-zero   complex-valued   ext-real-valued   real-valued   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seq_1.html#RC1'>seq_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   constant   non  empty   total  V18( NAT , REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seq_1.html#RC2'>seq_1</span></td></tr>
<tr><td>
cluster  Function-like   constant  V32( NAT , REAL )  ->  convergent   for    Element of K21(K22(NAT,REAL));
</td><td><span data-href='seq_2.html#CC3'>seq_2</span></td></tr>
<tr><td>
cluster  Function-like  V32( NAT , REAL )  convergent   ->  bounded   for    Element of K21(K22(NAT,REAL));
</td><td><span data-href='seq_2.html#CC4'>seq_2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , REAL ) V47()  bounded_above   ->  convergent   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='seq_4.html#CC1'>seq_4</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , REAL ) V48()  bounded_below   ->  convergent   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='seq_4.html#CC2'>seq_4</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , REAL )  monotone   bounded   ->  convergent   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='seq_4.html#CC3'>seq_4</span></td></tr>
<tr><td>
cluster  Incr v ->  non  empty   increasing  ;
</td><td><span data-href='seq_4.html#FC4'>seq_4</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   bounded_below   bounded_above   for    Element of  bool REAL;
</td><td><span data-href='seq_4.html#RC1'>seq_4</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  non-decreasing   non-increasing   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seqm_3.html#CC1'>seqm_3</span></td></tr>
<tr><td>
cluster  Function-like   non-decreasing   non-increasing   ->  constant   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seqm_3.html#CC2'>seqm_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   non  empty   total  V18( NAT , REAL )  complex-valued   ext-real-valued   real-valued   natural-valued   increasing   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seqm_3.html#RC1'>seqm_3</span></td></tr>
<tr><td>
cluster   ->  real-valued   for    FinSequence of  REAL ;
</td><td><span data-href='seqm_3.html#CC4'>seqm_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   non  empty   complex-valued   ext-real-valued   real-valued   increasing  V61()  FinSequence-like   FinSubsequence-like   for    FinSequence of  REAL ;
</td><td><span data-href='seqm_3.html#RC3'>seqm_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   constant   complex-valued   ext-real-valued   real-valued  V61()  FinSequence-like   FinSubsequence-like   for    FinSequence of  REAL ;
</td><td><span data-href='seqm_3.html#RC4'>seqm_3</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , REAL )  absolutely_summable   ->  summable   for    Element of K19(K20(omega,REAL));
</td><td><span data-href='series_1.html#CC1'>series_1</span></td></tr>
<tr><td>
cluster K74(r1,r2) ->  real-bounded   for  Subset of REAL;
</td><td><span data-href='sprect_1.html#FC9'>sprect_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   NAT  -defined   REAL  -valued   Function-like   constant   total   quasi_total   complex-valued   ext-real-valued   real-valued   summable   convergent   for    Element of K10(K11(NAT,REAL));
</td><td><span data-href='tietze.html#RC1'>tietze</span></td></tr>
<tr><td>
cluster  REAL  ->  non  countable  ;
</td><td><span data-href='topgen_4.html#FC2'>topgen_4</span></td></tr>
<tr><td>
cluster  Cl X ->  non  empty  ;
</td><td><span data-href='topreal6.html#FC4'>topreal6</span></td></tr>
<tr><td>
cluster  Cl D ->  bounded_below  ;
</td><td><span data-href='topreal6.html#FC5'>topreal6</span></td></tr>
<tr><td>
cluster  Cl D ->  bounded_above  ;
</td><td><span data-href='topreal6.html#FC6'>topreal6</span></td></tr>
<tr><td>
cluster  R^1 A ->  non  empty  ;
</td><td><span data-href='toprealb.html#FC10'>toprealb</span></td></tr>
<tr><td>
cluster  R^1 A ->  open  ;
</td><td><span data-href='toprealb.html#FC11'>toprealb</span></td></tr>
<tr><td>
cluster  R^1 A ->  closed  ;
</td><td><span data-href='toprealb.html#FC12'>toprealb</span></td></tr>
<tr><td>
cluster R^1 | (R^1 A) ->  open  ;
</td><td><span data-href='toprealb.html#FC13'>toprealb</span></td></tr>
<tr><td>
cluster R^1 | (R^1 A) ->  closed  ;
</td><td><span data-href='toprealb.html#FC14'>toprealb</span></td></tr>
<tr><td>
cluster  R^1 f ->  onto  ;
</td><td><span data-href='toprealb.html#FC15'>toprealb</span></td></tr>
<tr><td>
cluster  R^1 f ->  one-to-one  ;
</td><td><span data-href='toprealb.html#FC16'>toprealb</span></td></tr>
<tr><td>
cluster  R^1 f ->  continuous  ;
</td><td><span data-href='toprealb.html#FC17'>toprealb</span></td></tr>
<tr><td>
cluster x ** A ->  interval  ;
</td><td><span data-href='urysohn2.html#FC1'>urysohn2</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -valued   ->  real-valued   for    set ;
</td><td><span data-href='valued_0.html#CC30'>valued_0</span></td></tr>
<tr><td>
cluster f1 + f2 ->  total   for  PartFunc of C,REAL;
</td><td><span data-href='valued_1.html#FC8'>valued_1</span></td></tr>
<tr><td>
cluster r + f ->  total   for  PartFunc of C,REAL;
</td><td><span data-href='valued_1.html#FC19'>valued_1</span></td></tr>
<tr><td>
cluster f - r ->  total   for  PartFunc of C,REAL;
</td><td><span data-href='valued_1.html#FC29'>valued_1</span></td></tr>
<tr><td>
cluster f1 (#) f2 ->  total   for  PartFunc of C,REAL;
</td><td><span data-href='valued_1.html#FC39'>valued_1</span></td></tr>
<tr><td>
cluster r (#) f ->  total   for  PartFunc of C,REAL;
</td><td><span data-href='valued_1.html#FC50'>valued_1</span></td></tr>
<tr><td>
cluster  - f ->  total   for  PartFunc of C,REAL;
</td><td><span data-href='valued_1.html#FC60'>valued_1</span></td></tr>
<tr><td>
cluster f "  ->  total   for  PartFunc of C,REAL;
</td><td><span data-href='valued_1.html#FC67'>valued_1</span></td></tr>
<tr><td>
cluster f ^2  ->  total   for  PartFunc of C,REAL;
</td><td><span data-href='valued_1.html#FC76'>valued_1</span></td></tr>
<tr><td>
cluster f1 - f2 ->  total   for  PartFunc of C,REAL;
</td><td><span data-href='valued_1.html#FC86'>valued_1</span></td></tr>
<tr><td>
cluster f1 /" f2 ->  total   for  PartFunc of C,REAL;
</td><td><span data-href='valued_1.html#FC94'>valued_1</span></td></tr>
<tr><td>
cluster |.f.| ->  total   for  PartFunc of C,REAL;
</td><td><span data-href='valued_1.html#FC99'>valued_1</span></td></tr>
<tr><td>
cluster  RLSMetrStruct(# X,F,O,B,G #) ->  non  empty  ;
</td><td><span data-href='vectmetr.html#FC5'>vectmetr</span></td></tr>
<tr><td>
cluster f1 (#) f2 ->  total  ;
</td><td><span data-href='vfunct_1.html#FC3'>vfunct_1</span></td></tr>
<tr><td>
cluster   ->  complex   for    Element of  REAL ;
</td><td><span data-href='xcmplx_0.html#CC2'>xcmplx_0</span></td></tr>
<tr><td>
cluster   ->  real   for    Element of  REAL ;
</td><td><span data-href='xreal_0.html#CC1'>xreal_0</span></td></tr>
<tr><td>
cluster   ->  ext-real   for    Element of  REAL ;
</td><td><span data-href='xreal_1.html#CC1'>xreal_1</span></td></tr>
<tr><td>
cluster  REAL  ->  non  bounded_below   non  bounded_above  ;
</td><td><span data-href='xxreal_2.html#FC11'>xxreal_2</span></td></tr>
<tr><td>
cluster  REAL  ->  interval  ;
</td><td><span data-href='xxreal_2.html#FC17'>xxreal_2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined  REAL *  -valued   Function-like   finite   FinSequence-like   FinSubsequence-like   Function-yielding  V201()  tabular   FinSequence-yielding   finite-support   integer   for    FinSequence of REAL * ;
</td><td><span data-href='zmatrlin.html#RC1'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined  REAL *  -valued   Function-like   finite   FinSequence-like   FinSubsequence-like   Function-yielding  V201()  tabular  V207( REAL ,n,m)  FinSequence-yielding   finite-support   integer   for    FinSequence of REAL * ;
</td><td><span data-href='zmatrlin.html#RC2'>zmatrlin</span></td></tr>
</tbody>
</table>
</div>
<div class='related-reduce'>
<table class='pure-table'>
<thead><tr><th colspan='2'>reduce</th></tr></thead>
<tbody>
<tr><td>
reduce (f | i) | (i + j) to f | i;
</td><td><span data-href='newton04.html#RD19'>newton04</span></td></tr>
<tr><td>
reduce (Sequel f) | (dom f) to f;
</td><td><span data-href='rvsum_4.html#RD29'>rvsum_4</span></td></tr>
<tr><td>
reduce  In (i,REAL) to i;
</td><td><span data-href='xreal_0.html#RD1'>xreal_0</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
</body>
</html>
