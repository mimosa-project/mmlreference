<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<title>non-empty</title>
</head>
<body>
<div class='mml-summary'>
<h1>attr non-empty</h1>
<h2>List of Definitions (7)</h2>
<ol>
<li><span data-link='3057.html#ELM8586'>non-empty</span> [<span data-href='freealg.html'>freealg</span>]</li>
<li><span data-link='3057.html#ELM8828'>non-empty</span> [<span data-href='funct_1.html'>funct_1</span>]</li>
<li><span data-link='3057.html#ELM12507'>non-empty</span> [<span data-href='int_6.html'>int_6</span>]</li>
<li><span data-link='3057.html#ELM17069'>non-empty</span> [<span data-href='msualg_1.html#V4'>msualg_1</span>]</li>
<li><span data-link='3057.html#ELM19828'>non-empty</span> [<span data-href='pboole.html#V2'>pboole</span>]</li>
<li><span data-link='3057.html#ELM22398'>non-empty</span> [<span data-href='relat_1.html#V2'>relat_1</span>]</li>
<li><span data-link='3057.html#ELM27602'>non-empty</span> [<span data-href='unialg_1.html#V4'>unialg_1</span>]</li>
</ol>
</div>
<div class='mml-element' id='ELM8586'>
<h2>1.   <span data-link='3057.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='freealg.html'>freealg</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">IT</font> be   <span title="RELAT_1:NM.1" data-link="286.html#ELM22383">Relation</span>;<br><div about="#D3" typeof="oo:Definition" class="main-sentence">
<span class="kw">redefine </span><span class="kw">attr</span> <font color="Maroon" title="c1">IT</font> is  <span title="RELAT_1:attr.2" data-link="3057.html#ELM22398">non-empty</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E3">Def2</font></span>: <a name="D2"><span class="comment"><font color="firebrick">:: FREEALG:def 2</font></span><br></a> not  <span title="NUMBERS:func.5" data-link="6192.html#ELM18628">0</span>  <span title="TARSKI:pred.2" data-link="4139.html#ELM26063">in</span>  <span title="RELAT_1:NK.2" data-link="3141.html#ELM22385">rng</span> <font color="Maroon" title="c1">IT</font>;<br>
</div>
<span class="kw">compatibility</span> <span class="kw">by</span> <span class="lab"><span class="ref" onmouseover="rs('relat_1/D9')" onmouseout="rh()" data-href="relat_1.html#D9">RELAT_1:def 9</span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM8828'>
<h2>2.   <span data-link='3057.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='funct_1.html'>funct_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">F</font> be   <span title="FUNCT_1:NM.1" data-link="3155.html#ELM8817">Function</span>;<br><div about="#D47" typeof="oo:Definition" class="main-sentence">
<span class="kw">redefine </span><span class="kw">attr</span> <font color="Maroon" title="c1">F</font> is  <span title="RELAT_1:attr.2" data-link="3057.html#ELM22398">non-empty</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E47">Def9</font></span>: <a name="D9"><span class="comment"><font color="firebrick">:: FUNCT_1:def 9</font></span><br></a> for <font color="Olive" title="b1">n</font> being    <span title="HIDDEN:mode.1" data-link="4140.html#ELM11935">object</span>   st <font color="Olive" title="b1">n</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span>  <span title="RELAT_1:NK.1" data-link="41.html#ELM22384">dom</span> <font color="Maroon" title="c1">F</font> holds <br> not <font color="Maroon" title="c1">F</font> <span title="FUNCT_1:func.1" data-link="141.html#ELM8818">.</span> <font color="Olive" title="b1">n</font> is  <span title="XBOOLE_0:attr.1" data-link="1570.html#ELM29653">empty</span> ;<br>
</div>
<span class="kw">compatibility</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM12507'>
<h2>3.   <span data-link='3057.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='int_6.html'>int_6</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">f</font> be   <span title="NUMBERS:func.4" data-link="2849.html#ELM18627">INT</span>  <span title="RELAT_1:attr.5" data-link="7382.html#ELM22401">-valued</span>  <span title="FINSEQ_1:NM.1" data-link="27.html#ELM7089">FinSequence</span>;<br><div about="#D27" typeof="oo:Definition" class="main-sentence">
<span class="kw">redefine </span><span class="kw">attr</span> <font color="Maroon" title="c1">f</font> is  <span title="RELAT_1:attr.2" data-link="3057.html#ELM22398">non-empty</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E27">Def1</font></span>: <a name="D1"><span class="comment"><font color="firebrick">:: INT_6:def 1</font></span><br></a> for <font color="Olive" title="b1">i</font> being   <span title="NAT_1:NM.1" data-link="5402.html#ELM17446">Nat</span>  holds <br>(  not <font color="Olive" title="b1">i</font> <span title="TARSKI:pred.2" data-link="4139.html#ELM26063">in</span>  <span title="FINSEQ_1:func.4" data-link="41.html#ELM7097">dom</span> <font color="Maroon" title="c1">f</font> or  not <font color="Maroon" title="c1">f</font> <span title="FUNCT_1:func.1" data-link="141.html#ELM8818">.</span> <font color="Olive" title="b1">i</font> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span>  <span title="NUMBERS:func.5" data-link="6192.html#ELM18628">0</span>  );<br>
</div>
<span class="kw">compatibility</span> <br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM17069'>
<h2>4.   <span data-link='3057.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='msualg_1.html#V4'>msualg_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">S</font> be    <span title="STRUCT_0:struct.1" data-link="8048.html#ELM25742">1-sorted</span> ;<br><span class="kw">let </span><font color="Maroon" title="c2">A</font> be    <span title="MSUALG_1:struct.2" data-link="5759.html#ELM17053">many-sorted</span> over <font color="Maroon" title="c1">S</font>;<br><div about="#D1" typeof="oo:Definition" class="main-sentence">
<a name="V4"><span class="kw">attr</span> </a><font color="Maroon" title="c2">A</font> is  <span title="MSUALG_1:attr.4" data-link="3057.html#ELM17069">non-empty</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E1">Def3</font></span>: <a name="D3"><span class="comment"><font color="firebrick">:: MSUALG_1:def 3</font></span><br></a> the <span title="MSUALG_1:sel.3" data-href="msualg_1.html#U3">Sorts</span> of <font color="Maroon" title="c2">A</font> is <span title="RELAT_1:attr.2" data-link="3057.html#ELM22398">V5</span>();<br>
</div>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  Free (C,(MSVars C)) ->  non-empty  ;
</td><td><span data-href='abcmiz_1.html#FC12'>abcmiz_1</span></td></tr>
<tr><td>
cluster  the Sorts of A ->  one-to-one  ;
</td><td><span data-href='algspec1.html#FC2'>algspec1</span></td></tr>
<tr><td>
cluster  VarMSAlgebra(# U,C,v #) ->  non-empty  ;
</td><td><span data-href='aofa_a00.html#FC7'>aofa_a00</span></td></tr>
<tr><td>
cluster  non-empty   disjoint_valued   for    VarMSAlgebra over S;
</td><td><span data-href='aofa_a00.html#RC3'>aofa_a00</span></td></tr>
<tr><td>
cluster X,S -terms   all_vars_including   ->  non-empty  X,S -terms   for    VarMSAlgebra over S;
</td><td><span data-href='aofa_a00.html#CC1'>aofa_a00</span></td></tr>
<tr><td>
cluster  non-empty  V166(S)  disjoint_valued  X,S -terms   all_vars_including   inheriting_operations   free_in_itself   strict   vf-free   for    VarMSAlgebra over S;
</td><td><span data-href='aofa_a00.html#RC5'>aofa_a00</span></td></tr>
<tr><td>
cluster A -undef   ->  undef-consequent   for    UndefMSAlgebra over S;
</td><td><span data-href='aofa_a00.html#CC2'>aofa_a00</span></td></tr>
<tr><td>
cluster  non-empty   strict  A -undef   for    UndefMSAlgebra over S;
</td><td><span data-href='aofa_a00.html#RC7'>aofa_a00</span></td></tr>
<tr><td>
cluster C -States X ->  non  empty  ;
</td><td><span data-href='aofa_a00.html#FC9'>aofa_a00</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   for    Element of C -States X;
</td><td><span data-href='aofa_a00.html#CC3'>aofa_a00</span></td></tr>
<tr><td>
cluster   ->  the carrier of B -defined   Function-yielding   for    Element of C -States X;
</td><td><span data-href='aofa_a00.html#CC4'>aofa_a00</span></td></tr>
<tr><td>
cluster   ->  total   for    Element of C -States X;
</td><td><span data-href='aofa_a00.html#CC5'>aofa_a00</span></td></tr>
<tr><td>
cluster C -States X ->  non  empty  ;
</td><td><span data-href='aofa_a00.html#FC10'>aofa_a00</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   for    Element of  Args (o,A);
</td><td><span data-href='aofa_a00.html#CC6'>aofa_a00</span></td></tr>
<tr><td>
cluster C -States G ->  non  empty  ;
</td><td><span data-href='aofa_a00.html#FC11'>aofa_a00</span></td></tr>
<tr><td>
cluster  strict   non-empty   bool-correct   for    MSAlgebra over S;
</td><td><span data-href='aofa_a00.html#RC21'>aofa_a00</span></td></tr>
<tr><td>
cluster  strict   non-empty  V166(S)  bool-correct  4,1 integer   for    MSAlgebra over S;
</td><td><span data-href='aofa_a00.html#RC24'>aofa_a00</span></td></tr>
<tr><td>
cluster   ->  integer   for    Element of  the Sorts of A . 1;
</td><td><span data-href='aofa_a00.html#CC7'>aofa_a00</span></td></tr>
<tr><td>
cluster  strict   non-empty  V166(S) 1,I,N -array   for    MSAlgebra over S;
</td><td><span data-href='aofa_a00.html#RC28'>aofa_a00</span></td></tr>
<tr><td>
cluster  strict   non-empty  V166(S)  bool-correct  4,1 integer  11,1,1 -array   for    MSAlgebra over S;
</td><td><span data-href='aofa_a00.html#RC29'>aofa_a00</span></td></tr>
<tr><td>
cluster  non-empty   integer   for    MSAlgebra over S;
</td><td><span data-href='aofa_a01.html#RC1'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty  A -Image   Equations (S,A) -satisfying   bool-correct   for    MSAlgebra over S;
</td><td><span data-href='aofa_a01.html#RC2'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty  A -Image   Equations (S,A) -satisfying   bool-correct  4,1 integer   for    MSAlgebra over S;
</td><td><span data-href='aofa_a01.html#RC3'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty   ->  non-empty   bool-correct   for    MSSubAlgebra of A;
</td><td><span data-href='aofa_a01.html#CC1'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty   ->  non-empty  4,1 integer   for    MSSubAlgebra of A;
</td><td><span data-href='aofa_a01.html#CC2'>aofa_a01</span></td></tr>
<tr><td>
cluster  Free (S,X) ->  non-empty   integer   for  non-empty   MSAlgebra over S;
</td><td><span data-href='aofa_a01.html#FC1'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty  X,S -terms   all_vars_including   inheriting_operations   free_in_itself   vf-free   disjoint_valued   integer   for    VarMSAlgebra over S;
</td><td><span data-href='aofa_a01.html#RC4'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty   ->  non-empty  11,1,1 -array   for    MSSubAlgebra of A;
</td><td><span data-href='aofa_a01.html#CC4'>aofa_a01</span></td></tr>
<tr><td>
cluster  Free (S,X) ->  non-empty   integer-array   for  non-empty   MSAlgebra over S;
</td><td><span data-href='aofa_a01.html#FC16'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty   integer-array   ->  non-empty   integer   for    MSAlgebra over S;
</td><td><span data-href='aofa_a01.html#CC5'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty  X,S -terms   all_vars_including   inheriting_operations   free_in_itself   strict   vf-free   disjoint_valued   integer-array   for    VarMSAlgebra over S;
</td><td><span data-href='aofa_a01.html#RC9'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty   integer-array   for    MSAlgebra over S;
</td><td><span data-href='aofa_a01.html#RC10'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty  A -Image   Equations (S,A) -satisfying   bool-correct  4,1 integer  11,1,1 -array   for    MSAlgebra over S;
</td><td><span data-href='aofa_a01.html#RC11'>aofa_a01</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   for    Element of  the Sorts of A . (the_array_sort_of S);
</td><td><span data-href='aofa_a01.html#CC6'>aofa_a01</span></td></tr>
<tr><td>
cluster   ->  Sequence-like   finite   for    Element of  the Sorts of A . (the_array_sort_of S);
</td><td><span data-href='aofa_a01.html#CC7'>aofa_a01</span></td></tr>
<tr><td>
cluster (s . (the_array_sort_of S)) . M ->  Relation-like   Function-like  ;
</td><td><span data-href='aofa_a01.html#FC17'>aofa_a01</span></td></tr>
<tr><td>
cluster (s . (the_array_sort_of S)) . M ->  INT  -valued   Sequence-like   finite  ;
</td><td><span data-href='aofa_a01.html#FC18'>aofa_a01</span></td></tr>
<tr><td>
cluster  rng ((s . (the_array_sort_of S)) . M) ->  finite   integer-membered  ;
</td><td><span data-href='aofa_a01.html#FC19'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty  X,S -terms   all_vars_including   inheriting_operations   free_in_itself   disjoint_valued   non  array-degenerated   for    MSAlgebra over S;
</td><td><span data-href='aofa_a01.html#RC12'>aofa_a01</span></td></tr>
<tr><td>
cluster (s .  the bool-sort of S) . b ->  boolean  ;
</td><td><span data-href='aofa_a01.html#FC23'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty   strict   for    VarMSAlgebra over S;
</td><td><span data-href='aofa_l00.html#RC1'>aofa_l00</span></td></tr>
<tr><td>
cluster  non-empty   for    SubstMSAlgebra over J,X;
</td><td><span data-href='aofa_l00.html#RC14'>aofa_l00</span></td></tr>
<tr><td>
cluster  non-empty   non  empty  T -extension   for    MSAlgebra over S;
</td><td><span data-href='aofa_l00.html#RC21'>aofa_l00</span></td></tr>
<tr><td>
cluster  non-empty   ->  language   for    MSAlgebra over S;
</td><td><span data-href='aofa_l00.html#CC6'>aofa_l00</span></td></tr>
<tr><td>
cluster  Relation-like  V3()  the carrier of S -defined   Function-like   non  empty   total  X -tolerating   for    set ;
</td><td><span data-href='aofa_l00.html#RC27'>aofa_l00</span></td></tr>
<tr><td>
cluster  non-empty  T -extension   language   for    LanguageStr over T,Y,S;
</td><td><span data-href='aofa_l00.html#RC28'>aofa_l00</span></td></tr>
<tr><td>
cluster  non-empty  X extended_by ({}, the carrier of S) -vf-yielding  T -extension   language   for    LanguageStr over T,X extended_by ({}, the carrier of S),S;
</td><td><span data-href='aofa_l00.html#RC29'>aofa_l00</span></td></tr>
<tr><td>
cluster  non  empty   for    VariableSet of T;
</td><td><span data-href='aofa_l00.html#RC30'>aofa_l00</span></td></tr>
<tr><td>
cluster  non  empty   non  void   feasible   feasible  J -extension   for    AlgLangSignature over  Union X;
</td><td><span data-href='aofa_l00.html#RC32'>aofa_l00</span></td></tr>
<tr><td>
cluster  non  1s-empty   strict   for    BialgebraStr over S,Y;
</td><td><span data-href='aofa_l00.html#RC33'>aofa_l00</span></td></tr>
<tr><td>
cluster  non  1s-empty   partial   quasi_total   ua-non-empty   non-empty   with_empty-instruction   with_catenation   with_if-instruction   with_while-instruction  T -extension   language   strict   AL-correct   for    BialgebraStr over S,Y;
</td><td><span data-href='aofa_l00.html#RC34'>aofa_l00</span></td></tr>
<tr><td>
cluster  non  1s-empty   partial   quasi_total   ua-non-empty   non-empty   with_empty-instruction   with_catenation   with_if-instruction   with_while-instruction   non  degenerated   well_founded   ECIW-strict   non  empty   vf-correct   subst-correct  T -extension   language   vf-qc-correct   vf-finite   subst-forex   AL-correct   for    BialgebraStr over S,X extended_by ({}, the carrier of S);
</td><td><span data-href='aofa_l00.html#RC35'>aofa_l00</span></td></tr>
<tr><td>
cluster  [#] ( the Sorts of L .  the formula-sort of S) ->  QC-closed  ;
</td><td><span data-href='aofa_l00.html#FC11'>aofa_l00</span></td></tr>
<tr><td>
cluster  PC-closed   QC-closed   for    Element of  bool ( the Sorts of L .  the formula-sort of S);
</td><td><span data-href='aofa_l00.html#RC37'>aofa_l00</span></td></tr>
<tr><td>
cluster  [#] ( the Sorts of L .  the formula-sort of S) ->  with_equality  ;
</td><td><span data-href='aofa_l00.html#FC12'>aofa_l00</span></td></tr>
<tr><td>
cluster  PC-closed   QC-closed   with_equality   for    Element of  bool ( the Sorts of L .  the formula-sort of S);
</td><td><span data-href='aofa_l00.html#RC38'>aofa_l00</span></td></tr>
<tr><td>
cluster  non  empty   PC-closed   QC-closed   with_equality  V AL-closed   for    Element of  bool ( the Sorts of L .  the formula-sort of S);
</td><td><span data-href='aofa_l00.html#RC39'>aofa_l00</span></td></tr>
<tr><td>
cluster  MSAAutGroup U1 ->  strict  ;
</td><td><span data-href='autalg_1.html#FC5'>autalg_1</span></td></tr>
<tr><td>
cluster  non-empty   ->  non  empty   for    MSAlgebra over S;
</td><td><span data-href='catalg_1.html#CC1'>catalg_1</span></td></tr>
<tr><td>
cluster  strict   non-empty   disjoint_valued   for    MSAlgebra over S;
</td><td><span data-href='catalg_1.html#RC1'>catalg_1</span></td></tr>
<tr><td>
cluster  non-empty   finite-yielding   with_stabilization-limit   ->  non-empty   stabilizing   for    MSAlgebra over S;
</td><td><span data-href='circcmb3.html#CC1'>circcmb3</span></td></tr>
<tr><td>
cluster  finite-yielding   one-gate   ->  strict   non-empty   for    MSAlgebra over S;
</td><td><span data-href='circcmb3.html#CC4'>circcmb3</span></td></tr>
<tr><td>
cluster  non-empty   finite-yielding   one-gate   for    MSAlgebra over S;
</td><td><span data-href='circcmb3.html#RC2'>circcmb3</span></td></tr>
<tr><td>
cluster  non-empty   finite-yielding   one-gate   ->  non-empty   with_stabilization-limit   for    MSAlgebra over S;
</td><td><span data-href='circcmb3.html#CC5'>circcmb3</span></td></tr>
<tr><td>
cluster   ->  non-empty   gate`2=den   for    Circuit of X,S;
</td><td><span data-href='circcmb3.html#CC6'>circcmb3</span></td></tr>
<tr><td>
cluster  strict   non-empty   finite-yielding   gate`2=den   one-gate   for    Circuit of X,S;
</td><td><span data-href='circcmb3.html#RC4'>circcmb3</span></td></tr>
<tr><td>
cluster  strict   non-empty   finite-yielding   gate`2=den   for    Circuit of X,S;
</td><td><span data-href='circcmb3.html#RC5'>circcmb3</span></td></tr>
<tr><td>
cluster  1GateCircuit (p,f) ->  strict   non-empty   gate`2=den  ;
</td><td><span data-href='circcomb.html#FC13'>circcomb</span></td></tr>
<tr><td>
cluster  1GateCircuit (p,f) ->  strict   non-empty   finite-yielding  ;
</td><td><span data-href='circcomb.html#FC17'>circcomb</span></td></tr>
<tr><td>
cluster  Boolean   ->  non-empty   finite-yielding   for    MSAlgebra over S;
</td><td><span data-href='circcomb.html#CC3'>circcomb</span></td></tr>
<tr><td>
cluster A1 +* A2 ->  strict   non-empty   gate`2=den   Boolean  ;
</td><td><span data-href='circcomb.html#FC18'>circcomb</span></td></tr>
<tr><td>
cluster  strict   non-empty   finite-yielding   gate`2=den   for    MSAlgebra over  1GateCircStr (p,f);
</td><td><span data-href='circcomb.html#RC6'>circcomb</span></td></tr>
<tr><td>
cluster  1GateCircuit (p,f) ->  strict   non-empty   gate`2=den  ;
</td><td><span data-href='circcomb.html#FC19'>circcomb</span></td></tr>
<tr><td>
cluster  the_sort_of (v,A) ->  non  empty  ;
</td><td><span data-href='circtrm1.html#FC5'>circtrm1</span></td></tr>
<tr><td>
cluster X -CircuitSorts A -> V2() ;
</td><td><span data-href='circtrm1.html#FC6'>circtrm1</span></td></tr>
<tr><td>
cluster X -Circuit A ->  strict   non-empty   finite-yielding  ;
</td><td><span data-href='circtrm1.html#FC7'>circtrm1</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   non  empty   finite   for    Element of  the Sorts of (FreeEnv SCS) . v;
</td><td><span data-href='circuit1.html#CC1'>circuit1</span></td></tr>
<tr><td>
cluster   ->  DecoratedTree-like   for    Element of  the Sorts of (FreeEnv SCS) . v;
</td><td><span data-href='circuit1.html#CC2'>circuit1</span></td></tr>
<tr><td>
cluster  the Sorts of (FreeEnv A) . v ->  finite  ;
</td><td><span data-href='circuit1.html#FC1'>circuit1</span></td></tr>
<tr><td>
cluster  MSFull MS ->  non-empty  ;
</td><td><span data-href='closure1.html#FC3'>closure1</span></td></tr>
<tr><td>
cluster  non-empty   strict   additive   absolutely-additive   multiplicative   absolutely-multiplicative   properly-upper-bound   properly-lower-bound   for    MSClosureStr over S;
</td><td><span data-href='closure1.html#RC4'>closure1</span></td></tr>
<tr><td>
cluster  MSClosureStr(# M,F #) ->  non-empty  ;
</td><td><span data-href='closure1.html#FC10'>closure1</span></td></tr>
<tr><td>
cluster  ClOp->ClSys C ->  non-empty  ;
</td><td><span data-href='closure1.html#FC19'>closure1</span></td></tr>
<tr><td>
cluster  Full MS ->  non-empty  ;
</td><td><span data-href='closure2.html#FC6'>closure2</span></td></tr>
<tr><td>
cluster  non-empty   strict   additive   absolutely-additive   multiplicative   absolutely-multiplicative   properly-upper-bound   properly-lower-bound   for    ClosureStr over S;
</td><td><span data-href='closure2.html#RC6'>closure2</span></td></tr>
<tr><td>
cluster  ClosureStr(# M,F #) ->  non-empty  ;
</td><td><span data-href='closure2.html#FC13'>closure2</span></td></tr>
<tr><td>
cluster  SubAlgCl MA ->  strict   absolutely-multiplicative  ;
</td><td><span data-href='closure3.html#FC3'>closure3</span></td></tr>
<tr><td>
cluster  SubAlgCl MA ->  strict   algebraic  ;
</td><td><span data-href='closure3.html#FC4'>closure3</span></td></tr>
<tr><td>
cluster  MSAEndMonoid U1 ->  non  empty   strict  ;
</td><td><span data-href='endalg.html#FC3'>endalg</span></td></tr>
<tr><td>
cluster  MSAEndMonoid U1 ->  strict   well-unital   associative  ;
</td><td><span data-href='endalg.html#FC4'>endalg</span></td></tr>
<tr><td>
cluster  strict   non-empty   free   for    MSAlgebra over S;
</td><td><span data-href='equation.html#RC1'>equation</span></td></tr>
<tr><td>
cluster  GenMSAlg X ->  finitely-generated  ;
</td><td><span data-href='equation.html#FC2'>equation</span></td></tr>
<tr><td>
cluster  strict   non-empty   finitely-generated   for    MSSubAlgebra of A;
</td><td><span data-href='equation.html#RC2'>equation</span></td></tr>
<tr><td>
cluster  TermAlg S ->  strict   non-empty   free  ;
</td><td><span data-href='equation.html#FC3'>equation</span></td></tr>
<tr><td>
cluster  Relation-like  V2()  the carrier of S -defined   Function-like   non  empty   total   for    GeneratorSet of U1;
</td><td><span data-href='extens_1.html#RC1'>extens_1</span></td></tr>
<tr><td>
cluster A | S1 ->  strict   non-empty  ;
</td><td><span data-href='instalg1.html#FC1'>instalg1</span></td></tr>
<tr><td>
cluster  FreeMSA X ->  strict   non-empty  ;
</td><td><span data-href='msafree.html#FC9'>msafree</span></td></tr>
<tr><td>
cluster  strict   non-empty   free   for    MSAlgebra over S;
</td><td><span data-href='msafree.html#RC1'>msafree</span></td></tr>
<tr><td>
cluster  non-empty   disjoint_valued   for    MSAlgebra over S;
</td><td><span data-href='msafree1.html#RC2'>msafree1</span></td></tr>
<tr><td>
cluster  SingleAlg S ->  strict   non-empty   disjoint_valued  ;
</td><td><span data-href='msafree1.html#FC2'>msafree1</span></td></tr>
<tr><td>
cluster  FreeMSA X ->  non-empty  ;
</td><td><span data-href='msafree1.html#FC5'>msafree1</span></td></tr>
<tr><td>
cluster  Args (o,A) ->  non  empty  ;
</td><td><span data-href='msafree1.html#FC6'>msafree1</span></td></tr>
<tr><td>
cluster  Result (o,A) ->  non  empty  ;
</td><td><span data-href='msafree1.html#FC7'>msafree1</span></td></tr>
<tr><td>
cluster  non-empty   finite-yielding   ->  non-empty   finitely-generated   for    MSAlgebra over S;
</td><td><span data-href='msafree2.html#CC2'>msafree2</span></td></tr>
<tr><td>
cluster  strict   non-empty   finite-yielding   for    MSAlgebra over S;
</td><td><span data-href='msafree2.html#RC3'>msafree2</span></td></tr>
<tr><td>
cluster  strict   non-empty   disjoint_valued   trivial   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#RC7'>msafree4</span></td></tr>
<tr><td>
cluster A -Image   ->  non-empty   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#CC4'>msafree4</span></td></tr>
<tr><td>
cluster  strict   non-empty   feasible   non  empty  A -Image   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#RC8'>msafree4</span></td></tr>
<tr><td>
cluster  non-empty   disjoint_valued   feasible   non  empty   trivial  A -Image   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#RC9'>msafree4</span></td></tr>
<tr><td>
cluster  Free (S,X) ->  non-empty   disjoint_valued  ;
</td><td><span data-href='msafree4.html#FC15'>msafree4</span></td></tr>
<tr><td>
cluster  strict   non-empty  X,S -terms   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#RC10'>msafree4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  V5()  the carrier of J -defined   Function-like   total   for    GeneratorSet of T;
</td><td><span data-href='msafree4.html#RC11'>msafree4</span></td></tr>
<tr><td>
cluster X,S -terms   all_vars_including   ->  non-empty  X,S -terms   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#CC5'>msafree4</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   for    Element of  Union  the Sorts of A0;
</td><td><span data-href='msafree4.html#CC7'>msafree4</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   for    Element of  the Sorts of A0 . s;
</td><td><span data-href='msafree4.html#CC8'>msafree4</span></td></tr>
<tr><td>
cluster   ->  DecoratedTree-like   for    Element of  Union  the Sorts of A0;
</td><td><span data-href='msafree4.html#CC9'>msafree4</span></td></tr>
<tr><td>
cluster   ->  DecoratedTree-like   for    Element of  the Sorts of A0 . s;
</td><td><span data-href='msafree4.html#CC10'>msafree4</span></td></tr>
<tr><td>
cluster  non-empty   trivial  T -satisfying   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#RC15'>msafree4</span></td></tr>
<tr><td>
cluster  non-empty  A -Image   ->  non-empty  T -satisfying   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#CC12'>msafree4</span></td></tr>
<tr><td>
cluster A -Image   -> A -Image   Equations (S,A) -satisfying   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#CC13'>msafree4</span></td></tr>
<tr><td>
cluster  NFAlgebra R ->  strict   non-empty  X,S -terms  ;
</td><td><span data-href='msafree4.html#FC19'>msafree4</span></td></tr>
<tr><td>
cluster  NFAlgebra R ->  strict   non-empty   all_vars_including   inheriting_operations   free_in_itself  ;
</td><td><span data-href='msafree4.html#FC20'>msafree4</span></td></tr>
<tr><td>
cluster s -sort   for    Element of  Union  the Sorts of A;
</td><td><span data-href='msafree5.html#RC6'>msafree5</span></td></tr>
<tr><td>
cluster   -> s -sort   for    Element of  the Sorts of A . s;
</td><td><span data-href='msafree5.html#CC7'>msafree5</span></td></tr>
<tr><td>
cluster  non-empty   disjoint_valued  X,S -terms   all_vars_including   inheriting_operations   free_in_itself   non  empty   struct-invariant   for    MSAlgebra over S;
</td><td><span data-href='msafree5.html#RC15'>msafree5</span></td></tr>
<tr><td>
cluster  Relation-like  V2()  the carrier of S -defined   Function-like   non  empty  V28()  total   for    GeneratorSet of A;
</td><td><span data-href='msscyc_1.html#RC7'>msscyc_1</span></td></tr>
<tr><td>
cluster  strict   non-empty   for    MSAlgebra over S;
</td><td><span data-href='msualg_1.html#RC6'>msualg_1</span></td></tr>
<tr><td>
cluster  strict   non-empty   for    many-sorted over S;
</td><td><span data-href='msualg_1.html#RC7'>msualg_1</span></td></tr>
<tr><td>
cluster  the Sorts of A -> V5() ;
</td><td><span data-href='msualg_1.html#FC1'>msualg_1</span></td></tr>
<tr><td>
cluster   ->  non  empty   for    Element of  rng  the Sorts of A;
</td><td><span data-href='msualg_1.html#CC1'>msualg_1</span></td></tr>
<tr><td>
cluster   ->  non  empty   for    Element of  rng ( the Sorts of A #);
</td><td><span data-href='msualg_1.html#CC2'>msualg_1</span></td></tr>
<tr><td>
cluster  MSAlg A ->  strict   non-empty  ;
</td><td><span data-href='msualg_1.html#FC3'>msualg_1</span></td></tr>
<tr><td>
cluster  the_sort_of A ->  non  empty  ;
</td><td><span data-href='msualg_1.html#FC4'>msualg_1</span></td></tr>
<tr><td>
cluster  Constants (U0,s) ->  non  empty  ;
</td><td><span data-href='msualg_2.html#FC4'>msualg_2</span></td></tr>
<tr><td>
cluster  Constants U0 -> V8() ;
</td><td><span data-href='msualg_2.html#FC5'>msualg_2</span></td></tr>
<tr><td>
cluster  MSAlgebra(#  the Sorts of U0, the Charact of U0 #) ->  non-empty  ;
</td><td><span data-href='msualg_2.html#FC6'>msualg_2</span></td></tr>
<tr><td>
cluster  strict   non-empty   for    MSSubAlgebra of U0;
</td><td><span data-href='msualg_2.html#RC3'>msualg_2</span></td></tr>
<tr><td>
cluster  GenMSAlg A ->  strict   non-empty  ;
</td><td><span data-href='msualg_2.html#FC10'>msualg_2</span></td></tr>
<tr><td>
cluster  MSSubAlLattice U0 ->  strict   bounded  ;
</td><td><span data-href='msualg_2.html#FC12'>msualg_2</span></td></tr>
<tr><td>
cluster  Args (o,U1) ->  functional  ;
</td><td><span data-href='msualg_3.html#FC1'>msualg_3</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of S -defined   Function-like   total   Relation-yielding   MSEquivalence-like   MSCongruence-like   for    ManySortedRelation of  the Sorts of U1, the Sorts of U1;
</td><td><span data-href='msualg_4.html#RC3'>msualg_4</span></td></tr>
<tr><td>
cluster  QuotMSAlg (U1,R) ->  strict   non-empty  ;
</td><td><span data-href='msualg_4.html#FC3'>msualg_4</span></td></tr>
<tr><td>
cluster  CongrLatt A ->  strict   bounded  ;
</td><td><span data-href='msualg_5.html#FC1'>msualg_5</span></td></tr>
<tr><td>
cluster  non-empty   ->  feasible   for    MSAlgebra over S;
</td><td><span data-href='msualg_6.html#CC1'>msualg_6</span></td></tr>
<tr><td>
cluster  non-empty   for    MSAlgebra over S;
</td><td><span data-href='msualg_6.html#RC1'>msualg_6</span></td></tr>
<tr><td>
cluster  MSEquivalence-like   invariant   ->  MSEquivalence-like   compatible   for    ManySortedRelation of  the Sorts of A, the Sorts of A;
</td><td><span data-href='msualg_6.html#CC2'>msualg_6</span></td></tr>
<tr><td>
cluster  MSEquivalence-like   compatible   ->  MSEquivalence-like   invariant   for    ManySortedRelation of  the Sorts of A, the Sorts of A;
</td><td><span data-href='msualg_6.html#CC3'>msualg_6</span></td></tr>
<tr><td>
cluster  MSEquivalence-like   -> V2()  for    ManySortedRelation of  the Sorts of A, the Sorts of A;
</td><td><span data-href='msualg_6.html#CC4'>msualg_6</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   non  empty   Function-like   total   Relation-yielding   MSEquivalence-like   invariant   stable   for    ManySortedRelation of  the Sorts of A, the Sorts of A;
</td><td><span data-href='msualg_6.html#RC2'>msualg_6</span></td></tr>
<tr><td>
cluster  InvCl R -> V2()  invariant  ;
</td><td><span data-href='msualg_6.html#FC2'>msualg_6</span></td></tr>
<tr><td>
cluster  StabCl R -> V2()  stable  ;
</td><td><span data-href='msualg_6.html#FC3'>msualg_6</span></td></tr>
<tr><td>
cluster  TRS R -> V2()  invariant   stable  ;
</td><td><span data-href='msualg_6.html#FC4'>msualg_6</span></td></tr>
<tr><td>
cluster  EqCl (R,A) ->  MSEquivalence-like   stable  ;
</td><td><span data-href='msualg_6.html#FC5'>msualg_6</span></td></tr>
<tr><td>
cluster  EqCl (R,A) ->  MSEquivalence-like   invariant  ;
</td><td><span data-href='msualg_6.html#FC6'>msualg_6</span></td></tr>
<tr><td>
cluster  CongrLatt A ->  /\-inheriting   \/-inheriting  ;
</td><td><span data-href='msualg_8.html#FC3'>msualg_8</span></td></tr>
<tr><td>
cluster   ->  FinSequence-like   for    Element of  Args (o,A);
</td><td><span data-href='msualg_9.html#CC1'>msualg_9</span></td></tr>
<tr><td>
cluster [:A,B:] ->  non-empty  ;
</td><td><span data-href='msualg_9.html#FC3'>msualg_9</span></td></tr>
<tr><td>
cluster  Trivial_Algebra S ->  non-empty   finite-yielding  ;
</td><td><span data-href='msualg_9.html#FC5'>msualg_9</span></td></tr>
<tr><td>
cluster  ParsedTermsOSA X ->  strict   non-empty  ;
</td><td><span data-href='osafree.html#FC5'>osafree</span></td></tr>
<tr><td>
cluster  strict   non-empty   order-sorted   monotone   osfree   for    MSAlgebra over S;
</td><td><span data-href='osafree.html#RC2'>osafree</span></td></tr>
<tr><td>
cluster  strict   non-empty   order-sorted   for    MSAlgebra over S;
</td><td><span data-href='osalg_1.html#RC12'>osalg_1</span></td></tr>
<tr><td>
cluster  ConstOSA (S,z,CH) ->  strict   non-empty   order-sorted  ;
</td><td><span data-href='osalg_1.html#FC5'>osalg_1</span></td></tr>
<tr><td>
cluster  strict   non-empty   order-sorted   monotone   for    MSAlgebra over S;
</td><td><span data-href='osalg_1.html#RC13'>osalg_1</span></td></tr>
<tr><td>
cluster  TrivialOSA (S,z,z1) ->  strict   non-empty   monotone  ;
</td><td><span data-href='osalg_1.html#FC6'>osalg_1</span></td></tr>
<tr><td>
cluster  strict   non-empty   order-sorted   monotone   for    MSAlgebra over S;
</td><td><span data-href='osalg_2.html#RC2'>osalg_2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  V8()  the carrier of S -defined   Function-like  V17( the carrier of S)  for    OSSubset of U0;
</td><td><span data-href='osalg_2.html#RC3'>osalg_2</span></td></tr>
<tr><td>
cluster  strict   non-empty   order-sorted   for    MSSubAlgebra of U0;
</td><td><span data-href='osalg_2.html#RC7'>osalg_2</span></td></tr>
<tr><td>
cluster  OSSubAlLattice U0 ->  strict   bounded  ;
</td><td><span data-href='osalg_2.html#FC8'>osalg_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   non  empty   Function-like   total   Relation-yielding   MSEquivalence-like   MSCongruence-like   for    OrderSortedRelation of U1;
</td><td><span data-href='osalg_4.html#RC4'>osalg_4</span></td></tr>
<tr><td>
cluster  OSClass (E,s1) ->  non  empty  ;
</td><td><span data-href='osalg_4.html#FC1'>osalg_4</span></td></tr>
<tr><td>
cluster  OSClass E -> V2() ;
</td><td><span data-href='osalg_4.html#FC2'>osalg_4</span></td></tr>
<tr><td>
cluster  QuotOSAlg (U1,R) ->  strict   non-empty  ;
</td><td><span data-href='osalg_4.html#FC3'>osalg_4</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   non  empty   Function-like   total   Relation-yielding   MSEquivalence-like   MSCongruence-like   monotone   for    OrderSortedRelation of U1;
</td><td><span data-href='osalg_4.html#RC7'>osalg_4</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   non  empty   Function-like   total   Relation-yielding   MSEquivalence-like   monotone   for    OrderSortedRelation of U1;
</td><td><span data-href='osalg_4.html#RC8'>osalg_4</span></td></tr>
<tr><td>
cluster  MSEquivalence-like   monotone   ->  MSEquivalence-like   MSCongruence-like   for    OrderSortedRelation of U1;
</td><td><span data-href='osalg_4.html#CC5'>osalg_4</span></td></tr>
<tr><td>
cluster  MSEquivalence-like   MSCongruence-like   ->  monotone   for    OrderSortedRelation of U1;
</td><td><span data-href='osalg_4.html#CC6'>osalg_4</span></td></tr>
<tr><td>
cluster  QuotOSAlg (U1,R) ->  monotone  ;
</td><td><span data-href='osalg_4.html#FC4'>osalg_4</span></td></tr>
<tr><td>
cluster |.U1.| ->  non  empty  ;
</td><td><span data-href='pralg_2.html#FC2'>pralg_2</span></td></tr>
<tr><td>
cluster [:U1,U2:] ->  strict  ;
</td><td><span data-href='pralg_2.html#FC4'>pralg_2</span></td></tr>
<tr><td>
cluster  product AF ->  non-empty  ;
</td><td><span data-href='pralg_3.html#FC1'>pralg_3</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM19828'>
<h2>5.   <span data-link='3057.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='pboole.html#V2'>pboole</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">I</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c2">X</font> be   <span title="PBOOLE:NM.1" data-link="4273.html#ELM19812">ManySortedSet</span> of <font color="Maroon" title="c1">I</font>;<br><div about="#D0" typeof="oo:Definition" class="">
<span class="comment"><font color="firebrick">:: original: </font></span><span title="RELAT_1:attr.3" data-link="3159.html#ELM22399">empty-yielding</span><br><span class="kw">redefine </span><a name="V1"><span class="kw">attr</span> </a><font color="Maroon" title="c2">X</font> is  <span title="PBOOLE:attr.1" data-link="3159.html#ELM19827">empty-yielding</span> <span class="kw"> means </span><a name="D12"><span class="comment"><font color="firebrick">:: PBOOLE:def 12</font></span><br></a> for <font color="Olive" title="b1">i</font> being    <span title="HIDDEN:mode.1" data-link="4140.html#ELM11935">object</span>   st <font color="Olive" title="b1">i</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span> <font color="Maroon" title="c1">I</font> holds <br><font color="Maroon" title="c2">X</font> <span title="FUNCT_1:func.1" data-link="141.html#ELM8818">.</span> <font color="Olive" title="b1">i</font> is  <span title="XBOOLE_0:attr.1" data-link="1570.html#ELM29653">empty</span> ;<br>
</div>
<span class="kw">compatibility</span> <div about="#D64" typeof="oo:Definition" class="main-sentence">
<span class="comment"><font color="firebrick">:: original: </font></span><span title="RELAT_1:attr.2" data-link="3057.html#ELM22398">non-empty</span><br><span class="kw">redefine </span><a name="V2"><span class="kw">attr</span> </a><font color="Maroon" title="c2">X</font> is  <span title="PBOOLE:attr.2" data-link="3057.html#ELM19828">non-empty</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E64">Def13</font></span>: <a name="D13"><span class="comment"><font color="firebrick">:: PBOOLE:def 13</font></span><br></a> for <font color="Olive" title="b1">i</font> being    <span title="HIDDEN:mode.1" data-link="4140.html#ELM11935">object</span>   st <font color="Olive" title="b1">i</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span> <font color="Maroon" title="c1">I</font> holds <br> not <font color="Maroon" title="c2">X</font> <span title="FUNCT_1:func.1" data-link="141.html#ELM8818">.</span> <font color="Olive" title="b1">i</font> is  <span title="XBOOLE_0:attr.1" data-link="1570.html#ELM29653">empty</span> ;<br>
</div>
<span class="kw">compatibility</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM22398'>
<h2>6.   <span data-link='3057.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='relat_1.html#V2'>relat_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">R</font> be   <span title="RELAT_1:NM.1" data-link="286.html#ELM22383">Relation</span>;<br><div about="#D17" typeof="oo:Definition" class="main-sentence">
<a name="V2"><span class="kw">attr</span> </a><font color="Maroon" title="c1">R</font> is  <span title="RELAT_1:attr.2" data-link="3057.html#ELM22398">non-empty</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E17">Def7</font></span>: <a name="D9"><span class="comment"><font color="firebrick">:: RELAT_1:def 9</font></span><br></a> not  <span title="XBOOLE_0:func.1" data-link="857.html#ELM29648">{}</span>  <span title="TARSKI:pred.2" data-link="4139.html#ELM26063">in</span>  <span title="RELAT_1:NK.2" data-link="3141.html#ELM22385">rng</span> <font color="Maroon" title="c1">R</font>;<br>
</div>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster (variables_in t) . s ->  finite  ;
</td><td><span data-href='abcmiz_1.html#FC23'>abcmiz_1</span></td></tr>
<tr><td>
cluster  Relation-like  V8()  the carrier of S -defined   Function-like   total   ->  with_missing_variables   for    set ;
</td><td><span data-href='abcmiz_1.html#CC10'>abcmiz_1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty  A -defined  B -valued   Function-like  V35(A,B)  for    Element of  bool [:A,B:];
</td><td><span data-href='abian.html#RC8'>abian</span></td></tr>
<tr><td>
cluster f . a ->  non  empty  ;
</td><td><span data-href='abian.html#FC18'>abian</span></td></tr>
<tr><td>
cluster  TRSStr(# X,O,r #) ->  non-empty  ;
</td><td><span data-href='absred_0.html#FC5'>absred_0</span></td></tr>
<tr><td>
cluster SCM-OK * SCM-VAL ->  non-empty  ;
</td><td><span data-href='ami_2.html#FC2'>ami_2</span></td></tr>
<tr><td>
cluster <*x,y*> ->  non-empty  ;
</td><td><span data-href='aofa_000.html#FC1'>aofa_000</span></td></tr>
<tr><td>
cluster p ^ q ->  non-empty  ;
</td><td><span data-href='aofa_000.html#FC2'>aofa_000</span></td></tr>
<tr><td>
cluster f +* (i,x) -> V2() ;
</td><td><span data-href='aofa_a00.html#FC1'>aofa_a00</span></td></tr>
<tr><td>
cluster  VarMSAlgebra(# U,C,v #) ->  non-empty  ;
</td><td><span data-href='aofa_a00.html#FC7'>aofa_a00</span></td></tr>
<tr><td>
cluster X,S -terms   strict   for    VarMSAlgebra over S;
</td><td><span data-href='aofa_a00.html#RC2'>aofa_a00</span></td></tr>
<tr><td>
cluster X,S -terms   all_vars_including   ->  non-empty  X,S -terms   for    VarMSAlgebra over S;
</td><td><span data-href='aofa_a00.html#CC1'>aofa_a00</span></td></tr>
<tr><td>
cluster  disjoint_valued  X,S -terms   all_vars_including   inheriting_operations   free_in_itself   strict   for    VarMSAlgebra over S;
</td><td><span data-href='aofa_a00.html#RC4'>aofa_a00</span></td></tr>
<tr><td>
cluster  non-empty  V166(S)  disjoint_valued  X,S -terms   all_vars_including   inheriting_operations   free_in_itself   strict   vf-free   for    VarMSAlgebra over S;
</td><td><span data-href='aofa_a00.html#RC5'>aofa_a00</span></td></tr>
<tr><td>
cluster  Relation-like  V2() S -defined   Function-like   total   disjoint_valued   for    ManySortedSubset of T;
</td><td><span data-href='aofa_a00.html#RC12'>aofa_a00</span></td></tr>
<tr><td>
cluster C -States X ->  non  empty  ;
</td><td><span data-href='aofa_a00.html#FC9'>aofa_a00</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   for    Element of C -States X;
</td><td><span data-href='aofa_a00.html#CC3'>aofa_a00</span></td></tr>
<tr><td>
cluster   ->  the carrier of B -defined   Function-yielding   for    Element of C -States X;
</td><td><span data-href='aofa_a00.html#CC4'>aofa_a00</span></td></tr>
<tr><td>
cluster   ->  total   for    Element of C -States X;
</td><td><span data-href='aofa_a00.html#CC5'>aofa_a00</span></td></tr>
<tr><td>
cluster C -States X ->  non  empty  ;
</td><td><span data-href='aofa_a00.html#FC10'>aofa_a00</span></td></tr>
<tr><td>
cluster C -States G ->  non  empty  ;
</td><td><span data-href='aofa_a00.html#FC11'>aofa_a00</span></td></tr>
<tr><td>
cluster X . 1 ->  non  empty  ;
</td><td><span data-href='aofa_a00.html#FC13'>aofa_a00</span></td></tr>
<tr><td>
cluster <*X*> ->  non-empty  ;
</td><td><span data-href='aofa_a00.html#FC17'>aofa_a00</span></td></tr>
<tr><td>
cluster <*X,Y,Z*> ->  non-empty  ;
</td><td><span data-href='aofa_a00.html#FC18'>aofa_a00</span></td></tr>
<tr><td>
cluster  Free (S,X) ->  non-empty   integer   for  non-empty   MSAlgebra over S;
</td><td><span data-href='aofa_a01.html#FC1'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty  X,S -terms   all_vars_including   inheriting_operations   free_in_itself   vf-free   disjoint_valued   integer   for    VarMSAlgebra over S;
</td><td><span data-href='aofa_a01.html#RC4'>aofa_a01</span></td></tr>
<tr><td>
cluster  FreeGen T -> V3()  Equations (S,T) -free  ;
</td><td><span data-href='aofa_a01.html#FC2'>aofa_a01</span></td></tr>
<tr><td>
cluster  FreeGen T -> V3()  basic  ;
</td><td><span data-href='aofa_a01.html#FC3'>aofa_a01</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  V3()  non  empty-yielding   the carrier of S -defined   Function-like   total   basic   for    GeneratorSet of T;
</td><td><span data-href='aofa_a01.html#RC5'>aofa_a01</span></td></tr>
<tr><td>
cluster  pure   for    Element of G . s;
</td><td><span data-href='aofa_a01.html#RC6'>aofa_a01</span></td></tr>
<tr><td>
cluster  basic   for    GeneratorSystem over S,X,T;
</td><td><span data-href='aofa_a01.html#RC7'>aofa_a01</span></td></tr>
<tr><td>
cluster  the generators of G ->  basic  ;
</td><td><span data-href='aofa_a01.html#FC4'>aofa_a01</span></td></tr>
<tr><td>
cluster (s . I) . x ->  integer  ;
</td><td><span data-href='aofa_a01.html#FC5'>aofa_a01</span></td></tr>
<tr><td>
cluster t value_at (C,s) ->  integer  ;
</td><td><span data-href='aofa_a01.html#FC6'>aofa_a01</span></td></tr>
<tr><td>
cluster t value_at (C,u) ->  integer  ;
</td><td><span data-href='aofa_a01.html#FC7'>aofa_a01</span></td></tr>
<tr><td>
cluster t value_at (C,s) ->  boolean  ;
</td><td><span data-href='aofa_a01.html#FC8'>aofa_a01</span></td></tr>
<tr><td>
cluster t value_at (C,u) ->  boolean  ;
</td><td><span data-href='aofa_a01.html#FC9'>aofa_a01</span></td></tr>
<tr><td>
cluster  non  empty   partial   quasi_total   non-empty   with_empty-instruction   with_catenation   with_if-instruction   with_while-instruction   non  degenerated   well_founded   ECIW-strict   strict   elementary   for    ProgramAlgStr over S,T, the generators of G;
</td><td><span data-href='aofa_a01.html#RC8'>aofa_a01</span></td></tr>
<tr><td>
cluster x := (t,A) ->  absolutely-terminating  ;
</td><td><span data-href='aofa_a01.html#FC11'>aofa_a01</span></td></tr>
<tr><td>
cluster  Free (S,X) ->  non-empty   integer-array   for  non-empty   MSAlgebra over S;
</td><td><span data-href='aofa_a01.html#FC16'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty  X,S -terms   all_vars_including   inheriting_operations   free_in_itself   strict   vf-free   disjoint_valued   integer-array   for    VarMSAlgebra over S;
</td><td><span data-href='aofa_a01.html#RC9'>aofa_a01</span></td></tr>
<tr><td>
cluster (s . (the_array_sort_of S)) . M ->  Relation-like   Function-like  ;
</td><td><span data-href='aofa_a01.html#FC17'>aofa_a01</span></td></tr>
<tr><td>
cluster (s . (the_array_sort_of S)) . M ->  INT  -valued   Sequence-like   finite  ;
</td><td><span data-href='aofa_a01.html#FC18'>aofa_a01</span></td></tr>
<tr><td>
cluster  rng ((s . (the_array_sort_of S)) . M) ->  finite   integer-membered  ;
</td><td><span data-href='aofa_a01.html#FC19'>aofa_a01</span></td></tr>
<tr><td>
cluster  Free (S,X) ->  non  array-degenerated  ;
</td><td><span data-href='aofa_a01.html#FC22'>aofa_a01</span></td></tr>
<tr><td>
cluster  non-empty  X,S -terms   all_vars_including   inheriting_operations   free_in_itself   disjoint_valued   non  array-degenerated   for    MSAlgebra over S;
</td><td><span data-href='aofa_a01.html#RC12'>aofa_a01</span></td></tr>
<tr><td>
cluster (s .  the bool-sort of S) . b ->  boolean  ;
</td><td><span data-href='aofa_a01.html#FC23'>aofa_a01</span></td></tr>
<tr><td>
cluster f +* (i,x) ->  non-empty  ;
</td><td><span data-href='aofa_l00.html#FC2'>aofa_l00</span></td></tr>
<tr><td>
cluster  Relation-like  V2() J -defined   Function-like   total  X -tolerating   for    set ;
</td><td><span data-href='aofa_l00.html#RC3'>aofa_l00</span></td></tr>
<tr><td>
cluster  non  empty   PC-closed   QC-closed   with_equality  V AL-closed   for    Element of  bool ( the Sorts of L .  the formula-sort of S);
</td><td><span data-href='aofa_l00.html#RC39'>aofa_l00</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   REAL  -valued   non  empty   Sequence-like   Function-like  V39() V40() V41()  finite   positive-yielding   nonnegative-yielding  V183()  for    set ;
</td><td><span data-href='asympt_3.html#RC2'>asympt_3</span></td></tr>
<tr><td>
cluster  (Funcs) (A,A) -> V2() ;
</td><td><span data-href='autalg_1.html#FC2'>autalg_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  non-empty   for    Element of  bool [:A,B:];
</td><td><span data-href='card_3.html#CC2'>card_3</span></td></tr>
<tr><td>
cluster  product f ->  non  empty  ;
</td><td><span data-href='card_3.html#FC5'>card_3</span></td></tr>
<tr><td>
cluster   -> f -compatible   for    Element of  product f;
</td><td><span data-href='card_3.html#CC9'>card_3</span></td></tr>
<tr><td>
cluster   -> I -defined   for    Element of  product f;
</td><td><span data-href='card_3.html#CC10'>card_3</span></td></tr>
<tr><td>
cluster   ->  total   for    Element of  product f;
</td><td><span data-href='card_3.html#CC13'>card_3</span></td></tr>
<tr><td>
cluster   ->  total   for    Element of  product f;
</td><td><span data-href='card_3.html#CC14'>card_3</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   empty-yielding   the carrier of C -defined   the carrier of D -valued   empty   trivial   non  proper  V9() V10() V11() V13() V14() V15() V16() V17() V18()  Function-like   one-to-one   constant   functional   total  V28( the carrier of C, the carrier of D) V31() V35() V36() V39()  cardinal   0  -element  V43() V44() V45() V98() V99() V100() V101() V102() V105() V106() V107() V108() V109() V110() V111() V112()  identity-preserving   multiplicative   antimultiplicative   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC15'>cat_6</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   empty-yielding   the carrier of C -defined   the carrier of D -valued   empty   trivial   non  proper  V9() V10() V11() V13() V14() V15() V16() V17() V18()  Function-like   one-to-one   constant   functional   total  V28( the carrier of C, the carrier of D) V31() V35() V36() V39()  cardinal   0  -element  V43() V44() V45() V98() V99() V100() V101() V102() V105() V106() V107() V108() V109() V110() V111() V112()  covariant   contravariant   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC17'>cat_6</span></td></tr>
<tr><td>
cluster <%x%> ->  non-empty  ;
</td><td><span data-href='cayldick.html#FC3'>cayldick</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   NAT  -defined   Function-like  V25() V32()  countable  V65()  for    set ;
</td><td><span data-href='cayldick.html#RC1'>cayldick</span></td></tr>
<tr><td>
cluster f ^ g ->  non-empty  ;
</td><td><span data-href='cayldick.html#FC4'>cayldick</span></td></tr>
<tr><td>
cluster <%x,y%> ->  non-empty  ;
</td><td><span data-href='cayldick.html#FC5'>cayldick</span></td></tr>
<tr><td>
cluster A .--> B -> V2() ;
</td><td><span data-href='circcomb.html#FC5'>circcomb</span></td></tr>
<tr><td>
cluster X -CircuitStr  ->  non  empty   strict   unsplit  ;
</td><td><span data-href='circtrm1.html#FC1'>circtrm1</span></td></tr>
<tr><td>
cluster X -CircuitStr  ->  non  empty   non  void   strict  ;
</td><td><span data-href='circtrm1.html#FC2'>circtrm1</span></td></tr>
<tr><td>
cluster  the_arity_of g ->  DTree-yielding  ;
</td><td><span data-href='circtrm1.html#FC3'>circtrm1</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   finite   for    Element of  the carrier of (X -CircuitStr);
</td><td><span data-href='circtrm1.html#CC1'>circtrm1</span></td></tr>
<tr><td>
cluster   ->  DecoratedTree-like   for    Element of  the carrier of (X -CircuitStr);
</td><td><span data-href='circtrm1.html#CC2'>circtrm1</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   finite   for    Element of  the carrier' of (X -CircuitStr);
</td><td><span data-href='circtrm1.html#CC3'>circtrm1</span></td></tr>
<tr><td>
cluster   ->  DecoratedTree-like   for    Element of  the carrier' of (X -CircuitStr);
</td><td><span data-href='circtrm1.html#CC4'>circtrm1</span></td></tr>
<tr><td>
cluster  the_sort_of (v,A) ->  non  empty  ;
</td><td><span data-href='circtrm1.html#FC5'>circtrm1</span></td></tr>
<tr><td>
cluster X -CircuitSorts A -> V2() ;
</td><td><span data-href='circtrm1.html#FC6'>circtrm1</span></td></tr>
<tr><td>
cluster X -Circuit A ->  strict   non-empty   finite-yielding  ;
</td><td><span data-href='circtrm1.html#FC7'>circtrm1</span></td></tr>
<tr><td>
cluster x -tree p ->  finite  ;
</td><td><span data-href='circtrm1.html#FC8'>circtrm1</span></td></tr>
<tr><td>
cluster  MSClosureStr(# M,F #) ->  non-empty  ;
</td><td><span data-href='closure1.html#FC10'>closure1</span></td></tr>
<tr><td>
cluster  ClOp->ClSys C ->  non-empty  ;
</td><td><span data-href='closure1.html#FC19'>closure1</span></td></tr>
<tr><td>
cluster |:SF:| -> V8() ;
</td><td><span data-href='closure2.html#FC4'>closure2</span></td></tr>
<tr><td>
cluster  ClosureStr(# M,F #) ->  non-empty  ;
</td><td><span data-href='closure2.html#FC13'>closure2</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of M -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of M)  pointwise_bounded   for    Element of  bool [:omega,(bool  the carrier of M):];
</td><td><span data-href='compl_sp.html#RC1'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  open   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC6'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  closed   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC7'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of M -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of M)  pointwise_bounded   open   for    Element of  bool [:omega,(bool  the carrier of M):];
</td><td><span data-href='compl_sp.html#RC8'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of M -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of M)  pointwise_bounded   closed   for    Element of  bool [:omega,(bool  the carrier of M):];
</td><td><span data-href='compl_sp.html#RC9'>compl_sp</span></td></tr>
<tr><td>
cluster  empty   trivial   proper   with_non-empty_elements   Relation-like   non-empty   empty-yielding   NAT  -defined   reflexive   irreflexive   symmetric   antisymmetric   asymmetric   connected   strongly_connected   transitive   Function-like   one-to-one   constant   functional   ext-real  V29() V30() V31() V32() V34() V35() V36() V38() V39() V40() V50()  FinSequence-like   FinSubsequence-like   FinSequence-membered   for    a_partition of X;
</td><td><span data-href='eqrel_1.html#RC1'>eqrel_1</span></td></tr>
<tr><td>
cluster  GenMSAlg X ->  finitely-generated  ;
</td><td><span data-href='equation.html#FC2'>equation</span></td></tr>
<tr><td>
cluster  Equations S -> V2() ;
</td><td><span data-href='equation.html#FC4'>equation</span></td></tr>
<tr><td>
cluster  Relation-like  V2()  the carrier of S -defined   Function-like   non  empty   total   for    GeneratorSet of U1;
</td><td><span data-href='extens_1.html#RC1'>extens_1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   NAT  -defined   Function-like   non  empty   finite   FinSequence-like   FinSubsequence-like   for    set ;
</td><td><span data-href='finseq_1.html#RC5'>finseq_1</span></td></tr>
<tr><td>
cluster M #  -> V2() ;
</td><td><span data-href='finseq_2.html#FC6'>finseq_2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   with_zero   NAT  -defined   NAT  -valued   Function-like  V33()  FinSequence-like   FinSubsequence-like   for    FinSequence of  NAT ;
</td><td><span data-href='freealg.html#RC2'>freealg</span></td></tr>
<tr><td>
cluster  DTConUA (f,X) ->  strict   with_nonterminals   with_useful_nonterminals  ;
</td><td><span data-href='freealg.html#FC3'>freealg</span></td></tr>
<tr><td>
cluster  FreeUnivAlgZAO (f,D) ->  strict   free  ;
</td><td><span data-href='freealg.html#FC6'>freealg</span></td></tr>
<tr><td>
cluster B --> c ->  non-empty  ;
</td><td><span data-href='funcop_1.html#FC11'>funcop_1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty  I -defined   Function-like   total   for    set ;
</td><td><span data-href='funcop_1.html#RC5'>funcop_1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   Function-like   for    set ;
</td><td><span data-href='funct_1.html#RC3'>funct_1</span></td></tr>
<tr><td>
cluster  rng f ->  with_non-empty_elements  ;
</td><td><span data-href='funct_1.html#FC10'>funct_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   non-empty   Function-like   for    set ;
</td><td><span data-href='funct_1.html#RC4'>funct_1</span></td></tr>
<tr><td>
cluster a . i ->  non  empty  ;
</td><td><span data-href='funct_1.html#FC11'>funct_1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty  I -defined   Function-like   for    set ;
</td><td><span data-href='funct_1.html#RC9'>funct_1</span></td></tr>
<tr><td>
cluster f +* g ->  non-empty  ;
</td><td><span data-href='funct_4.html#FC6'>funct_4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   non-empty   omega  -defined   Function-like   Function-yielding   finite   FinSequence-like   FinSubsequence-like   for    set ;
</td><td><span data-href='funct_7.html#RC1'>funct_7</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   non-empty   omega  -defined   Function-like   finite   FinSequence-like   FinSubsequence-like   FuncSeq-like   for    set ;
</td><td><span data-href='funct_7.html#RC2'>funct_7</span></td></tr>
<tr><td>
cluster   ->  non-empty   FuncSeq-like   for    FuncSequence of q;
</td><td><span data-href='funct_7.html#CC4'>funct_7</span></td></tr>
<tr><td>
cluster  GA-Space f ->  non  empty  ;
</td><td><span data-href='genealg1.html#FC1'>genealg1</span></td></tr>
<tr><td>
cluster  Carrier F -> V2() ;
</td><td><span data-href='group_7.html#FC1'>group_7</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty  I -defined   Function-like   total   disjoint_valued   for    set ;
</td><td><span data-href='group_21.html#RC1'>group_21</span></td></tr>
<tr><td>
cluster  dprod F ->  non  empty   constituted-Functions  ;
</td><td><span data-href='group_21.html#FC1'>group_21</span></td></tr>
<tr><td>
cluster  dprod F ->  Group-like   associative  ;
</td><td><span data-href='group_21.html#FC2'>group_21</span></td></tr>
<tr><td>
cluster  dsum F ->  constituted-Functions  ;
</td><td><span data-href='group_21.html#FC3'>group_21</span></td></tr>
<tr><td>
cluster  dprod2prod F ->  bijective  ;
</td><td><span data-href='group_21.html#FC4'>group_21</span></td></tr>
<tr><td>
cluster  prod2dprod F ->  bijective  ;
</td><td><span data-href='group_21.html#FC5'>group_21</span></td></tr>
<tr><td>
cluster  dsum2sum F ->  bijective  ;
</td><td><span data-href='group_21.html#FC6'>group_21</span></td></tr>
<tr><td>
cluster  sum2dsum F ->  bijective  ;
</td><td><span data-href='group_21.html#FC7'>group_21</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   NAT  -defined   bool F -valued   non  empty   Function-like   finite   FinSequence-like   FinSubsequence-like   for    FinSequence of  bool F;
</td><td><span data-href='hallmar1.html#RC1'>hallmar1</span></td></tr>
<tr><td>
cluster  non  empty   Hall   ->  non-empty   non  empty   for    FinSequence of  bool F;
</td><td><span data-href='hallmar1.html#CC1'>hallmar1</span></td></tr>
<tr><td>
cluster v tohilbval  -> V8() ;
</td><td><span data-href='hilbert4.html#FC15'>hilbert4</span></td></tr>
<tr><td>
cluster  Objs F ->  non-empty  A -defined  ;
</td><td><span data-href='index_1.html#FC4'>index_1</span></td></tr>
<tr><td>
cluster  Mphs F ->  non-empty  A -defined  ;
</td><td><span data-href='index_1.html#FC5'>index_1</span></td></tr>
<tr><td>
cluster  Objs F ->  non-empty   total  ;
</td><td><span data-href='index_1.html#FC6'>index_1</span></td></tr>
<tr><td>
cluster  Mphs F ->  non-empty   total  ;
</td><td><span data-href='index_1.html#FC7'>index_1</span></td></tr>
<tr><td>
cluster   ->  DTree-yielding   for    Element of  Args (o,(FreeMSA V));
</td><td><span data-href='instalg1.html#CC1'>instalg1</span></td></tr>
<tr><td>
cluster  FreeGen X -> V2() ;
</td><td><span data-href='instalg1.html#FC2'>instalg1</span></td></tr>
<tr><td>
cluster  Relation-like   multiplicative-trivial   omega  -defined   INT  -valued   Function-like  V35()  FinSequence-like   FinSubsequence-like   complex-valued   ext-real-valued   real-valued   for    set ;
</td><td><span data-href='int_6.html#RC1'>int_6</span></td></tr>
<tr><td>
cluster  Relation-like   non  multiplicative-trivial   omega  -defined   INT  -valued   Function-like  V35()  FinSequence-like   FinSubsequence-like   complex-valued   ext-real-valued   real-valued   for    set ;
</td><td><span data-href='int_6.html#RC2'>int_6</span></td></tr>
<tr><td>
cluster  Relation-like   INT  -valued   Function-like   non  empty   FinSequence-like   positive-yielding   Chinese_Remainder   ->  non  multiplicative-trivial   for    set ;
</td><td><span data-href='int_6.html#CC1'>int_6</span></td></tr>
<tr><td>
cluster  Relation-like   multiplicative-trivial   INT  -valued   Function-like   FinSequence-like   ->  INT  -valued   non  empty   for    set ;
</td><td><span data-href='int_6.html#CC2'>int_6</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   NAT  -defined  D *  -valued   non  empty   Function-like   finite   FinSequence-like   FinSubsequence-like   Function-yielding  V88()  FinSequence-yielding   finite-support   for    FinSequence of D * ;
</td><td><span data-href='jordan1h.html#RC1'>jordan1h</span></td></tr>
<tr><td>
cluster  rngs F ->  non-empty  ;
</td><td><span data-href='jordan1h.html#FC1'>jordan1h</span></td></tr>
<tr><td>
cluster  Values M ->  non  empty  ;
</td><td><span data-href='jordan1h.html#FC4'>jordan1h</span></td></tr>
<tr><td>
cluster  non  empty-yielding   tabular   X_equal-in-line   Y_equal-in-column   Y_increasing-in-line   X_increasing-in-column   ->  non-empty   non  empty   for    FinSequence of  the carrier of (TOP-REAL 2) * ;
</td><td><span data-href='jordan1h.html#CC1'>jordan1h</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   non-empty   NAT  -defined   bool T -valued   Function-like  V31( NAT ) V35( NAT , bool T)  for    Element of  bool [:NAT,(bool T):];
</td><td><span data-href='kurato_0.html#RC1'>kurato_0</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   NAT  -defined   PFuncs ((A *),A) -valued   Function-like   Function-yielding  V22() V34()  FinSequence-like   FinSubsequence-like   countable   homogeneous   quasi_total   for    FinSequence of  PFuncs ((A *),A);
</td><td><span data-href='margrel1.html#RC5'>margrel1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   NAT  -defined  ( the carrier of K *) *  -valued   Function-like   finite   FinSequence-like   FinSubsequence-like   Function-yielding  V186()  Matrix-yielding   Square-Matrix-yielding   Jordan-block-yielding   for    FinSequence_of_Jordan_block of L,K;
</td><td><span data-href='matrixj2.html#RC2'>matrixj2</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   NAT  -defined  ( the carrier of K *) *  -valued   Function-like   finite   FinSequence-like   FinSubsequence-like   Function-yielding  V186()  Matrix-yielding   Square-Matrix-yielding   Jordan-block-yielding   for    FinSequence of ( the carrier of K *) * ;
</td><td><span data-href='matrixj2.html#RC3'>matrixj2</span></td></tr>
<tr><td>
cluster  bool A -> V2() ;
</td><td><span data-href='mboolean.html#FC1'>mboolean</span></td></tr>
<tr><td>
cluster  the_Values_of S ->  non-empty  ;
</td><td><span data-href='memstr_0.html#FC3'>memstr_0</span></td></tr>
<tr><td>
cluster  coprod  -> V5() ;
</td><td><span data-href='msafree.html#FC3'>msafree</span></td></tr>
<tr><td>
cluster  Union X ->  non  empty  ;
</td><td><span data-href='msafree.html#FC4'>msafree</span></td></tr>
<tr><td>
cluster  DTConMSA X ->  with_terminals   with_nonterminals   with_useful_nonterminals  ;
</td><td><span data-href='msafree.html#FC6'>msafree</span></td></tr>
<tr><td>
cluster  FreeSort (X,s) ->  non  empty  ;
</td><td><span data-href='msafree.html#FC7'>msafree</span></td></tr>
<tr><td>
cluster  FreeSort X -> V5() ;
</td><td><span data-href='msafree.html#FC8'>msafree</span></td></tr>
<tr><td>
cluster  FreeMSA X ->  strict   non-empty  ;
</td><td><span data-href='msafree.html#FC9'>msafree</span></td></tr>
<tr><td>
cluster  FreeGen (s,X) ->  non  empty  ;
</td><td><span data-href='msafree.html#FC10'>msafree</span></td></tr>
<tr><td>
cluster  FreeSort X ->  disjoint_valued  ;
</td><td><span data-href='msafree1.html#FC4'>msafree1</span></td></tr>
<tr><td>
cluster  FreeMSA X ->  non-empty  ;
</td><td><span data-href='msafree1.html#FC5'>msafree1</span></td></tr>
<tr><td>
cluster  the Sorts of (FreeMSA X) ->  disjoint_valued  ;
</td><td><span data-href='msafree1.html#FC8'>msafree1</span></td></tr>
<tr><td>
cluster  FreeMSA X ->  disjoint_valued  ;
</td><td><span data-href='msafree1.html#FC9'>msafree1</span></td></tr>
<tr><td>
cluster   ->  Relation-like   non  empty   Function-like   finite   for    Element of  the Sorts of (FreeMSA X) . v;
</td><td><span data-href='msafree2.html#CC3'>msafree2</span></td></tr>
<tr><td>
cluster  Relation-like   non  empty   Function-like   finite   countable   for    Element of  the Sorts of (FreeMSA X) . v;
</td><td><span data-href='msafree2.html#RC5'>msafree2</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like   ->  Relation-like   Function-like   DecoratedTree-like   for    Element of  the Sorts of (FreeMSA X) . v;
</td><td><span data-href='msafree2.html#CC4'>msafree2</span></td></tr>
<tr><td>
cluster  Relation-like   non  empty   Function-like   finite   countable   DecoratedTree-like   for    Element of  the Sorts of (FreeMSA X) . v;
</td><td><span data-href='msafree2.html#RC6'>msafree2</span></td></tr>
<tr><td>
cluster p * F ->  FinSequence-like  ;
</td><td><span data-href='msafree4.html#FC1'>msafree4</span></td></tr>
<tr><td>
cluster  rngs f -> V5() ;
</td><td><span data-href='msafree4.html#FC7'>msafree4</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   for    Element of A . x;
</td><td><span data-href='msafree4.html#CC3'>msafree4</span></td></tr>
<tr><td>
cluster  Relation-like  V5() I -defined   Function-like   total   countable   for    set ;
</td><td><span data-href='msafree4.html#RC3'>msafree4</span></td></tr>
<tr><td>
cluster  Relation-like  V5() I -defined   Function-like   total  V276()  for    set ;
</td><td><span data-href='msafree4.html#RC6'>msafree4</span></td></tr>
<tr><td>
cluster  Free (S,X) -> X,S -terms  ;
</td><td><span data-href='msafree4.html#FC14'>msafree4</span></td></tr>
<tr><td>
cluster  Free (S,X) ->  non-empty   disjoint_valued  ;
</td><td><span data-href='msafree4.html#FC15'>msafree4</span></td></tr>
<tr><td>
cluster  strict   non-empty  X,S -terms   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#RC10'>msafree4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  V5()  the carrier of J -defined   Function-like   total   for    GeneratorSet of T;
</td><td><span data-href='msafree4.html#RC11'>msafree4</span></td></tr>
<tr><td>
cluster  Free (S,X) ->  all_vars_including   inheriting_operations   free_in_itself  ;
</td><td><span data-href='msafree4.html#FC16'>msafree4</span></td></tr>
<tr><td>
cluster X,S -terms   all_vars_including   ->  non-empty  X,S -terms   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#CC5'>msafree4</span></td></tr>
<tr><td>
cluster  strict  X,S -terms   all_vars_including   inheriting_operations   free_in_itself   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#RC12'>msafree4</span></td></tr>
<tr><td>
cluster  Relation-like  V5() S -defined   Function-like   total   disjoint_valued   for    set ;
</td><td><span data-href='msafree4.html#RC13'>msafree4</span></td></tr>
<tr><td>
cluster   ->  disjoint_valued   for    ManySortedSubset of T;
</td><td><span data-href='msafree4.html#CC6'>msafree4</span></td></tr>
<tr><td>
cluster  strict  X,S -terms   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#RC14'>msafree4</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   for    Element of  Union  the Sorts of A0;
</td><td><span data-href='msafree4.html#CC7'>msafree4</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   for    Element of  the Sorts of A0 . s;
</td><td><span data-href='msafree4.html#CC8'>msafree4</span></td></tr>
<tr><td>
cluster   ->  DecoratedTree-like   for    Element of  Union  the Sorts of A0;
</td><td><span data-href='msafree4.html#CC9'>msafree4</span></td></tr>
<tr><td>
cluster   ->  DecoratedTree-like   for    Element of  the Sorts of A0 . s;
</td><td><span data-href='msafree4.html#CC10'>msafree4</span></td></tr>
<tr><td>
cluster X,S -terms   ->  disjoint_valued   for    MSAlgebra over S;
</td><td><span data-href='msafree4.html#CC11'>msafree4</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   for    Element of G . s;
</td><td><span data-href='msafree4.html#CC14'>msafree4</span></td></tr>
<tr><td>
cluster V6()  ->  invariant   stable   NF-var   for    ManySortedRelation of  the Sorts of (Free (S,X)), the Sorts of (Free (S,X));
</td><td><span data-href='msafree4.html#CC17'>msafree4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of S -defined   Function-like   total   Relation-yielding   invariant   stable   terminating   with_UN_property   NF-var   for    ManySortedRelation of  the Sorts of (Free (S,X)), the Sorts of (Free (S,X));
</td><td><span data-href='msafree4.html#RC17'>msafree4</span></td></tr>
<tr><td>
cluster  NFAlgebra R ->  strict   non-empty  X,S -terms  ;
</td><td><span data-href='msafree4.html#FC19'>msafree4</span></td></tr>
<tr><td>
cluster  NFAlgebra R ->  strict   non-empty   all_vars_including   inheriting_operations   free_in_itself  ;
</td><td><span data-href='msafree4.html#FC20'>msafree4</span></td></tr>
<tr><td>
cluster   ->  finite   for    Element of  Union  the Sorts of T;
</td><td><span data-href='msafree5.html#CC1'>msafree5</span></td></tr>
<tr><td>
cluster  Relation-like   non-trivial   ->  non-empty   for    set ;
</td><td><span data-href='msafree5.html#CC3'>msafree5</span></td></tr>
<tr><td>
cluster   ->  DTree-yielding   for    Element of  Args (o,(Free (S,X)));
</td><td><span data-href='msafree5.html#CC5'>msafree5</span></td></tr>
<tr><td>
cluster   ->  Union  the Sorts of T -valued   for    Element of  Args (o,T);
</td><td><span data-href='msafree5.html#CC8'>msafree5</span></td></tr>
<tr><td>
cluster x -term  ->  non  compound  ;
</td><td><span data-href='msafree5.html#FC12'>msafree5</span></td></tr>
<tr><td>
cluster o -term p ->  compound   the_result_sort_of o -sort  ;
</td><td><span data-href='msafree5.html#FC13'>msafree5</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   non  pair   Function-like   finite   DecoratedTree-like   countable   compound   for    Element of  Union  the Sorts of (Free (S,X));
</td><td><span data-href='msafree5.html#RC7'>msafree5</span></td></tr>
<tr><td>
cluster T deg<= i ->  non  empty  ;
</td><td><span data-href='msafree5.html#FC16'>msafree5</span></td></tr>
<tr><td>
cluster T height<= i ->  non  empty  ;
</td><td><span data-href='msafree5.html#FC17'>msafree5</span></td></tr>
<tr><td>
cluster  vf r ->  finite  ;
</td><td><span data-href='msafree5.html#FC18'>msafree5</span></td></tr>
<tr><td>
cluster x -context   -> s -context   for    Element of  Union  the Sorts of (Free (S,X));
</td><td><span data-href='msafree5.html#CC10'>msafree5</span></td></tr>
<tr><td>
cluster x -term  -> x -context  ;
</td><td><span data-href='msafree5.html#FC19'>msafree5</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   non  pair   Function-like   finite   DecoratedTree-like   countable   non  compound  x -context   for    Element of  Union  the Sorts of (Free (S,X));
</td><td><span data-href='msafree5.html#RC8'>msafree5</span></td></tr>
<tr><td>
cluster x -omitting   ->  non x -context   for    Element of  Union  the Sorts of (Free (S,X));
</td><td><span data-href='msafree5.html#CC11'>msafree5</span></td></tr>
<tr><td>
cluster x -context_including   ->  non  empty   for    Element of  Args (o,(Free (S,X)));
</td><td><span data-href='msafree5.html#CC12'>msafree5</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of S -defined   Function-like   total   Function-yielding   Relation-yielding  x -constant   for    Homomorphism of  Free (S,X),T;
</td><td><span data-href='msafree5.html#RC14'>msafree5</span></td></tr>
<tr><td>
cluster  NFAlgebra R ->  struct-invariant  ;
</td><td><span data-href='msafree5.html#FC23'>msafree5</span></td></tr>
<tr><td>
cluster  non-empty   disjoint_valued  X,S -terms   all_vars_including   inheriting_operations   free_in_itself   non  empty   struct-invariant   for    MSAlgebra over S;
</td><td><span data-href='msafree5.html#RC15'>msafree5</span></td></tr>
<tr><td>
cluster  the_sort_of C -> s -reachable  ;
</td><td><span data-href='msafree5.html#FC24'>msafree5</span></td></tr>
<tr><td>
cluster  Coim (t,a) ->  FinSequence-membered  ;
</td><td><span data-href='msafree5.html#FC25'>msafree5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   Union X -valued   Function-like   finite   FinSequence-like   FinSubsequence-like   countable  B -sorts   for    FinSequence of  Union X;
</td><td><span data-href='msafree5.html#RC17'>msafree5</span></td></tr>
<tr><td>
cluster B -sorts   ->  non  empty   for    FinSequence of  Union X;
</td><td><span data-href='msafree5.html#CC13'>msafree5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   Union  the Sorts of (Free (S,X)) -valued   Function-like   finite   FinSequence-like   FinSubsequence-like   Function-yielding   Relation-yielding   DTree-yielding   countable  B -sorts   for    FinSequence of  Union  the Sorts of (Free (S,X));
</td><td><span data-href='msafree5.html#RC18'>msafree5</span></td></tr>
<tr><td>
cluster B -sorts   ->  non  empty   for    FinSequence of  Union  the Sorts of (Free (S,X));
</td><td><span data-href='msafree5.html#CC14'>msafree5</span></td></tr>
<tr><td>
cluster V -context-sequence   ->  non  empty   for    FinSequence of  Union  the Sorts of (Free (S,X));
</td><td><span data-href='msafree5.html#CC15'>msafree5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   Union  the Sorts of (Free (S,X)) -valued   Function-like   finite   FinSequence-like   FinSubsequence-like   Function-yielding   Relation-yielding   DTree-yielding   countable  V -context-sequence   for    FinSequence of  Union  the Sorts of (Free (S,X));
</td><td><span data-href='msafree5.html#RC19'>msafree5</span></td></tr>
<tr><td>
cluster S -Terms V ->  non  empty  ;
</td><td><span data-href='msaterm.html#FC1'>msaterm</span></td></tr>
<tr><td>
cluster   ->  finite   for    Element of S -Terms V;
</td><td><span data-href='msaterm.html#CC1'>msaterm</span></td></tr>
<tr><td>
cluster  Relation-like  V2()  the carrier of S -defined   Function-like   non  empty  V28()  total   for    GeneratorSet of A;
</td><td><span data-href='msscyc_1.html#RC7'>msscyc_1</span></td></tr>
<tr><td>
cluster  FreeGen (v,X) ->  finite  ;
</td><td><span data-href='msscyc_1.html#FC2'>msscyc_1</span></td></tr>
<tr><td>
cluster  Relation-like  V8() I -defined   Function-like   total   for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#RC2'>mssubfam</span></td></tr>
<tr><td>
cluster  Relation-like  V8() I -defined   Function-like   total  V39()  for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#RC4'>mssubfam</span></td></tr>
<tr><td>
cluster  Relation-like  V8() I -defined   Function-like   total   additive   absolutely-additive   multiplicative   absolutely-multiplicative   properly-upper-bound   properly-lower-bound   for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#RC5'>mssubfam</span></td></tr>
<tr><td>
cluster  properly-upper-bound   -> V8()  for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#CC6'>mssubfam</span></td></tr>
<tr><td>
cluster  properly-lower-bound   -> V8()  for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#CC8'>mssubfam</span></td></tr>
<tr><td>
cluster  the Sorts of A -> V5() ;
</td><td><span data-href='msualg_1.html#FC1'>msualg_1</span></td></tr>
<tr><td>
cluster X (\/) Y -> V8() ;
</td><td><span data-href='msualg_2.html#FC1'>msualg_2</span></td></tr>
<tr><td>
cluster Y (\/) X -> V8() ;
</td><td><span data-href='msualg_2.html#FC2'>msualg_2</span></td></tr>
<tr><td>
cluster  Constants U0 -> V8() ;
</td><td><span data-href='msualg_2.html#FC5'>msualg_2</span></td></tr>
<tr><td>
cluster  GenMSAlg A ->  strict   non-empty  ;
</td><td><span data-href='msualg_2.html#FC10'>msualg_2</span></td></tr>
<tr><td>
cluster  MSEquivalence-like   -> V2()  for    ManySortedRelation of  the Sorts of A, the Sorts of A;
</td><td><span data-href='msualg_6.html#CC4'>msualg_6</span></td></tr>
<tr><td>
cluster  InvCl R -> V2()  invariant  ;
</td><td><span data-href='msualg_6.html#FC2'>msualg_6</span></td></tr>
<tr><td>
cluster  StabCl R -> V2()  stable  ;
</td><td><span data-href='msualg_6.html#FC3'>msualg_6</span></td></tr>
<tr><td>
cluster  TRS R -> V2()  invariant   stable  ;
</td><td><span data-href='msualg_6.html#FC4'>msualg_6</span></td></tr>
<tr><td>
cluster  Relation-like  V2() I -defined   Function-like   total  V35()  for    ManySortedSubset of M;
</td><td><span data-href='msualg_9.html#RC2'>msualg_9</span></td></tr>
<tr><td>
cluster  FreeGen X -> V2()  free  ;
</td><td><span data-href='msualg_9.html#FC1'>msualg_9</span></td></tr>
<tr><td>
cluster  FreeMSA X ->  free  ;
</td><td><span data-href='msualg_9.html#FC2'>msualg_9</span></td></tr>
<tr><td>
cluster  the Sorts of (Trivial_Algebra S) -> V2() V35() ;
</td><td><span data-href='msualg_9.html#FC4'>msualg_9</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   empty-yielding   NAT  -defined   RAT  -valued   empty   trivial   proper  V9() V10() V11() V13() V14() V15()  zero  V17() V18()  complex  V20()  Function-like   one-to-one   constant   functional   finite   finite-yielding  V36()  cardinal   0  -element   FinSequence-like   FinSubsequence-like   FinSequence-membered   ext-real   non  positive   non  negative  V53() V54() V55() V56() V57() V58() V59() V60() V63() V64() V65() V66() V67() V68() V69()  Function-yielding   reflexive   irreflexive   symmetric   antisymmetric   asymmetric   connected   strongly_connected   transitive   FinSequence-yielding   finite-support  V107()  for    a_partition of A;
</td><td><span data-href='orders_5.html#RC2'>orders_5</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like   Sequence-like   Ordinal-yielding   Cantor-normal-form   ->  non-empty   for    set ;
</td><td><span data-href='ordinal5.html#CC9'>ordinal5</span></td></tr>
<tr><td>
cluster  Sum^ A ->  non  empty  ;
</td><td><span data-href='ordinal7.html#FC5'>ordinal7</span></td></tr>
<tr><td>
cluster  Sum^ (A ^ B) ->  non  empty  ;
</td><td><span data-href='ordinal7.html#FC6'>ordinal7</span></td></tr>
<tr><td>
cluster  Sum^ (B ^ A) ->  non  empty  ;
</td><td><span data-href='ordinal7.html#FC7'>ordinal7</span></td></tr>
<tr><td>
cluster omega -leading_coeff A ->  non-empty   natural-valued  ;
</td><td><span data-href='ordinal7.html#FC26'>ordinal7</span></td></tr>
<tr><td>
cluster  DTConOSA X ->  with_terminals   with_nonterminals   with_useful_nonterminals  ;
</td><td><span data-href='osafree.html#FC2'>osafree</span></td></tr>
<tr><td>
cluster  ParsedTerms (X,s) ->  non  empty  ;
</td><td><span data-href='osafree.html#FC3'>osafree</span></td></tr>
<tr><td>
cluster  ParsedTerms X -> V2() ;
</td><td><span data-href='osafree.html#FC4'>osafree</span></td></tr>
<tr><td>
cluster  ParsedTermsOSA X ->  strict   non-empty  ;
</td><td><span data-href='osafree.html#FC5'>osafree</span></td></tr>
<tr><td>
cluster  Args (o2,(ParsedTermsOSA X)) ->  non  empty  ;
</td><td><span data-href='osafree.html#FC6'>osafree</span></td></tr>
<tr><td>
cluster  PTCongruence X ->  MSEquivalence-like   monotone  ;
</td><td><span data-href='osafree.html#FC7'>osafree</span></td></tr>
<tr><td>
cluster  PTVars (s,X) ->  non  empty  ;
</td><td><span data-href='osafree.html#FC8'>osafree</span></td></tr>
<tr><td>
cluster  OSFreeGen (s,X) ->  non  empty  ;
</td><td><span data-href='osafree.html#FC9'>osafree</span></td></tr>
<tr><td>
cluster  OSFreeGen X -> V2() ;
</td><td><span data-href='osafree.html#FC10'>osafree</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  V8()  the carrier of R -defined   Function-like  V25( the carrier of R)  order-sorted   for    set ;
</td><td><span data-href='osalg_1.html#RC11'>osalg_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  V8()  the carrier of R -defined   Function-like  V17( the carrier of R)  for    OrderSortedSubset of M;
</td><td><span data-href='osalg_2.html#RC1'>osalg_2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  V8()  the carrier of S -defined   Function-like  V17( the carrier of S)  for    OSSubset of U0;
</td><td><span data-href='osalg_2.html#RC3'>osalg_2</span></td></tr>
<tr><td>
cluster  OSClass E -> V2() ;
</td><td><span data-href='osalg_4.html#FC2'>osalg_4</span></td></tr>
<tr><td>
cluster f " {0} ->  empty  ;
</td><td><span data-href='partfun3.html#FC6'>partfun3</span></td></tr>
<tr><td>
cluster X --> 0 ->  non  non-empty  ;
</td><td><span data-href='partfun3.html#FC11'>partfun3</span></td></tr>
<tr><td>
cluster  Relation-like   positive-yielding   ->  non-empty   nonnegative-yielding   for    set ;
</td><td><span data-href='partfun3.html#CC1'>partfun3</span></td></tr>
<tr><td>
cluster  Relation-like   negative-yielding   ->  non-empty   nonpositive-yielding   for    set ;
</td><td><span data-href='partfun3.html#CC2'>partfun3</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   Function-like   real-valued   for    set ;
</td><td><span data-href='partfun3.html#RC3'>partfun3</span></td></tr>
<tr><td>
cluster f (#) g ->  non-empty  ;
</td><td><span data-href='partfun3.html#FC32'>partfun3</span></td></tr>
<tr><td>
cluster r (#) f ->  non-empty  ;
</td><td><span data-href='partfun3.html#FC42'>partfun3</span></td></tr>
<tr><td>
cluster f / g ->  non-empty  ;
</td><td><span data-href='partfun3.html#FC52'>partfun3</span></td></tr>
<tr><td>
cluster  Inv f ->  non-empty  ;
</td><td><span data-href='partfun3.html#FC57'>partfun3</span></td></tr>
<tr><td>
cluster  - f ->  non-empty  ;
</td><td><span data-href='partfun3.html#FC58'>partfun3</span></td></tr>
<tr><td>
cluster |.f.| ->  positive-yielding  ;
</td><td><span data-href='partfun3.html#FC64'>partfun3</span></td></tr>
<tr><td>
cluster f ^  ->  non-empty  ;
</td><td><span data-href='partfun3.html#FC69'>partfun3</span></td></tr>
<tr><td>
cluster K484(f) ->  continuous   for  RealMap of T;
</td><td><span data-href='partfun4.html#FC8'>partfun4</span></td></tr>
<tr><td>
cluster K481(f,g) ->  continuous   for  RealMap of T;
</td><td><span data-href='partfun4.html#FC9'>partfun4</span></td></tr>
<tr><td>
cluster  Relation-like  V8() I -defined   Function-like   total   for    set ;
</td><td><span data-href='pboole.html#RC3'>pboole</span></td></tr>
<tr><td>
cluster  Relation-like  V8() I -defined   Function-like   total   -> V9()  for    set ;
</td><td><span data-href='pboole.html#CC1'>pboole</span></td></tr>
<tr><td>
cluster  Relation-like  V9() I -defined   Function-like   total   -> V8()  for    set ;
</td><td><span data-href='pboole.html#CC2'>pboole</span></td></tr>
<tr><td>
cluster B . j ->  non  empty  ;
</td><td><span data-href='pboole.html#FC2'>pboole</span></td></tr>
<tr><td>
cluster  Relation-like  V8() I -defined   Function-like   total   for    ManySortedSubset of M;
</td><td><span data-href='pboole.html#RC5'>pboole</span></td></tr>
<tr><td>
cluster  Relation-like  V8() A -defined   Function-like   total   -> V9()  for    set ;
</td><td><span data-href='pboole.html#CC4'>pboole</span></td></tr>
<tr><td>
cluster  Relation-like  I -defined   Function-like  f -compatible   total   for    set ;
</td><td><span data-href='pboole.html#RC6'>pboole</span></td></tr>
<tr><td>
cluster  id X ->  non-empty  ;
</td><td><span data-href='pboole.html#FC5'>pboole</span></td></tr>
<tr><td>
cluster  Relation-like  V2() I -defined   Function-like  V14(I)  trivial-yielding   Segre-like   for    ManySortedSubset of  Carrier A;
</td><td><span data-href='pencil_1.html#RC4'>pencil_1</span></td></tr>
<tr><td>
cluster  Relation-like  V2() I -defined   Function-like  V14(I)  non  trivial-yielding   Segre-like   for    ManySortedSubset of  Carrier A;
</td><td><span data-href='pencil_1.html#RC5'>pencil_1</span></td></tr>
<tr><td>
cluster  Relation-like  I -defined   Function-like  V14(I)  non  trivial-yielding   Segre-like   -> V2()  for    set ;
</td><td><span data-href='pencil_1.html#CC5'>pencil_1</span></td></tr>
<tr><td>
cluster  Carrier A -> V2() ;
</td><td><span data-href='pralg_1.html#FC2'>pralg_1</span></td></tr>
<tr><td>
cluster  product B ->  non  empty  ;
</td><td><span data-href='pralg_1.html#FC3'>pralg_1</span></td></tr>
<tr><td>
cluster  Relation-like  J -defined   Function-like   non  empty   total   Function-yielding  V48()  equal-arity   for    ManySortedOperation of B;
</td><td><span data-href='pralg_1.html#RC5'>pralg_1</span></td></tr>
<tr><td>
cluster  uncurry p -> [:(dom p),J:] -defined  ;
</td><td><span data-href='pralg_1.html#FC6'>pralg_1</span></td></tr>
<tr><td>
cluster  uncurry p -> [:(dom p),J:] -defined   total   for [:(dom p),J:] -defined  Function;
</td><td><span data-href='pralg_1.html#FC7'>pralg_1</span></td></tr>
<tr><td>
cluster [|A,B|] -> V2() ;
</td><td><span data-href='pralg_2.html#FC1'>pralg_2</span></td></tr>
<tr><td>
cluster  Carrier (A,s) -> V2() ;
</td><td><span data-href='pralg_2.html#FC5'>pralg_2</span></td></tr>
<tr><td>
cluster  SORTS A -> V2() ;
</td><td><span data-href='pralg_2.html#FC6'>pralg_2</span></td></tr>
<tr><td>
cluster  id X ->  non-empty  ;
</td><td><span data-href='pralg_3.html#FC2'>pralg_3</span></td></tr>
<tr><td>
cluster  Relation-like  V2() I -defined   Function-like   total  V44()  for    set ;
</td><td><span data-href='pre_circ.html#RC1'>pre_circ</span></td></tr>
<tr><td>
cluster M | A ->  non-empty  ;
</td><td><span data-href='pre_circ.html#FC3'>pre_circ</span></td></tr>
<tr><td>
cluster X ^ Y ->  non-empty  ;
</td><td><span data-href='prvect_3.html#FC1'>prvect_3</span></td></tr>
<tr><td>
cluster   ->  non-empty   for    FinSequence of X;
</td><td><span data-href='pua2mss1.html#CC1'>pua2mss1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   NAT  -defined   PFuncs ((A *),A) -valued   non  empty   Function-like  V50()  FinSequence-like   FinSubsequence-like   countable   homogeneous   quasi_total   for    FinSequence of  PFuncs ((A *),A);
</td><td><span data-href='pua2mss1.html#RC1'>pua2mss1</span></td></tr>
<tr><td>
cluster   ->  non-empty   one-to-one   for    IndexedPartition of X;
</td><td><span data-href='pua2mss1.html#CC3'>pua2mss1</span></td></tr>
<tr><td>
cluster {A} -> V2() V26() ;
</td><td><span data-href='pzfmisc1.html#FC1'>pzfmisc1</span></td></tr>
<tr><td>
cluster {A,B} -> V2() V26() ;
</td><td><span data-href='pzfmisc1.html#FC2'>pzfmisc1</span></td></tr>
<tr><td>
cluster D . n ->  non  empty  ;
</td><td><span data-href='random_3.html#FC2'>random_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   non  empty   Function-like   total  S -Probability_sequence-like   for    set ;
</td><td><span data-href='random_3.html#RC9'>random_3</span></td></tr>
<tr><td>
cluster  Product_dom D ->  non-empty  ;
</td><td><span data-href='random_3.html#FC3'>random_3</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   for    set ;
</td><td><span data-href='relat_1.html#RC2'>relat_1</span></td></tr>
<tr><td>
cluster R (#) S ->  non-empty  ;
</td><td><span data-href='relat_1.html#FC15'>relat_1</span></td></tr>
<tr><td>
cluster  empty   Relation-like   ->  non-empty   for    set ;
</td><td><span data-href='relat_1.html#CC4'>relat_1</span></td></tr>
<tr><td>
cluster SCM+FSA-OK * SCM*-VAL ->  non-empty  ;
</td><td><span data-href='scmfsa_1.html#FC3'>scmfsa_1</span></td></tr>
<tr><td>
cluster SCM-OK * (SCM-VAL G) ->  non-empty  ;
</td><td><span data-href='scmring1.html#FC1'>scmring1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty  K42() -defined   Function-like   finite  n -element   FinSequence-like   FinSubsequence-like   countable   for    set ;
</td><td><span data-href='srings_4.html#RC3'>srings_4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  K42() -defined   Function-like   finite  n -element   FinSequence-like   FinSubsequence-like   countable   cap-closed-yielding   for    SemiringFamily of X;
</td><td><span data-href='srings_4.html#RC4'>srings_4</span></td></tr>
<tr><td>
cluster  SemiringProduct S ->  cap-closed  ;
</td><td><span data-href='srings_4.html#FC11'>srings_4</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   the carrier of T -defined   the carrier of R^1 -valued   Function-like   non  empty   total  V18( the carrier of T, the carrier of R^1)  complex-valued   ext-real-valued   real-valued   continuous   for    Element of  bool [: the carrier of T, the carrier of R^1:];
</td><td><span data-href='toprealc.html#RC3'>toprealc</span></td></tr>
<tr><td>
cluster f "  ->  continuous   for  Function of T,R^1;
</td><td><span data-href='toprealc.html#FC25'>toprealc</span></td></tr>
<tr><td>
cluster f /" g ->  continuous   for  Function of T,R^1;
</td><td><span data-href='toprealc.html#FC33'>toprealc</span></td></tr>
<tr><td>
cluster f </> g ->  continuous   for  Function of T,(TOP-REAL n);
</td><td><span data-href='toprealc.html#FC40'>toprealc</span></td></tr>
<tr><td>
cluster  Relation-like   non  non-empty   Function-like   for    set ;
</td><td><span data-href='tops_5.html#RC2'>tops_5</span></td></tr>
<tr><td>
cluster  Carrier J ->  non-empty  ;
</td><td><span data-href='tops_5.html#FC5'>tops_5</span></td></tr>
<tr><td>
cluster  ProjMap f ->  non-empty  ;
</td><td><span data-href='tops_5.html#FC9'>tops_5</span></td></tr>
<tr><td>
cluster  ProjMap f ->  empty-yielding  ;
</td><td><span data-href='tops_5.html#FC10'>tops_5</span></td></tr>
<tr><td>
cluster  ProjMap J ->  non  empty   non-empty   Function-yielding  ;
</td><td><span data-href='tops_5.html#FC11'>tops_5</span></td></tr>
<tr><td>
cluster  the charact of U1 ->  non-empty   non  empty  ;
</td><td><span data-href='unialg_1.html#FC4'>unialg_1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined  X -valued   Function-like   non  empty   total   quasi_total   for    Element of  bool [:omega,X:];
</td><td><span data-href='valued_0.html#RC5'>valued_0</span></td></tr>
<tr><td>
cluster   ->  non-empty   for    subsequence of s;
</td><td><span data-href='valued_0.html#CC27'>valued_0</span></td></tr>
<tr><td>
cluster  proj2 (F . j) ->  non  empty  ;
</td><td><span data-href='waybel_5.html#FC1'>waybel_5</span></td></tr>
<tr><td>
cluster   -> V9()  for    ManySortedFunction of K,J --> D;
</td><td><span data-href='waybel_5.html#CC1'>waybel_5</span></td></tr>
<tr><td>
cluster  doms f ->  non-empty  ;
</td><td><span data-href='waybel_5.html#FC2'>waybel_5</span></td></tr>
<tr><td>
cluster  Carrier J -> V2() ;
</td><td><span data-href='yellow_6.html#FC5'>yellow_6</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty  W -valued   Sequence-like   Function-like   DOMAIN-yielding   for    set ;
</td><td><span data-href='zf_refle.html#RC2'>zf_refle</span></td></tr>
</tbody>
</table>
</div>
<div class='related-reduce'>
<table class='pure-table'>
<thead><tr><th colspan='2'>reduce</th></tr></thead>
<tbody>
<tr><td>
reduce (canonical_homomorphism T) . (@ r) to r;
</td><td><span data-href='msafree5.html#RD8'>msafree5</span></td></tr>
<tr><td>
reduce (canonical_homomorphism T) . (x -term) to x -term ;
</td><td><span data-href='msafree5.html#RD9'>msafree5</span></td></tr>
<tr><td>
reduce C -sub (x -term) to C;
</td><td><span data-href='msafree5.html#RD10'>msafree5</span></td></tr>
<tr><td>
reduce ((canonical_homomorphism T) . s) . (x -term) to x -term ;
</td><td><span data-href='msafree5.html#RD11'>msafree5</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM27602'>
<h2>7.   <span data-link='3057.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='unialg_1.html#V4'>unialg_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">IT</font> be    <span title="UNIALG_1:struct.1" data-link="8470.html#ELM27597">UAStr</span> ;<br><div about="#D1" typeof="oo:Definition">
<a name="V2"><span class="kw">attr</span> </a><font color="Maroon" title="c1">IT</font> is  <span title="UNIALG_1:attr.2" data-link="4254.html#ELM27600">partial</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E1">Def1</font></span>: <a name="D1"><span class="comment"><font color="firebrick">:: UNIALG_1:def 1</font></span><br></a> the <span title="UNIALG_1:sel.1" data-href="unialg_1.html#U1">charact</span> of <font color="Maroon" title="c1">IT</font> is  <span title="MARGREL1:attr.4" data-link="1759.html#ELM14399">homogeneous</span> ;<br>
</div>
<div about="#D2" typeof="oo:Definition">
<a name="V3"><span class="kw">attr</span> </a><font color="Maroon" title="c1">IT</font> is  <span title="UNIALG_1:attr.3" data-link="3165.html#ELM27601">quasi_total</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E2">Def2</font></span>: <a name="D2"><span class="comment"><font color="firebrick">:: UNIALG_1:def 2</font></span><br></a> the <span title="UNIALG_1:sel.1" data-href="unialg_1.html#U1">charact</span> of <font color="Maroon" title="c1">IT</font> is  <span title="MARGREL1:attr.5" data-link="3165.html#ELM14400">quasi_total</span> ;<br>
</div>
<div about="#D3" typeof="oo:Definition" class="main-sentence">
<a name="V4"><span class="kw">attr</span> </a><font color="Maroon" title="c1">IT</font> is  <span title="UNIALG_1:attr.4" data-link="3057.html#ELM27602">non-empty</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E3">Def3</font></span>: <a name="D3"><span class="comment"><font color="firebrick">:: UNIALG_1:def 3</font></span><br></a>(  the <span title="UNIALG_1:sel.1" data-href="unialg_1.html#U1">charact</span> of <font color="Maroon" title="c1">IT</font> <span title="HIDDEN:NR.2" data-link="4138.html#ELM11933">&lt;&gt;</span>  <span title="XBOOLE_0:func.1" data-link="857.html#ELM29648">{}</span>  &amp;  the <span title="UNIALG_1:sel.1" data-href="unialg_1.html#U1">charact</span> of <font color="Maroon" title="c1">IT</font> is  <span title="RELAT_1:attr.2" data-link="3057.html#ELM22398">non-empty</span>  );<br>
</div>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  non  empty   non-empty   strict   for    TRSStr ;
</td><td><span data-href='absred_0.html#RC4'>absred_0</span></td></tr>
<tr><td>
cluster   ->  non  empty   for    Element of  rng  the charact of S;
</td><td><span data-href='absred_0.html#CC20'>absred_0</span></td></tr>
<tr><td>
cluster   ->  Relation-like   Function-like   for    Element of  dom o;
</td><td><span data-href='absred_0.html#CC21'>absred_0</span></td></tr>
<tr><td>
cluster   ->  homogeneous   for    Element of  rng  the charact of S;
</td><td><span data-href='absred_0.html#CC22'>absred_0</span></td></tr>
<tr><td>
cluster   ->  quasi_total   for    Element of  rng  the charact of S;
</td><td><span data-href='absred_0.html#CC23'>absred_0</span></td></tr>
<tr><td>
cluster  TRSStr(# X,O,r #) ->  non-empty  ;
</td><td><span data-href='absred_0.html#FC5'>absred_0</span></td></tr>
<tr><td>
cluster  TotalTRS (X,x) ->  non  empty   partial   quasi_total   non-empty   strict   Group-like   invariant  ;
</td><td><span data-href='absred_0.html#FC6'>absred_0</span></td></tr>
<tr><td>
cluster  non  empty   partial   quasi_total   non-empty   strict   Group-like   invariant   for    TRSStr ;
</td><td><span data-href='absred_0.html#RC5'>absred_0</span></td></tr>
<tr><td>
cluster  non  empty   strict   partial   quasi_total   non-empty   with_empty-instruction   with_catenation   with_if-instruction   with_while-instruction   associative   unital   for    UAStr ;
</td><td><span data-href='aofa_000.html#RC4'>aofa_000</span></td></tr>
<tr><td>
cluster  non  empty   partial   quasi_total   non-empty   free   with_empty-instruction   with_catenation   with_if-instruction   with_while-instruction   ->  non  degenerated   well_founded   for    UAStr ;
</td><td><span data-href='aofa_000.html#CC4'>aofa_000</span></td></tr>
<tr><td>
cluster  non  empty   strict   partial   quasi_total   non-empty   free   with_empty-instruction   with_catenation   with_if-instruction   with_while-instruction   infinite   non  degenerated   well_founded   ECIW-strict   for    UAStr ;
</td><td><span data-href='aofa_000.html#RC6'>aofa_000</span></td></tr>
<tr><td>
cluster  partial   quasi_total   non-empty   strict   for    ProgramAlgStr over J,T,X;
</td><td><span data-href='aofa_a00.html#RC9'>aofa_a00</span></td></tr>
<tr><td>
cluster  non  empty   partial   quasi_total   non-empty   with_empty-instruction   with_catenation   with_if-instruction   with_while-instruction   strict   for    ProgramAlgStr over J,T,X;
</td><td><span data-href='aofa_a00.html#RC10'>aofa_a00</span></td></tr>
<tr><td>
cluster  non  empty   partial   quasi_total   non-empty   with_empty-instruction   with_catenation   with_if-instruction   with_while-instruction   infinite   non  degenerated   well_founded   ECIW-strict   strict   for    ProgramAlgStr over J,T,X;
</td><td><span data-href='aofa_a00.html#RC11'>aofa_a00</span></td></tr>
<tr><td>
cluster  non  empty   partial   quasi_total   non-empty   with_empty-instruction   with_catenation   with_if-instruction   with_while-instruction   non  degenerated   well_founded   ECIW-strict   strict   elementary   for    ProgramAlgStr over S,T, the generators of G;
</td><td><span data-href='aofa_a01.html#RC8'>aofa_a01</span></td></tr>
<tr><td>
cluster  non  empty  V161() V162() V163()  with_empty-instruction   with_catenation   with_if-instruction   with_while-instruction   non  degenerated   Euclidean   for   L9();
</td><td><span data-href='aofa_i00.html#RC3'>aofa_i00</span></td></tr>
<tr><td>
cluster  non  empty   strict  V112()  quasi_total   non-empty   free   for    UAStr ;
</td><td><span data-href='freealg.html#RC4'>freealg</span></td></tr>
<tr><td>
cluster  non  empty   strict  V112()  quasi_total   non-empty   with_const_op   free   for    UAStr ;
</td><td><span data-href='freealg.html#RC6'>freealg</span></td></tr>
<tr><td>
cluster  UAStr(#  the carrier of A, the charact of A #) ->  non-empty  ;
</td><td><span data-href='mssublat.html#FC4'>mssublat</span></td></tr>
<tr><td>
cluster  non-empty   ->  non  empty   for    UAStr ;
</td><td><span data-href='pua2mss1.html#CC2'>pua2mss1</span></td></tr>
<tr><td>
cluster  DomRel A ->  total   symmetric   transitive  ;
</td><td><span data-href='pua2mss1.html#FC1'>pua2mss1</span></td></tr>
<tr><td>
cluster  LimDomRel A ->  total   symmetric   transitive  ;
</td><td><span data-href='pua2mss1.html#FC2'>pua2mss1</span></td></tr>
<tr><td>
cluster  MSSign (A,P) ->  non  empty   non  void   strict  ;
</td><td><span data-href='pua2mss1.html#FC3'>pua2mss1</span></td></tr>
<tr><td>
cluster  non  empty   strict   partial   quasi_total   non-empty   for    UAStr ;
</td><td><span data-href='unialg_1.html#RC3'>unialg_1</span></td></tr>
<tr><td>
cluster  the charact of U1 ->  non-empty   non  empty  ;
</td><td><span data-href='unialg_1.html#FC4'>unialg_1</span></td></tr>
<tr><td>
cluster  non  empty   strict  V87()  quasi_total   non-empty   for    SubAlgebra of U0;
</td><td><span data-href='unialg_2.html#RC1'>unialg_2</span></td></tr>
<tr><td>
cluster  non  empty   strict  V87()  quasi_total   non-empty   with_const_op   for    UAStr ;
</td><td><span data-href='unialg_2.html#RC2'>unialg_2</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
</body>
</html>
