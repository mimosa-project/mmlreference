<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<title>bool</title>
</head>
<body>
<div class='mml-summary'>
<h1>func bool</h1>
<h2>List of Definitions (10)</h2>
<ol>
<li><span data-link='1652.html#ELM4167'>bool</span> [<span data-href='chain_1.html#K1'>chain_1</span>]</li>
<li><span data-link='1652.html#ELM4412'>bool</span> [<span data-href='classes2.html#K2'>classes2</span>]</li>
<li><span data-link='1652.html#ELM10730'>bool</span> [<span data-href='graph_1.html#K11'>graph_1</span>]</li>
<li><span data-link='1652.html#ELM14947'>bool</span> [<span data-href='mboolean.html#K1'>mboolean</span>]</li>
<li><span data-link='1652.html#ELM16622'>bool</span> [<span data-href='monoid_1.html#K20'>monoid_1</span>]</li>
<li><span data-link='1652.html#ELM16623'>bool</span> [<span data-href='monoid_1.html#K21'>monoid_1</span>]</li>
<li><span data-link='1652.html#ELM17009'>bool</span> [<span data-href='mssubfam.html#K1'>mssubfam</span>]</li>
<li><span data-link='1652.html#ELM17013'>bool</span> [<span data-href='mssubfam.html#K5'>mssubfam</span>]</li>
<li><span data-link='1652.html#ELM25011'>bool</span> [<span data-href='setfam_1.html#K9'>setfam_1</span>]</li>
<li><span data-link='1652.html#ELM30579'>bool</span> [<span data-href='zfmisc_1.html#K1'>zfmisc_1</span>]</li>
</ol>
</div>
<div class='mml-element' id='ELM4167'>
<h2>1.   <span data-link='1652.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='chain_1.html#K1'>chain_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">B</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c2">A</font> be   <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <font color="Maroon" title="c1">B</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.1" data-link="1652.html#ELM30579">bool</span><br><span class="kw">redefine </span><a name="K1"><span class="kw">func</span> </a> <span title="CHAIN_1:func.1" data-link="1652.html#ELM4167">bool</span> <font color="Maroon" title="c2">A</font><span class="kw"> -&gt; </span>  <span title="SETFAM_1:NM.1" data-link="7849.html#ELM25001">Subset-Family</span> of <font color="Maroon" title="c1">B</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" onmouseover="rs('zfmisc_1/T67')" onmouseout="rh()" data-href="zfmisc_1.html#T67">ZFMISC_1:67</span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM4412'>
<h2>2.   <span data-link='1652.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='classes2.html#K2'>classes2</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">U</font> be   <span title="CLASSES2:NM.1" data-link="1738.html#ELM4408">Universe</span>;<br><span class="kw">let </span><font color="Maroon" title="c2">u</font> be    <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="TARSKI:func.1" data-link="857.html#ELM26065">{</span><br><span class="kw">redefine </span><a name="K1"><span class="kw">func</span> </a><span class="p1"><span title="CLASSES2:func.1" data-link="857.html#ELM4411">{</span><span class="default"><font color="Maroon" title="c2">u</font></span><span title="CLASSES2:func.1" data-link="857.html#ELM4411">}</span></span><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T2')" onmouseout="rh()" data-href="classes2.html#T2">Th2</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.1" data-link="1652.html#ELM30579">bool</span><br><span class="kw">redefine </span><a name="K2"><span class="kw">func</span> </a> <span title="CLASSES2:func.2" data-link="1652.html#ELM4412">bool</span> <font color="Maroon" title="c2">u</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T59')" onmouseout="rh()" data-href="classes2.html#T59">Th59</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="TARSKI:func.3" data-link="1741.html#ELM26067">union</span><br><span class="kw">redefine </span><a name="K3"><span class="kw">func</span> </a> <span title="CLASSES2:func.3" data-link="1741.html#ELM4413">union</span> <font color="Maroon" title="c2">u</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T59')" onmouseout="rh()" data-href="classes2.html#T59">Th59</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="SETFAM_1:func.1" data-link="1742.html#ELM25003">meet</span><br><span class="kw">redefine </span><a name="K4"><span class="kw">func</span> </a> <span title="CLASSES2:func.4" data-link="1742.html#ELM4414">meet</span> <font color="Maroon" title="c2">u</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T59')" onmouseout="rh()" data-href="classes2.html#T59">Th59</span></span>;<br><span class="kw">let </span><font color="Maroon" title="c3">v</font> be    <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="TARSKI:func.2" data-link="857.html#ELM26066">{</span><br><span class="kw">redefine </span><a name="K5"><span class="kw">func</span> </a><span class="p1"><span title="CLASSES2:func.5" data-link="857.html#ELM4415">{</span><span class="default"><font color="Maroon" title="c2">u</font>,<font color="Maroon" title="c3">v</font></span><span title="CLASSES2:func.5" data-link="857.html#ELM4415">}</span></span><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T2')" onmouseout="rh()" data-href="classes2.html#T2">Th2</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="TARSKI:func.4" data-link="802.html#ELM26068">[</span><br><span class="kw">redefine </span><a name="K6"><span class="kw">func</span> </a><span class="p1"><span title="CLASSES2:func.6" data-link="802.html#ELM4416">[</span><span class="default"><font color="Maroon" title="c2">u</font>,<font color="Maroon" title="c3">v</font></span><span title="CLASSES2:func.6" data-link="802.html#ELM4416">]</span></span><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T3')" onmouseout="rh()" data-href="classes2.html#T3">Th3</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="XBOOLE_0:func.2" data-link="1743.html#ELM29649">\/</span><br><span class="kw">redefine </span><a name="K7"><span class="kw">func</span> </a><font color="Maroon" title="c2">u</font> <span title="CLASSES2:func.7" data-link="1743.html#ELM4417">\/</span> <font color="Maroon" title="c3">v</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T60')" onmouseout="rh()" data-href="classes2.html#T60">Th60</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="XBOOLE_0:func.3" data-link="1487.html#ELM29650">/\</span><br><span class="kw">redefine </span><a name="K8"><span class="kw">func</span> </a><font color="Maroon" title="c2">u</font> <span title="CLASSES2:func.8" data-link="1487.html#ELM4418">/\</span> <font color="Maroon" title="c3">v</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T60')" onmouseout="rh()" data-href="classes2.html#T60">Th60</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="XBOOLE_0:func.4" data-link="724.html#ELM29651">\</span><br><span class="kw">redefine </span><a name="K9"><span class="kw">func</span> </a><font color="Maroon" title="c2">u</font> <span title="CLASSES2:func.9" data-link="724.html#ELM4419">\</span> <font color="Maroon" title="c3">v</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T60')" onmouseout="rh()" data-href="classes2.html#T60">Th60</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="XBOOLE_0:func.5" data-link="1174.html#ELM29652">\+\</span><br><span class="kw">redefine </span><a name="K10"><span class="kw">func</span> </a><font color="Maroon" title="c2">u</font> <span title="CLASSES2:func.10" data-link="1174.html#ELM4420">\+\</span> <font color="Maroon" title="c3">v</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T60')" onmouseout="rh()" data-href="classes2.html#T60">Th60</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><br><span class="kw">redefine </span><a name="K11"><span class="kw">func</span> </a><span class="p1"><span title="CLASSES2:func.11" data-link="395.html#ELM4421">[:</span><span class="default"><font color="Maroon" title="c2">u</font>,<font color="Maroon" title="c3">v</font></span><span title="CLASSES2:func.11" data-link="395.html#ELM4421">:]</span></span><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T61')" onmouseout="rh()" data-href="classes2.html#T61">Th61</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="FUNCT_2:func.1" data-link="52.html#ELM8878">Funcs</span><br><span class="kw">redefine </span><a name="K12"><span class="kw">func</span> </a> <span title="CLASSES2:func.12" data-link="52.html#ELM4422">Funcs</span> (<font color="Maroon" title="c2">u</font>,<font color="Maroon" title="c3">v</font>)<span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T61')" onmouseout="rh()" data-href="classes2.html#T61">Th61</span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM10730'>
<h2>3.   <span data-link='1652.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='graph_1.html#K11'>graph_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">G</font> be   <span title="GRAPH_1:NM.3" data-link="3764.html#ELM10712">Graph</span>;<br><div about="#D15" typeof="oo:Definition" class="main-sentence">
<a name="K11"><span class="kw">func</span> </a> <span title="GRAPH_1:func.11" data-link="1652.html#ELM10730">bool</span> <font color="Maroon" title="c1">G</font><span class="kw"> -&gt; </span>   <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E15">Def25</font></span>: <a name="D25"><span class="comment"><font color="firebrick">:: GRAPH_1:def 25</font></span><br></a> for <font color="Olive" title="b1">x</font> being    <span title="HIDDEN:mode.1" data-link="4140.html#ELM11935">object</span>  holds <br> ( <font color="Olive" title="b1">x</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span> <span class="kw">it</span> iff <font color="Olive" title="b1">x</font> is   <span title="GRAPH_1:attr.1" data-href="graph_1.html#V1">strict</span>   <span title="GRAPH_1:mode.3" data-link="3503.html#ELM10719">Subgraph</span> of <font color="Maroon" title="c1">G</font> );<br>
</div>
<span class="kw">existence</span> <span class="kw">uniqueness</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM14947'>
<h2>4.   <span data-link='1652.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='mboolean.html#K1'>mboolean</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">I</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c2">A</font> be   <span title="PBOOLE:NM.1" data-link="4273.html#ELM19812">ManySortedSet</span> of <font color="Maroon" title="c1">I</font>;<br><div about="#D1" typeof="oo:Definition" class="main-sentence">
<a name="K1"><span class="kw">func</span> </a> <span title="MBOOLEAN:func.1" data-link="1652.html#ELM14947">bool</span> <font color="Maroon" title="c2">A</font><span class="kw"> -&gt; </span>  <span title="PBOOLE:NM.1" data-link="4273.html#ELM19812">ManySortedSet</span> of <font color="Maroon" title="c1">I</font><span class="kw"> means </span>:<span class="lab"><font color="Green" title="E1">Def1</font></span>: <a name="D1"><span class="comment"><font color="firebrick">:: MBOOLEAN:def 1</font></span><br></a> for <font color="Olive" title="b1">i</font> being    <span title="HIDDEN:mode.1" data-link="4140.html#ELM11935">object</span>   st <font color="Olive" title="b1">i</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span> <font color="Maroon" title="c1">I</font> holds <br><span class="kw">it</span> <span title="FUNCT_1:func.1" data-link="141.html#ELM8818">.</span> <font color="Olive" title="b1">i</font> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span>  <span title="ZFMISC_1:func.1" data-link="1652.html#ELM30579">bool</span> <span class="p1">(<span class="default"><font color="Maroon" title="c2">A</font> <span title="FUNCT_1:func.1" data-link="141.html#ELM8818">.</span> <font color="Olive" title="b1">i</font></span>)</span>;<br>
</div>
<span class="kw">existence</span> <span class="kw">uniqueness</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  bool A -> V2() ;
</td><td><span data-href='mboolean.html#FC1'>mboolean</span></td></tr>
<tr><td>
cluster  bool M -> V39() ;
</td><td><span data-href='mssubfam.html#FC12'>mssubfam</span></td></tr>
<tr><td>
cluster  Relation-like  V8() I -defined   Function-like   total   for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#RC2'>mssubfam</span></td></tr>
<tr><td>
cluster  Relation-like  V9() I -defined   Function-like   total  V39()  for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#RC3'>mssubfam</span></td></tr>
<tr><td>
cluster  Relation-like  V8() I -defined   Function-like   total  V39()  for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#RC4'>mssubfam</span></td></tr>
<tr><td>
cluster  Relation-like  V8() I -defined   Function-like   total   additive   absolutely-additive   multiplicative   absolutely-multiplicative   properly-upper-bound   properly-lower-bound   for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#RC5'>mssubfam</span></td></tr>
<tr><td>
cluster  absolutely-additive   ->  additive   for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#CC3'>mssubfam</span></td></tr>
<tr><td>
cluster  absolutely-multiplicative   ->  multiplicative   for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#CC4'>mssubfam</span></td></tr>
<tr><td>
cluster  absolutely-multiplicative   ->  properly-upper-bound   for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#CC5'>mssubfam</span></td></tr>
<tr><td>
cluster  properly-upper-bound   -> V8()  for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#CC6'>mssubfam</span></td></tr>
<tr><td>
cluster  absolutely-additive   ->  properly-lower-bound   for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#CC7'>mssubfam</span></td></tr>
<tr><td>
cluster  properly-lower-bound   -> V8()  for    ManySortedSubset of  bool M;
</td><td><span data-href='mssubfam.html#CC8'>mssubfam</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM16622'>
<h2>5.   <span data-link='1652.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='monoid_1.html#K20'>monoid_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">G</font> be   non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="ALGSTR_0:struct.3" data-link="321.html#ELM740">multMagma</span> ;<br><div about="#D50" typeof="oo:Definition" class="main-sentence">
<a name="K20"><span class="kw">func</span> </a> <span title="MONOID_1:func.20" data-link="1652.html#ELM16622">bool</span> <font color="Maroon" title="c1">G</font><span class="kw"> -&gt; </span>   <span title="ALGSTR_0:struct.3" data-link="321.html#ELM740">multMagma</span> <span class="kw"> equals </span>:<span class="lab"><font color="Green" title="E50">Def9</font></span>: <a name="D9"><span class="comment"><font color="firebrick">:: MONOID_1:def 9</font></span><br></a> <span title="ALGSTR_0:aggr.4" data-href="algstr_0.html#G4">multLoopStr</span>(# <span class="p1">(<span class="default"><span title="ZFMISC_1:func.1" data-link="1652.html#ELM30579">bool</span>  the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c1">G</font></span>)</span>,<span class="p1">(<span class="default"> the <span title="ALGSTR_0:sel.2" data-href="algstr_0.html#U2">multF</span> of <font color="Maroon" title="c1">G</font> <span title="MONOID_1:func.19" data-link="5665.html#ELM16621">.:^2</span></span>)</span>,<span class="p1"><span title="DOMAIN_1:func.6" data-link="857.html#ELM5997">{</span><span class="default"><span class="p2">(<span class="default"><span title="BINOP_1:func.3" data-link="1125.html#ELM2755">the_unity_wrt</span>  the <span title="ALGSTR_0:sel.2" data-href="algstr_0.html#U2">multF</span> of <font color="Maroon" title="c1">G</font></span>)</span></span><span title="DOMAIN_1:func.6" data-link="857.html#ELM5997">}</span></span> #)<span class="kw"> if </span><font color="Maroon" title="c1">G</font> is  <span title="GROUP_1:attr.1" data-link="646.html#ELM10993">unital</span> <br><span class="kw"> otherwise </span> <span title="ALGSTR_0:aggr.3" data-href="algstr_0.html#G3">multMagma</span>(# <span class="p1">(<span class="default"><span title="ZFMISC_1:func.1" data-link="1652.html#ELM30579">bool</span>  the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c1">G</font></span>)</span>,<span class="p1">(<span class="default"> the <span title="ALGSTR_0:sel.2" data-href="algstr_0.html#U2">multF</span> of <font color="Maroon" title="c1">G</font> <span title="MONOID_1:func.19" data-link="5665.html#ELM16621">.:^2</span></span>)</span> #);<br>
</div>
<span class="kw">correctness </span><br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  bool G ->  non  empty  ;
</td><td><span data-href='monoid_1.html#FC4'>monoid_1</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM16623'>
<h2>6.   <span data-link='1652.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='monoid_1.html#K21'>monoid_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">G</font> be   non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="GROUP_1:attr.1" data-link="646.html#ELM10993">unital</span>   <span title="ALGSTR_0:struct.3" data-link="321.html#ELM740">multMagma</span> ;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="MONOID_1:func.20" data-link="1652.html#ELM16622">bool</span><br><span class="kw">redefine </span><a name="K21"><span class="kw">func</span> </a> <span title="MONOID_1:func.21" data-link="1652.html#ELM16623">bool</span> <font color="Maroon" title="c1">G</font><span class="kw"> -&gt; </span>  non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="ALGSTR_0:attr.22" data-href="algstr_0.html#V22">strict</span>   <span title="VECTSP_1:attr.4" data-link="5661.html#ELM28516">well-unital</span>   <span title="ALGSTR_0:struct.4" data-link="322.html#ELM741">multLoopStr</span> ;<br><span class="kw">coherence</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM17009'>
<h2>7.   <span data-link='1652.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='mssubfam.html#K1'>mssubfam</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">I</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c2">M</font> be   <span title="PBOOLE:NM.1" data-link="4273.html#ELM19812">ManySortedSet</span> of <font color="Maroon" title="c1">I</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="MBOOLEAN:func.1" data-link="1652.html#ELM14947">bool</span><br><span class="kw">redefine </span><a name="K1"><span class="kw">func</span> </a> <span title="MSSUBFAM:func.1" data-link="1652.html#ELM17009">bool</span> <font color="Maroon" title="c2">M</font><span class="kw"> -&gt; </span>  <span title="MSSUBFAM:NM.1" data-link="5757.html#ELM17008">MSSubsetFamily</span> of <font color="Maroon" title="c2">M</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" onmouseover="rs('pboole/D18')" onmouseout="rh()" data-href="pboole.html#D18">PBOOLE:def 18</span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM17013'>
<h2>8.   <span data-link='1652.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='mssubfam.html#K5'>mssubfam</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">I</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c2">M</font> be   <span title="PBOOLE:NM.1" data-link="4273.html#ELM19812">ManySortedSet</span> of <font color="Maroon" title="c1">I</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="MBOOLEAN:func.1" data-link="1652.html#ELM14947">bool</span><br><span class="kw">redefine </span><a name="K5"><span class="kw">func</span> </a> <span title="MSSUBFAM:func.5" data-link="1652.html#ELM17013">bool</span> <font color="Maroon" title="c2">M</font><span class="kw"> -&gt; </span>  <span title="MSSUBFAM:attr.1" data-link="1792.html#ELM17014">additive</span>   <span title="MSSUBFAM:attr.2" data-link="1793.html#ELM17015">absolutely-additive</span>   <span title="MSSUBFAM:attr.3" data-link="1027.html#ELM17016">multiplicative</span>   <span title="MSSUBFAM:attr.4" data-link="1794.html#ELM17017">absolutely-multiplicative</span>   <span title="MSSUBFAM:attr.5" data-link="1795.html#ELM17018">properly-upper-bound</span>   <span title="MSSUBFAM:attr.6" data-link="1796.html#ELM17019">properly-lower-bound</span>  <span title="MSSUBFAM:NM.1" data-link="5757.html#ELM17008">MSSubsetFamily</span> of <font color="Maroon" title="c2">M</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="lab"><font color="Green" title="E15">Lm1</font></span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  Relation-like  V9() I -defined   Function-like   total  V45()  for    Element of  bool M;
</td><td><span data-href='closure1.html#RC1'>closure1</span></td></tr>
<tr><td>
cluster  Relation-like  I -defined   Function-like   total   Function-yielding  V25()  reflexive   monotonic   idempotent   topological   for    ManySortedFunction of  bool M, bool M;
</td><td><span data-href='closure1.html#RC2'>closure1</span></td></tr>
<tr><td>
cluster  topological   ->  monotonic   for    ManySortedFunction of  bool M, bool M;
</td><td><span data-href='closure1.html#CC1'>closure1</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM25011'>
<h2>9.   <span data-link='1652.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='setfam_1.html#K9'>setfam_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.1" data-link="1652.html#ELM30579">bool</span><br><span class="kw">redefine </span><a name="K9"><span class="kw">func</span> </a> <span title="SETFAM_1:func.9" data-link="1652.html#ELM25011">bool</span> <font color="Maroon" title="c1">X</font><span class="kw"> -&gt; </span>  <span title="SETFAM_1:NM.1" data-link="7849.html#ELM25001">Subset-Family</span> of <font color="Maroon" title="c1">X</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" onmouseover="rs('zfmisc_1/D1')" onmouseout="rh()" data-href="zfmisc_1.html#D1">ZFMISC_1:def 1</span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  non  empty   Relation-like   bool X -defined   bool X -valued   finite   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC4'>armstrng</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool X -defined   bool X -valued   (F2)   (F1)   (F3)   (F4)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC5'>armstrng</span></td></tr>
<tr><td>
cluster  Relation-like   bool X -defined   bool X -valued   full_family   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC6'>armstrng</span></td></tr>
<tr><td>
cluster  Relation-like   bool X -defined   bool X -valued   finite   countable   full_family   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC7'>armstrng</span></td></tr>
<tr><td>
cluster   ->  finite   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC1'>armstrng</span></td></tr>
<tr><td>
cluster  full_family   ->  (F2)   (F1)   (F3)   (F4)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC2'>armstrng</span></td></tr>
<tr><td>
cluster  (F2)   (F1)   (F3)   (F4)   ->  full_family   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC3'>armstrng</span></td></tr>
<tr><td>
cluster  (F1)   (F3)   ->  (DC3)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC4'>armstrng</span></td></tr>
<tr><td>
cluster  (F2)   (DC3)   ->  (F1)   (F3)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC5'>armstrng</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool X -defined   bool X -valued   (F2)   (F4)   (DC3)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC8'>armstrng</span></td></tr>
<tr><td>
cluster  (F1)   ->  non  empty   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC6'>armstrng</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of M -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of M)  pointwise_bounded   for    Element of  bool [:omega,(bool  the carrier of M):];
</td><td><span data-href='compl_sp.html#RC1'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  open   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC4'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  closed   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC5'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  open   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC6'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  closed   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC7'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of M -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of M)  pointwise_bounded   open   for    Element of  bool [:omega,(bool  the carrier of M):];
</td><td><span data-href='compl_sp.html#RC8'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of M -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of M)  pointwise_bounded   closed   for    Element of  bool [:omega,(bool  the carrier of M):];
</td><td><span data-href='compl_sp.html#RC9'>compl_sp</span></td></tr>
<tr><td>
cluster  partition-membered   for    Element of  bool (bool (bool X));
</td><td><span data-href='eqrel_1.html#RC2'>eqrel_1</span></td></tr>
<tr><td>
cluster  non  empty   partition-membered   for    Element of  bool (bool (bool X));
</td><td><span data-href='eqrel_1.html#RC4'>eqrel_1</span></td></tr>
<tr><td>
cluster  In (I,(bool REAL)) ->  non  empty  ;
</td><td><span data-href='finance3.html#FC1'>finance3</span></td></tr>
<tr><td>
cluster (union F) \ X ->  empty   for   set ;
</td><td><span data-href='fomodel0.html#FC75'>fomodel0</span></td></tr>
<tr><td>
cluster (bool X) \ X ->  non  empty   for   set ;
</td><td><span data-href='fomodel0.html#FC85'>fomodel0</span></td></tr>
<tr><td>
cluster  Relation-like   bool (S -sequents) -defined   bool (S -sequents) -valued   Function-like   total   quasi_total   isotone   for    Element of  Funcs ((bool (S -sequents)),(bool (S -sequents)));
</td><td><span data-href='fomodel4.html#RC7'>fomodel4</span></td></tr>
<tr><td>
cluster  functional   isotone   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC8'>fomodel4</span></td></tr>
<tr><td>
cluster  non  empty   functional   isotone   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC12'>fomodel4</span></td></tr>
<tr><td>
cluster 1 -ranked   ->  0  -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#CC17'>fomodel4</span></td></tr>
<tr><td>
cluster 2 -ranked   -> 1 -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#CC18'>fomodel4</span></td></tr>
<tr><td>
cluster  functional  2 -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC13'>fomodel4</span></td></tr>
<tr><td>
cluster  functional  1 -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC14'>fomodel4</span></td></tr>
<tr><td>
cluster  functional   0  -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC15'>fomodel4</span></td></tr>
<tr><td>
cluster  functional   0  -ranked  1 -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC16'>fomodel4</span></td></tr>
<tr><td>
cluster  0  -ranked   ->  non  empty   0  -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#CC19'>fomodel4</span></td></tr>
<tr><td>
cluster  Relation-like   bool (S -sequents) -defined   bool (S -sequents) -valued   Function-like   total   quasi_total   Correct   for    Element of  Funcs ((bool (S -sequents)),(bool (S -sequents)));
</td><td><span data-href='fomodel4.html#RC17'>fomodel4</span></td></tr>
<tr><td>
cluster  functional   isotone   Correct   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC20'>fomodel4</span></td></tr>
<tr><td>
cluster  functional   isotone  2 -ranked   Correct   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC21'>fomodel4</span></td></tr>
<tr><td>
cluster f . n ->  Relation-like  ;
</td><td><span data-href='funct_7.html#FC9'>funct_7</span></td></tr>
<tr><td>
cluster  Function-like  V35( NAT , bool X)  ->  non  empty   for    Element of  bool [:NAT,(bool X):];
</td><td><span data-href='kurato_0.html#CC1'>kurato_0</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   non-empty   NAT  -defined   bool T -valued   Function-like  V31( NAT ) V35( NAT , bool T)  for    Element of  bool [:NAT,(bool T):];
</td><td><span data-href='kurato_0.html#RC1'>kurato_0</span></td></tr>
<tr><td>
cluster  Function-like   constant  V35( NAT , bool T)  -> V52() V53()  convergent   for    Element of  bool [:NAT,(bool T):];
</td><td><span data-href='kurato_0.html#CC2'>kurato_0</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   NAT  -defined   bool T -valued   Function-like   constant  V31( NAT ) V35( NAT , bool T)  for    Element of  bool [:NAT,(bool T):];
</td><td><span data-href='kurato_0.html#RC2'>kurato_0</span></td></tr>
<tr><td>
cluster  ProdMatroid P ->  finite   strict  ;
</td><td><span data-href='matroid0.html#FC8'>matroid0</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   bool X -valued   Function-like   FinSequence-like   disjoint_valued   for    FinSequence of F;
</td><td><span data-href='measure8.html#RC2'>measure8</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined  F -valued   bool X -valued   Function-like  V40( NAT , bool X)  for    Event of ;
</td><td><span data-href='prob_1.html#RC3'>prob_1</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( bool X)  non  empty   Function-like  V25( NAT ) V29( NAT , bool X) V126()  for    Element of  bool [:NAT,(bool X):];
</td><td><span data-href='prob_4.html#RC1'>prob_4</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5(Si) V5( bool X)  non  empty   Function-like  V25( NAT ) V29( NAT , bool X) V126()  for    Element of  bool [:NAT,(bool X):];
</td><td><span data-href='prob_4.html#RC2'>prob_4</span></td></tr>
<tr><td>
cluster  Function-like  V21( bool X, bool X)  \/-preserving   ->  c=-monotone   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='roughs_4.html#CC1'>roughs_4</span></td></tr>
<tr><td>
cluster  Function-like  V21( bool X, bool X)  /\-preserving   ->  c=-monotone   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='roughs_4.html#CC2'>roughs_4</span></td></tr>
<tr><td>
cluster  id (bool X) ->  closure   for  Function of (bool X),(bool X);
</td><td><span data-href='roughs_4.html#FC1'>roughs_4</span></td></tr>
<tr><td>
cluster  id (bool X) ->  interior   for  Function of (bool X),(bool X);
</td><td><span data-href='roughs_4.html#FC2'>roughs_4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool X -defined   bool X -valued   Function-like  V17( bool X) V21( bool X, bool X)  closure   interior   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='roughs_4.html#RC2'>roughs_4</span></td></tr>
<tr><td>
cluster  Function-like  V21( bool X, bool X)  closure   ->  preclosure   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='roughs_4.html#CC3'>roughs_4</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM30579'>
<h2>10.   <span data-link='1652.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='zfmisc_1.html#K1'>zfmisc_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">defpred </span><font color="Maroon">S<sub>1</sub></font>[   <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ] <span class="kw">means </span>$1 <span title="TARSKI:pred.1" data-link="2755.html#ELM26062">c=</span> <font color="Maroon" title="c1">X</font>;<br><div about="#D4" typeof="oo:Definition" class="main-sentence">
<a name="K1"><span class="kw">func</span> </a> <span title="ZFMISC_1:func.1" data-link="1652.html#ELM30579">bool</span> <font color="Maroon" title="c1">X</font><span class="kw"> -&gt; </span>   <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E4">Def1</font></span>: <a name="D1"><span class="comment"><font color="firebrick">:: ZFMISC_1:def 1</font></span><br></a> for <font color="Olive" title="b1">Z</font> being    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span>  holds <br> ( <font color="Olive" title="b1">Z</font> <span title="TARSKI:pred.2" data-link="4139.html#ELM26063">in</span> <span class="kw">it</span> iff <font color="Olive" title="b1">Z</font> <span title="TARSKI:pred.1" data-link="2755.html#ELM26062">c=</span> <font color="Maroon" title="c1">X</font> );<br>
</div>
<span class="kw">existence</span> <span class="kw">uniqueness</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  empty   Function-like   ->  irrelevant   for    Element of  bool [:Vars,(QuasiTerms C):];
</td><td><span data-href='abcmiz_1.html#CC12'>abcmiz_1</span></td></tr>
<tr><td>
cluster  empty   Relation-like   Vars  -defined   QuasiTerms C -valued   Function-like   Function-yielding  V119()  for    Element of  bool [:Vars,(QuasiTerms C):];
</td><td><span data-href='abcmiz_1.html#RC16'>abcmiz_1</span></td></tr>
<tr><td>
cluster  non  empty   finite   covering   for    Element of  bool (bool E);
</td><td><span data-href='abian.html#RC7'>abian</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty  A -defined  B -valued   Function-like  V35(A,B)  for    Element of  bool [:A,B:];
</td><td><span data-href='abian.html#RC8'>abian</span></td></tr>
<tr><td>
cluster  bool X ->  with_non-empty_element  ;
</td><td><span data-href='abian.html#FC19'>abian</span></td></tr>
<tr><td>
cluster  being_line   for   M3(K24( the carrier of AS));
</td><td><span data-href='aff_1.html#RC1'>aff_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of R -valued   Function-like  V18( NAT , the carrier of R)  finite-Support   for    Element of K19(K20(NAT, the carrier of R));
</td><td><span data-href='algseq_1.html#RC1'>algseq_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of M -defined   the carrier of M -valued   total   quasi_total  V65() V70()  compatible   for    Element of  bool [: the carrier of M, the carrier of M:];
</td><td><span data-href='algstr_4.html#RC2'>algstr_4</span></td></tr>
<tr><td>
cluster  stable   for    Element of  bool  the carrier of M;
</td><td><span data-href='algstr_4.html#RC5'>algstr_4</span></td></tr>
<tr><td>
cluster  Function-like   constant  V21( the carrier of M, the carrier of M)  ->  contraction   for    Element of K10(K11( the carrier of M, the carrier of M));
</td><td><span data-href='ali2.html#CC1'>ali2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of M -defined   the carrier of M -valued   Function-like   constant  V17( the carrier of M) V21( the carrier of M, the carrier of M)  for    Element of K10(K11( the carrier of M, the carrier of M));
</td><td><span data-href='ali2.html#RC1'>ali2</span></td></tr>
<tr><td>
cluster  Relation-like  X *  -defined  X -valued   non  empty   Function-like   homogeneous   quasi_total  2 -ary   associative   unital   for    Element of  bool [:(X *),X:];
</td><td><span data-href='aofa_000.html#RC1'>aofa_000</span></td></tr>
<tr><td>
cluster  Relation-like  X *  -defined  X -valued   non  empty   Function-like   homogeneous   quasi_total   0  -ary   for    Element of  bool [:(X *),X:];
</td><td><span data-href='aofa_000.html#RC2'>aofa_000</span></td></tr>
<tr><td>
cluster  Relation-like  X *  -defined  X -valued   non  empty   Function-like   homogeneous   quasi_total  3 -ary   for    Element of  bool [:(X *),X:];
</td><td><span data-href='aofa_000.html#RC3'>aofa_000</span></td></tr>
<tr><td>
cluster  Relation-like  A *  -defined  A -valued   Function-like   non  empty   homogeneous   quasi_total  n -ary   for    Element of  bool [:(A *),A:];
</td><td><span data-href='aofa_a00.html#RC20'>aofa_a00</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   card X -valued   Function-like   one-to-one   quasi_total   onto   for    Element of  bool [:X,(card X):];
</td><td><span data-href='aofa_i00.html#RC1'>aofa_i00</span></td></tr>
<tr><td>
cluster  Relation-like   card X -defined  X -valued   Function-like   one-to-one   quasi_total   onto   for    Element of  bool [:(card X),X:];
</td><td><span data-href='aofa_i00.html#RC2'>aofa_i00</span></td></tr>
<tr><td>
cluster  Relation-like  [:(Union Q),Y:] -defined   Union Q -valued   Function-like   quasi_total   sort-preserving   for    Element of  bool [:[:(Union Q),Y:],(Union Q):];
</td><td><span data-href='aofa_l00.html#RC12'>aofa_l00</span></td></tr>
<tr><td>
cluster  PC-closed   ->  non  empty   for    Element of  bool ( the Sorts of L .  the formula-sort of S);
</td><td><span data-href='aofa_l00.html#CC7'>aofa_l00</span></td></tr>
<tr><td>
cluster  PC-closed   for    Element of  bool ( the Sorts of L .  the formula-sort of S);
</td><td><span data-href='aofa_l00.html#RC36'>aofa_l00</span></td></tr>
<tr><td>
cluster  PC-closed   QC-closed   for    Element of  bool ( the Sorts of L .  the formula-sort of S);
</td><td><span data-href='aofa_l00.html#RC37'>aofa_l00</span></td></tr>
<tr><td>
cluster  PC-closed   QC-closed   with_equality   for    Element of  bool ( the Sorts of L .  the formula-sort of S);
</td><td><span data-href='aofa_l00.html#RC38'>aofa_l00</span></td></tr>
<tr><td>
cluster  non  empty   PC-closed   QC-closed   with_equality  V AL-closed   for    Element of  bool ( the Sorts of L .  the formula-sort of S);
</td><td><span data-href='aofa_l00.html#RC39'>aofa_l00</span></td></tr>
<tr><td>
cluster  (B2)   (B1)   for    Element of  bool (bool X);
</td><td><span data-href='armstrng.html#RC2'>armstrng</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool X -defined   bool X -valued   finite   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC4'>armstrng</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool X -defined   bool X -valued   (F2)   (F1)   (F3)   (F4)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC5'>armstrng</span></td></tr>
<tr><td>
cluster  Relation-like   bool X -defined   bool X -valued   full_family   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC6'>armstrng</span></td></tr>
<tr><td>
cluster  Relation-like   bool X -defined   bool X -valued   finite   countable   full_family   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC7'>armstrng</span></td></tr>
<tr><td>
cluster   ->  finite   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC1'>armstrng</span></td></tr>
<tr><td>
cluster  full_family   ->  (F2)   (F1)   (F3)   (F4)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC2'>armstrng</span></td></tr>
<tr><td>
cluster  (F2)   (F1)   (F3)   (F4)   ->  full_family   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC3'>armstrng</span></td></tr>
<tr><td>
cluster  (F1)   (F3)   ->  (DC3)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC4'>armstrng</span></td></tr>
<tr><td>
cluster  (F2)   (DC3)   ->  (F1)   (F3)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC5'>armstrng</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool X -defined   bool X -valued   (F2)   (F4)   (DC3)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC8'>armstrng</span></td></tr>
<tr><td>
cluster  (F1)   ->  non  empty   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC6'>armstrng</span></td></tr>
<tr><td>
cluster  Relation-like  A -defined  A -valued  V17(A)  reflexive   antisymmetric   connected   transitive   for    Element of  bool [:A,A:];
</td><td><span data-href='arrow.html#RC1'>arrow</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( REAL )  non  empty   Function-like  V28( NAT )  quasi_total  V39() V40() V41()  eventually-nonnegative   positive   eventually-positive   eventually-nonzero   eventually-nondecreasing   for    Element of K16(K17(NAT,REAL));
</td><td><span data-href='asympt_0.html#RC7'>asympt_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   positive   ->  eventually-positive   for    Element of K16(K17(NAT,REAL));
</td><td><span data-href='asympt_0.html#CC1'>asympt_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   eventually-positive   ->  eventually-nonnegative   eventually-nonzero   for    Element of K16(K17(NAT,REAL));
</td><td><span data-href='asympt_0.html#CC2'>asympt_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   eventually-nonnegative   eventually-nonzero   ->  eventually-positive   for    Element of K16(K17(NAT,REAL));
</td><td><span data-href='asympt_0.html#CC3'>asympt_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   polynomially-bounded   ->  polynomially-abs-bounded   for    Element of  bool [:omega,REAL:];
</td><td><span data-href='asympt_3.html#CC1'>asympt_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   non  empty   Function-like  V28( NAT )  quasi_total  V39() V40() V41()  polynomially-abs-bounded   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='asympt_3.html#RC3'>asympt_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   non  empty   Function-like  V28( NAT )  quasi_total  V39() V40() V41()  negligible   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='asympt_3.html#RC4'>asympt_3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   negligible   ->  polynomially-abs-bounded   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='asympt_3.html#CC2'>asympt_3</span></td></tr>
<tr><td>
cluster  Function-like  V28(I,J)  ->  total   for    Element of  bool [:I,J:];
</td><td><span data-href='bagord_2.html#CC1'>bagord_2</span></td></tr>
<tr><td>
cluster  Relation-like  I -defined  I -valued   asymmetric   transitive   for    Element of  bool [:I,I:];
</td><td><span data-href='bagord_2.html#RC2'>bagord_2</span></td></tr>
<tr><td>
cluster  Relation-like   Bags n -defined   Bags n -valued   total  V18( Bags n, Bags n)  reflexive   antisymmetric   transitive   admissible   for    Element of  bool [:(Bags n),(Bags n):];
</td><td><span data-href='bagorder.html#RC1'>bagorder</span></td></tr>
<tr><td>
cluster V4() V7( NAT ) V8( the carrier of F_Complex)  Function-like  V32( NAT , the carrier of F_Complex)  complex-valued   finite-Support   imaginary   for    Element of K21(K22(NAT, the carrier of F_Complex));
</td><td><span data-href='basel_2.html#RC2'>basel_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of X -defined   the carrier of X9 -valued   Function-like   non  empty  V14( the carrier of X)  quasi_total   multiplicative   for    Element of  bool [: the carrier of X, the carrier of X9:];
</td><td><span data-href='bcialg_6.html#RC1'>bcialg_6</span></td></tr>
<tr><td>
cluster V12()  constant  V32( NAT , the carrier of X)  ->  convergent   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='bhsp_2.html#CC1'>bhsp_2</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the U1 of X) V6()  constant  V11() V14( NAT ) V18( NAT , the U1 of X)  for    Element of K19(K20(NAT, the U1 of X));
</td><td><span data-href='bhsp_3.html#RC1'>bhsp_3</span></td></tr>
<tr><td>
cluster V6()  constant  V18( NAT , the U1 of X)  ->  Cauchy   for    Element of K19(K20(NAT, the U1 of X));
</td><td><span data-href='bhsp_3.html#CC1'>bhsp_3</span></td></tr>
<tr><td>
cluster V6() V18( NAT , the U1 of X)  convergent   ->  Cauchy   for    Element of K19(K20(NAT, the U1 of X));
</td><td><span data-href='bhsp_3.html#CC2'>bhsp_3</span></td></tr>
<tr><td>
cluster V6()  constant  V18( NAT , the U1 of X)  ->  bounded   for    Element of K19(K20(NAT, the U1 of X));
</td><td><span data-href='bhsp_3.html#CC3'>bhsp_3</span></td></tr>
<tr><td>
cluster V6() V18( NAT , the U1 of X)  convergent   ->  bounded   for    Element of K19(K20(NAT, the U1 of X));
</td><td><span data-href='bhsp_3.html#CC4'>bhsp_3</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of W:]) V21([: the carrier of V, the carrier of W:], the carrier of K)  additiveFAF   additiveSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC1'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of W:]) V21([: the carrier of V, the carrier of W:], the carrier of K)  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC2'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of K -valued   Function-like   non  constant  V20([: the carrier of V, the carrier of W:]) V21([: the carrier of V, the carrier of W:], the carrier of K)  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC3'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of V:]) V21([: the carrier of V, the carrier of V:], the carrier of K)  symmetric   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC4'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of V:]) V21([: the carrier of V, the carrier of V:], the carrier of K)  alternating   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC5'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of V:]) V21([: the carrier of V, the carrier of V:], the carrier of K)  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   symmetric   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC6'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of V:]) V21([: the carrier of V, the carrier of V:], the carrier of K)  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   alternating   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC7'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of K -valued   Function-like   non  constant  V20([: the carrier of V, the carrier of V:]) V21([: the carrier of V, the carrier of V:], the carrier of K)  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   symmetric   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC8'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of V:]) V21([: the carrier of V, the carrier of V:], the carrier of K)  additiveFAF   additiveSAF   alternating   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC9'>bilinear</span></td></tr>
<tr><td>
cluster  Function-like  V18([:{},{}:], {} )  ->  empty   commutative   associative   for    Element of  bool [:[:{},{}:],{}:];
</td><td><span data-href='binop_1.html#CC1'>binop_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of T -defined   the carrier of T -valued   Function-like   one-to-one  V17( the carrier of T) V21( the carrier of T, the carrier of T)  continuous   for    Element of  bool [: the carrier of T, the carrier of T:];
</td><td><span data-href='borsuk_2.html#RC1'>borsuk_2</span></td></tr>
<tr><td>
cluster  non  empty   connected   compact   for    Element of  bool  the carrier of T;
</td><td><span data-href='borsuk_2.html#RC5'>borsuk_2</span></td></tr>
<tr><td>
cluster  empty   for    Element of  bool  the carrier of T;
</td><td><span data-href='borsuk_3.html#RC1'>borsuk_3</span></td></tr>
<tr><td>
cluster  being_simple_closed_curve   ->  non  trivial   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='borsuk_4.html#CC1'>borsuk_4</span></td></tr>
<tr><td>
cluster  non  empty   open   closed   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='borsuk_5.html#RC4'>borsuk_5</span></td></tr>
<tr><td>
cluster  empty   compact   for    Element of  bool  the carrier of T;
</td><td><span data-href='borsuk_6.html#RC3'>borsuk_6</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  without_antipodals   for    Element of  bool [: the carrier of (Tcircle (p,r)), the carrier of (TOP-REAL n):];
</td><td><span data-href='borsuk_7.html#CC2'>borsuk_7</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   continuous   ->  with_antipodals   for    Element of  bool [: the carrier of (Tcircle (p,r)), the carrier of (TOP-REAL 2):];
</td><td><span data-href='borsuk_7.html#CC3'>borsuk_7</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  FinSequence-yielding   for    Element of K10(K11(X, the carrier of (TOP-REAL n)));
</td><td><span data-href='brouwer3.html#CC1'>brouwer3</span></td></tr>
<tr><td>
cluster  additively-closed   ->  add-closed   having-inverse   for    Element of  bool  the carrier of V;
</td><td><span data-href='c0sp1.html#CC1'>c0sp1</span></td></tr>
<tr><td>
cluster  add-closed   having-inverse   ->  additively-closed   for    Element of  bool  the carrier of V;
</td><td><span data-href='c0sp1.html#CC2'>c0sp1</span></td></tr>
<tr><td>
cluster  non  empty   add-closed   having-inverse   for    Element of  bool  the carrier of V;
</td><td><span data-href='c0sp1.html#RC1'>c0sp1</span></td></tr>
<tr><td>
cluster  additively-linearly-closed   ->  additively-closed   for    Element of  bool  the carrier of V;
</td><td><span data-href='c0sp1.html#CC3'>c0sp1</span></td></tr>
<tr><td>
cluster  open   quasi_basis   for    Element of  bool (bool  the carrier of X);
</td><td><span data-href='cantor_1.html#RC1'>cantor_1</span></td></tr>
<tr><td>
cluster  open   quasi_basis   ->  quasi_prebasis   for    Element of  bool (bool  the carrier of X);
</td><td><span data-href='cantor_1.html#CC1'>cantor_1</span></td></tr>
<tr><td>
cluster  open   quasi_prebasis   for    Element of  bool (bool  the carrier of X);
</td><td><span data-href='cantor_1.html#RC2'>cantor_1</span></td></tr>
<tr><td>
cluster  bool A ->  infinite  ;
</td><td><span data-href='card_1.html#FC12'>card_1</span></td></tr>
<tr><td>
cluster  infinite   for    Element of  bool X;
</td><td><span data-href='card_1.html#RC6'>card_1</span></td></tr>
<tr><td>
cluster 1 -element   for    Element of  bool X;
</td><td><span data-href='card_1.html#RC9'>card_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  non-empty   for    Element of  bool [:A,B:];
</td><td><span data-href='card_3.html#CC2'>card_3</span></td></tr>
<tr><td>
cluster   ->  countable   for    Element of  bool X;
</td><td><span data-href='card_3.html#CC7'>card_3</span></td></tr>
<tr><td>
cluster   ->  with_common_domain   for    Element of  bool X;
</td><td><span data-href='card_3.html#CC8'>card_3</span></td></tr>
<tr><td>
cluster  non  empty   cap-closed   for    Element of  bool (bool X);
</td><td><span data-href='cardfil2.html#RC1'>cardfil2</span></td></tr>
<tr><td>
cluster  non  empty   cap-closed   upper   for    Element of  bool (bool X);
</td><td><span data-href='cardfil2.html#RC2'>cardfil2</span></td></tr>
<tr><td>
cluster  non  empty   with_non-empty_elements   cap-closed   upper   for    Element of  bool (bool X);
</td><td><span data-href='cardfil2.html#RC3'>cardfil2</span></td></tr>
<tr><td>
cluster  non  empty   filter_basis   for    Element of  bool F;
</td><td><span data-href='cardfil2.html#RC5'>cardfil2</span></td></tr>
<tr><td>
cluster  non  empty   quasi_basis   for    Element of  bool (bool X);
</td><td><span data-href='cardfil2.html#RC6'>cardfil2</span></td></tr>
<tr><td>
cluster  non  empty   with_non-empty_elements   quasi_basis   for    Element of  bool (bool X);
</td><td><span data-href='cardfil2.html#RC7'>cardfil2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of C -defined   the carrier of D -valued   Function-like  V28( the carrier of C, the carrier of D)  identity-preserving   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC14'>cat_6</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   empty-yielding   the carrier of C -defined   the carrier of D -valued   empty   trivial   non  proper  V9() V10() V11() V13() V14() V15() V16() V17() V18()  Function-like   one-to-one   constant   functional   total  V28( the carrier of C, the carrier of D) V31() V35() V36() V39()  cardinal   0  -element  V43() V44() V45() V98() V99() V100() V101() V102() V105() V106() V107() V108() V109() V110() V111() V112()  identity-preserving   multiplicative   antimultiplicative   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC15'>cat_6</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of C -defined   the carrier of D -valued   Function-like   total  V28( the carrier of C, the carrier of D)  identity-preserving   multiplicative   antimultiplicative   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC16'>cat_6</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   empty-yielding   the carrier of C -defined   the carrier of D -valued   empty   trivial   non  proper  V9() V10() V11() V13() V14() V15() V16() V17() V18()  Function-like   one-to-one   constant   functional   total  V28( the carrier of C, the carrier of D) V31() V35() V36() V39()  cardinal   0  -element  V43() V44() V45() V98() V99() V100() V101() V102() V105() V106() V107() V108() V109() V110() V111() V112()  covariant   contravariant   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC17'>cat_6</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of C -defined   the carrier of D -valued   Function-like   total  V28( the carrier of C, the carrier of D)  covariant   contravariant   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC18'>cat_6</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  covariant   for    Element of  bool [: the carrier of C1, the carrier of C2:];
</td><td><span data-href='cat_8.html#CC1'>cat_8</span></td></tr>
<tr><td>
cluster  Relation-like  [:D,D:] -defined  D -valued   Function-like  V14([:D,D:]) V18([:D,D:],D)  commutative   associative   for    Element of  bool [:[:D,D:],D:];
</td><td><span data-href='cayldick.html#RC2'>cayldick</span></td></tr>
<tr><td>
cluster  non  empty   multiplicatively-closed   Cadditively-linearly-closed   for    Element of  bool  the carrier of V;
</td><td><span data-href='cc0sp1.html#RC2'>cc0sp1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of X -defined   COMPLEX  -valued   non  empty   Function-like   total   quasi_total  V172()  continuous   for    Element of  bool [: the carrier of X,COMPLEX:];
</td><td><span data-href='cc0sp2.html#RC1'>cc0sp2</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( COMPLEX )  Function-like  V11()  total   non-zero   quasi_total   complex-valued   0  -convergent   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='cfdiff_1.html#RC1'>cfdiff_1</span></td></tr>
<tr><td>
cluster  Function-like   non-zero   quasi_total   0  -convergent   ->  convergent   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='cfdiff_1.html#CC1'>cfdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( COMPLEX )  Function-like   constant  V11()  total   quasi_total   complex-valued   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='cfdiff_1.html#RC2'>cfdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( COMPLEX ) V5( COMPLEX )  Function-like   total   complex-valued   RestFunc-like   for    Element of K19(K20(COMPLEX,COMPLEX));
</td><td><span data-href='cfdiff_1.html#RC3'>cfdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( COMPLEX ) V5( COMPLEX )  Function-like   total   complex-valued   linear   for    Element of K19(K20(COMPLEX,COMPLEX));
</td><td><span data-href='cfdiff_1.html#RC4'>cfdiff_1</span></td></tr>
<tr><td>
cluster V52()  open   for    Element of K19(COMPLEX);
</td><td><span data-href='cfdiff_1.html#RC5'>cfdiff_1</span></td></tr>
<tr><td>
cluster  non  trivial   finite   for    Element of  bool X;
</td><td><span data-href='chain_1.html#RC2'>chain_1</span></td></tr>
<tr><td>
cluster   ->  without_pairs   for    Element of  bool X;
</td><td><span data-href='circcmb3.html#CC8'>circcmb3</span></td></tr>
<tr><td>
cluster  non  empty   functional   FinSequence-membered   open   for    Element of K16((REAL m));
</td><td><span data-href='ckspace1.html#RC1'>ckspace1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of X -defined   the carrier of Y -valued   Function-like   total   quasi_total   additive   homogeneous   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='clopban1.html#RC1'>clopban1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of X -defined   the carrier of Y -valued   Function-like   total   quasi_total   additive   homogeneous   Lipschitzian   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='clopban1.html#RC2'>clopban1</span></td></tr>
<tr><td>
cluster V4()  Relation-like   NAT  -defined   the carrier of X -valued   Function-like  V32( NAT ) V33( NAT , the carrier of X)  summable   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='clopban3.html#RC1'>clopban3</span></td></tr>
<tr><td>
cluster V4()  Relation-like   NAT  -defined   the carrier of X -valued   Function-like  V32( NAT ) V33( NAT , the carrier of X)  norm_summable   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='clopban3.html#RC2'>clopban3</span></td></tr>
<tr><td>
cluster  Function-like  V33( NAT , the carrier of X)  summable   ->  convergent   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='clopban3.html#CC1'>clopban3</span></td></tr>
<tr><td>
cluster  Function-like  V33( NAT , the carrier of X)  norm_summable   ->  summable   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='clopban3.html#CC2'>clopban3</span></td></tr>
<tr><td>
cluster  non  empty   functional   with_common_domain   for    Element of  bool (Bool M);
</td><td><span data-href='closure2.html#RC1'>closure2</span></td></tr>
<tr><td>
cluster  empty   functional   finite   for    Element of  bool (Bool M);
</td><td><span data-href='closure2.html#RC2'>closure2</span></td></tr>
<tr><td>
cluster  non  empty   functional   with_common_domain   additive   absolutely-additive   multiplicative   absolutely-multiplicative   properly-upper-bound   properly-lower-bound   for    Element of  bool (Bool M);
</td><td><span data-href='closure2.html#RC3'>closure2</span></td></tr>
<tr><td>
cluster  absolutely-additive   ->  additive   for    Element of  bool (Bool M);
</td><td><span data-href='closure2.html#CC1'>closure2</span></td></tr>
<tr><td>
cluster  absolutely-multiplicative   ->  multiplicative   for    Element of  bool (Bool M);
</td><td><span data-href='closure2.html#CC2'>closure2</span></td></tr>
<tr><td>
cluster  absolutely-multiplicative   ->  properly-upper-bound   for    Element of  bool (Bool M);
</td><td><span data-href='closure2.html#CC3'>closure2</span></td></tr>
<tr><td>
cluster  properly-upper-bound   ->  non  empty   for    Element of  bool (Bool M);
</td><td><span data-href='closure2.html#CC4'>closure2</span></td></tr>
<tr><td>
cluster  absolutely-additive   ->  properly-lower-bound   for    Element of  bool (Bool M);
</td><td><span data-href='closure2.html#CC5'>closure2</span></td></tr>
<tr><td>
cluster  properly-lower-bound   ->  non  empty   for    Element of  bool (Bool M);
</td><td><span data-href='closure2.html#CC6'>closure2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   Function-like  V17( Bool M)  quasi_total   reflexive   monotonic   idempotent   topological   for    Element of  bool [:(Bool M),(Bool M):];
</td><td><span data-href='closure2.html#RC4'>closure2</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   topological   ->  monotonic   for    Element of  bool [:(Bool M),(Bool M):];
</td><td><span data-href='closure2.html#CC7'>closure2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   Bool M -defined   Bool M -valued   Function-like  V17( Bool M)  quasi_total   reflexive   monotonic   idempotent   algebraic   for    Element of  bool [:(Bool M),(Bool M):];
</td><td><span data-href='closure3.html#RC1'>closure3</span></td></tr>
<tr><td>
cluster  bool X ->  subset-closed   binary_complete  ;
</td><td><span data-href='cohsp_1.html#FC2'>cohsp_1</span></td></tr>
<tr><td>
cluster  finite   c=directed   c=filtered   for    Element of  bool C;
</td><td><span data-href='cohsp_1.html#RC4'>cohsp_1</span></td></tr>
<tr><td>
cluster  non  empty   preBoolean   for    Element of  bool C;
</td><td><span data-href='cohsp_1.html#RC5'>cohsp_1</span></td></tr>
<tr><td>
cluster  Relation-like  C1 -defined  C2 -valued   Function-like  V36(C1,C2)  union-distributive   cap-distributive   for    Element of  bool [:C1,C2:];
</td><td><span data-href='cohsp_1.html#RC7'>cohsp_1</span></td></tr>
<tr><td>
cluster  Relation-like  B -defined  C -valued   Function-like  V36(B,C)  U-linear   for    Element of  bool [:B,C:];
</td><td><span data-href='cohsp_1.html#RC11'>cohsp_1</span></td></tr>
<tr><td>
cluster  empty   ->  relatively-compact   for    Element of K19( the carrier of X);
</td><td><span data-href='compact1.html#CC1'>compact1</span></td></tr>
<tr><td>
cluster  relatively-compact   for    Element of K19( the carrier of T);
</td><td><span data-href='compact1.html#RC1'>compact1</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of X, the carrier of Y)  compactification   ->  embedding   for    Element of K19(K20( the carrier of X, the carrier of Y));
</td><td><span data-href='compact1.html#CC10'>compact1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of M -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of M)  pointwise_bounded   for    Element of  bool [:omega,(bool  the carrier of M):];
</td><td><span data-href='compl_sp.html#RC1'>compl_sp</span></td></tr>
<tr><td>
cluster  empty   ->  open   for    Element of  bool  the carrier of M;
</td><td><span data-href='compl_sp.html#CC1'>compl_sp</span></td></tr>
<tr><td>
cluster  empty   ->  closed   for    Element of  bool  the carrier of M;
</td><td><span data-href='compl_sp.html#CC2'>compl_sp</span></td></tr>
<tr><td>
cluster  non  empty   open   for    Element of  bool  the carrier of M;
</td><td><span data-href='compl_sp.html#RC2'>compl_sp</span></td></tr>
<tr><td>
cluster  non  empty   closed   for    Element of  bool  the carrier of M;
</td><td><span data-href='compl_sp.html#RC3'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  open   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC4'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  closed   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC5'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  open   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC6'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  closed   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC7'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of M -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of M)  pointwise_bounded   open   for    Element of  bool [:omega,(bool  the carrier of M):];
</td><td><span data-href='compl_sp.html#RC8'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of M -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of M)  pointwise_bounded   closed   for    Element of  bool [:omega,(bool  the carrier of M):];
</td><td><span data-href='compl_sp.html#RC9'>compl_sp</span></td></tr>
<tr><td>
cluster  empty   ->  compact   for    Element of  bool  the carrier of T;
</td><td><span data-href='compts_1.html#CC1'>compts_1</span></td></tr>
<tr><td>
cluster  compact   ->  closed   for    Element of  bool  the carrier of T;
</td><td><span data-href='compts_1.html#CC2'>compts_1</span></td></tr>
<tr><td>
cluster  finite   ->  compact   for    Element of  bool  the carrier of T;
</td><td><span data-href='compts_1.html#CC4'>compts_1</span></td></tr>
<tr><td>
cluster  non  empty   compact   for    Element of  bool  the carrier of T;
</td><td><span data-href='compts_1.html#RC3'>compts_1</span></td></tr>
<tr><td>
cluster  non  empty   open   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='compts_1.html#RC4'>compts_1</span></td></tr>
<tr><td>
cluster  Relation-like  X *  -defined  Y -valued   Function-like   homogeneous   for    Element of K32(K33((X *),Y));
</td><td><span data-href='comput_1.html#RC5'>comput_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  X *  -defined  Y -valued   Function-like   homogeneous   for    Element of K32(K33((X *),Y));
</td><td><span data-href='comput_1.html#RC6'>comput_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  X *  -defined  X -valued   Function-like   homogeneous   quasi_total   for    Element of K32(K33((X *),X));
</td><td><span data-href='comput_1.html#RC7'>comput_1</span></td></tr>
<tr><td>
cluster  Function-like   -> NAT *  -defined   to-naturals   for    Element of K32(K33((NAT *),NAT));
</td><td><span data-href='comput_1.html#CC3'>comput_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  len-total   for    Element of K32(K33((NAT *),NAT));
</td><td><span data-href='comput_1.html#CC4'>comput_1</span></td></tr>
<tr><td>
cluster  non  empty   functional   primitive-recursively_closed   for    Element of K32((HFuncs NAT));
</td><td><span data-href='comput_1.html#RC12'>comput_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   COMPLEX  -valued   Function-like   non  empty  V14( NAT ) V18( NAT , COMPLEX )  non-zero  V44()  for    Element of  bool [:NAT,COMPLEX:];
</td><td><span data-href='comseq_1.html#RC1'>comseq_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   COMPLEX  -valued   Function-like   non  empty   total  V18( NAT , COMPLEX )  complex-valued   bounded   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='comseq_2.html#RC1'>comseq_2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   COMPLEX  -valued   Function-like   non  empty   total  V18( NAT , COMPLEX )  complex-valued   convergent   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='comseq_2.html#RC2'>comseq_2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , COMPLEX )  convergent   ->  bounded   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='comseq_2.html#CC1'>comseq_2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , COMPLEX )  non  bounded   ->  non  convergent   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='comseq_2.html#CC2'>comseq_2</span></td></tr>
<tr><td>
cluster  Function-like  V19( NAT , REAL )  summable   ->  convergent   for    Element of K20(K21(NAT,REAL));
</td><td><span data-href='comseq_3.html#CC1'>comseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V19( NAT , REAL )  absolutely_summable   ->  summable   for    Element of K20(K21(NAT,REAL));
</td><td><span data-href='comseq_3.html#CC2'>comseq_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like  V12()  total  V19( NAT , REAL )  complex-valued   ext-real-valued   real-valued   absolutely_summable   for    Element of K20(K21(NAT,REAL));
</td><td><span data-href='comseq_3.html#RC1'>comseq_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   COMPLEX  -valued   Function-like  V12()  total  V19( NAT , COMPLEX )  complex-valued   summable   for    Element of K20(K21(NAT,COMPLEX));
</td><td><span data-href='comseq_3.html#RC2'>comseq_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   COMPLEX  -valued   Function-like  V12()  total  V19( NAT , COMPLEX )  complex-valued   absolutely_summable   for    Element of K20(K21(NAT,COMPLEX));
</td><td><span data-href='comseq_3.html#RC3'>comseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V19( NAT , COMPLEX )  summable   ->  convergent   for    Element of K20(K21(NAT,COMPLEX));
</td><td><span data-href='comseq_3.html#CC3'>comseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V19( NAT , COMPLEX )  absolutely_summable   ->  summable   for    Element of K20(K21(NAT,COMPLEX));
</td><td><span data-href='comseq_3.html#CC4'>comseq_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   COMPLEX  -valued   Function-like  V12()  total  V19( NAT , COMPLEX )  complex-valued   absolutely_summable   for    Element of K20(K21(NAT,COMPLEX));
</td><td><span data-href='comseq_3.html#RC4'>comseq_3</span></td></tr>
<tr><td>
cluster  non  empty   for    Element of  bool  the carrier of C;
</td><td><span data-href='conlat_1.html#RC4'>conlat_1</span></td></tr>
<tr><td>
cluster  non  empty   for    Element of  bool  the carrier' of C;
</td><td><span data-href='conlat_1.html#RC5'>conlat_1</span></td></tr>
<tr><td>
cluster  a_component   ->  connected   for    Element of K10( the carrier of GX);
</td><td><span data-href='connsp_1.html#CC1'>connsp_1</span></td></tr>
<tr><td>
cluster  a_component   ->  non  empty   for    Element of K10( the carrier of GX);
</td><td><span data-href='connsp_1.html#CC2'>connsp_1</span></td></tr>
<tr><td>
cluster  a_component   ->  closed   for    Element of K10( the carrier of GX);
</td><td><span data-href='connsp_1.html#CC3'>connsp_1</span></td></tr>
<tr><td>
cluster  empty   for    Element of K10( the carrier of T);
</td><td><span data-href='connsp_1.html#RC1'>connsp_1</span></td></tr>
<tr><td>
cluster  empty   ->  connected   for    Element of K10( the carrier of T);
</td><td><span data-href='connsp_1.html#CC4'>connsp_1</span></td></tr>
<tr><td>
cluster  non  empty   convex   for    Element of K10( the carrier of V);
</td><td><span data-href='convex1.html#RC1'>convex1</span></td></tr>
<tr><td>
cluster  empty   convex   for    Element of K10( the carrier of V);
</td><td><span data-href='convex1.html#RC2'>convex1</span></td></tr>
<tr><td>
cluster  cone   for    Element of K32( the carrier of V);
</td><td><span data-href='convex3.html#RC1'>convex3</span></td></tr>
<tr><td>
cluster  empty   cone   for    Element of K32( the carrier of V);
</td><td><span data-href='convex3.html#RC2'>convex3</span></td></tr>
<tr><td>
cluster  non  empty   cone   for    Element of K32( the carrier of V);
</td><td><span data-href='convex3.html#RC3'>convex3</span></td></tr>
<tr><td>
cluster  empty   ->  Affine   for    Element of  bool  the carrier of V;
</td><td><span data-href='convex4.html#CC1'>convex4</span></td></tr>
<tr><td>
cluster  non  empty   Affine   for    Element of  bool  the carrier of V;
</td><td><span data-href='convex4.html#RC1'>convex4</span></td></tr>
<tr><td>
cluster  empty   Affine   for    Element of  bool  the carrier of V;
</td><td><span data-href='convex4.html#RC2'>convex4</span></td></tr>
<tr><td>
cluster  non  empty   convex   for    Element of  bool  the carrier of V;
</td><td><span data-href='convex4.html#RC3'>convex4</span></td></tr>
<tr><td>
cluster  empty   convex   for    Element of  bool  the carrier of V;
</td><td><span data-href='convex4.html#RC4'>convex4</span></td></tr>
<tr><td>
cluster V1() V4(I) V5( REAL )  Function-like   non  empty   total  V55(I, REAL )  complex-valued   ext-real-valued   real-valued   HK-integrable   for    Element of  bool [:I,REAL:];
</td><td><span data-href='cousin2.html#RC1'>cousin2</span></td></tr>
<tr><td>
cluster V1() V4(I) V5( REAL )  Function-like   non  empty   total  V55(I, REAL )  complex-valued   ext-real-valued   real-valued   integrable   for    Element of  bool [:I,REAL:];
</td><td><span data-href='cousin2.html#RC2'>cousin2</span></td></tr>
<tr><td>
cluster V1() V4(X) V5( REAL )  Function-like   non  empty   total  V55(X, REAL )  complex-valued   ext-real-valued   real-valued   bounded   for    Element of  bool [:X,REAL:];
</td><td><span data-href='cousin2.html#RC3'>cousin2</span></td></tr>
<tr><td>
cluster V1() V4(I) V5( REAL )  Function-like   non  empty   total  V55(I, REAL )  complex-valued   ext-real-valued   real-valued   bounded   integrable   for    Element of  bool [:I,REAL:];
</td><td><span data-href='cousin2.html#RC4'>cousin2</span></td></tr>
<tr><td>
cluster  Function-like  V55(I, REAL )  bounded   integrable   ->  HK-integrable   for    Element of  bool [:I,REAL:];
</td><td><span data-href='cousin2.html#CC1'>cousin2</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   the carrier of Y -valued   non  empty   Function-like  V26(X)  quasi_total   bounded   for    Element of  bool [:X, the carrier of Y:];
</td><td><span data-href='csspace4.html#RC1'>csspace4</span></td></tr>
<tr><td>
cluster  Function-like  V32([:NAT,NAT:], REAL )  P-convergent   non-decreasing   ->  bounded_above   bounded_below   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#CC1'>dblseq_1</span></td></tr>
<tr><td>
cluster  Function-like  V32([:NAT,NAT:], REAL )  P-convergent   non-increasing   ->  bounded_above   bounded_below   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#CC2'>dblseq_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [:NAT,NAT:] -defined   REAL  -valued   Function-like  V28([:NAT,NAT:]) V32([:NAT,NAT:], REAL ) V109() V110() V111()  P-convergent   convergent_in_cod1   convergent_in_cod2   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#RC1'>dblseq_1</span></td></tr>
<tr><td>
cluster  Function-like  V32([:NAT,NAT:], REAL )  bounded_above   non-decreasing   ->  P-convergent   convergent_in_cod1   convergent_in_cod2   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#CC3'>dblseq_1</span></td></tr>
<tr><td>
cluster  Function-like  V32([:NAT,NAT:], REAL )  bounded_below   non-increasing   ->  P-convergent   convergent_in_cod1   convergent_in_cod2   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#CC4'>dblseq_1</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10(X) V11( REAL )  Function-like   total  V32(X, REAL )  complex-valued   ext-real-valued   real-valued   nonnegative   nonpositive   for    Element of  bool [:X,REAL:];
</td><td><span data-href='dblseq_3.html#RC1'>dblseq_3</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10(X) V11( ExtREAL )  Function-like   total  V32(X, ExtREAL )  ext-real-valued   nonnegative   nonpositive  V183() V184()  for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='dblseq_3.html#RC2'>dblseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V32(X, ExtREAL )  nonnegative   -> V183()  for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='dblseq_3.html#CC1'>dblseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V32(X, ExtREAL )  nonpositive   -> V184()  for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='dblseq_3.html#CC2'>dblseq_3</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10(X) V11( ExtREAL )  Function-like   total  V32(X, ExtREAL )  ext-real-valued  V183() V184()  for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='dblseq_3.html#RC3'>dblseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V32( omega , ExtREAL )  convergent_to_+infty   ->  convergent   for    Element of  bool [:omega,ExtREAL:];
</td><td><span data-href='dblseq_3.html#CC3'>dblseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V32( omega , ExtREAL )  convergent_to_-infty   ->  convergent   for    Element of  bool [:omega,ExtREAL:];
</td><td><span data-href='dblseq_3.html#CC4'>dblseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V32( omega , ExtREAL )  convergent_to_finite_number   ->  convergent   for    Element of  bool [:omega,ExtREAL:];
</td><td><span data-href='dblseq_3.html#CC5'>dblseq_3</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( omega ) V11( ExtREAL )  Function-like   total  V32( omega , ExtREAL )  ext-real-valued   convergent   for    Element of  bool [:omega,ExtREAL:];
</td><td><span data-href='dblseq_3.html#RC4'>dblseq_3</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( omega ) V11( ExtREAL )  Function-like   total  V32( omega , ExtREAL )  ext-real-valued  V183()  convergent   for    Element of  bool [:omega,ExtREAL:];
</td><td><span data-href='dblseq_3.html#RC5'>dblseq_3</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( omega ) V11( ExtREAL )  Function-like   total  V32( omega , ExtREAL )  ext-real-valued  V184()  convergent   for    Element of  bool [:omega,ExtREAL:];
</td><td><span data-href='dblseq_3.html#RC6'>dblseq_3</span></td></tr>
<tr><td>
cluster V1() V4( Segm n) V5( Seg n)  Function-like   non  empty   total   quasi_total  V49() V50() V51() V52()  NtoSEG   for    Element of  bool [:(Segm n),(Seg n):];
</td><td><span data-href='descip_1.html#RC1'>descip_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   NtoSEG   ->  bijective   NtoSEG   for    Element of  bool [:(Segm n),(Seg n):];
</td><td><span data-href='descip_1.html#CC2'>descip_1</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( PFuncs (REAL,REAL))  non  empty   Function-like   total   quasi_total   Sequence-yielding   for    Element of  bool [:NAT,(PFuncs (REAL,REAL)):];
</td><td><span data-href='diff_1.html#RC1'>diff_1</span></td></tr>
<tr><td>
cluster  trivial   ->  clique   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#CC1'>dilworth</span></td></tr>
<tr><td>
cluster  clique   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#RC1'>dilworth</span></td></tr>
<tr><td>
cluster  finite   connected   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#RC2'>dilworth</span></td></tr>
<tr><td>
cluster  connected   ->  strongly_connected   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#CC2'>dilworth</span></td></tr>
<tr><td>
cluster  non  empty   finite   connected   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#RC3'>dilworth</span></td></tr>
<tr><td>
cluster  trivial   ->  stable   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#CC3'>dilworth</span></td></tr>
<tr><td>
cluster  stable   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#RC4'>dilworth</span></td></tr>
<tr><td>
cluster  finite   stable   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#RC5'>dilworth</span></td></tr>
<tr><td>
cluster  non  empty   finite   stable   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#RC6'>dilworth</span></td></tr>
<tr><td>
cluster  connected   ->  finite   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#CC5'>dilworth</span></td></tr>
<tr><td>
cluster  stable   ->  finite   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#CC7'>dilworth</span></td></tr>
<tr><td>
cluster  strong-chain   ->  clique   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#CC11'>dilworth</span></td></tr>
<tr><td>
cluster 1 -element   ->  strong-chain   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#CC12'>dilworth</span></td></tr>
<tr><td>
cluster  non  empty   c=-linear   for    Element of  bool A;
</td><td><span data-href='domain_1.html#RC1'>domain_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of X -defined   REAL  -valued   non  empty   Function-like  V25( the carrier of X)  quasi_total  V156() V157() V158()  subadditive   additive   homogeneous   positively_homogeneous   Lipschitzian   for    Element of  bool [: the carrier of X,REAL:];
</td><td><span data-href='dualsp01.html#RC1'>dualsp01</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of X) V5( REAL )  non  empty   Function-like   total   quasi_total   additive   homogeneous  V166() V167() V168()  Lipschitzian   for    Element of  bool [: the carrier of X,REAL:];
</td><td><span data-href='dualsp04.html#RC1'>dualsp04</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of G -defined   the carrier of H -valued   Function-like   non  empty  V14( the carrier of G)  quasi_total   unity-preserving   multiplicative   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='endalg.html#RC2'>endalg</span></td></tr>
<tr><td>
cluster  partition-membered   for    Element of  bool (bool (bool X));
</td><td><span data-href='eqrel_1.html#RC2'>eqrel_1</span></td></tr>
<tr><td>
cluster  non  empty   partition-membered   for    Element of  bool (bool (bool X));
</td><td><span data-href='eqrel_1.html#RC4'>eqrel_1</span></td></tr>
<tr><td>
cluster  functional   FinSequence-membered   R-orthonormal   for    Element of  bool (REAL n);
</td><td><span data-href='euclid_7.html#RC3'>euclid_7</span></td></tr>
<tr><td>
cluster  orthogonal_basis   ->  R-orthonormal   complete   for    Element of  bool (REAL n);
</td><td><span data-href='euclid_7.html#CC5'>euclid_7</span></td></tr>
<tr><td>
cluster  R-orthonormal   complete   ->  orthogonal_basis   for    Element of  bool (REAL n);
</td><td><span data-href='euclid_7.html#CC6'>euclid_7</span></td></tr>
<tr><td>
cluster  functional   FinSequence-membered   orthogonal_basis   for    Element of  bool (REAL n);
</td><td><span data-href='euclid_7.html#RC4'>euclid_7</span></td></tr>
<tr><td>
cluster  orthogonal_basis   ->  non  empty   for    Element of  bool (REAL n);
</td><td><span data-href='euclid_7.html#CC7'>euclid_7</span></td></tr>
<tr><td>
cluster  R-orthonormal   ->  linearly-independent   for    Element of  bool  the carrier of (RealVectSpace (Seg n));
</td><td><span data-href='euclid_7.html#CC10'>euclid_7</span></td></tr>
<tr><td>
cluster  R-orthonormal   ->  linearly-independent   for    Element of  bool  the carrier of (REAL-US n);
</td><td><span data-href='euclid_7.html#CC11'>euclid_7</span></td></tr>
<tr><td>
cluster  Function-like  V8()  ->  continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC1'>fcont_1</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL  -valued   Function-like   complex-valued   ext-real-valued   real-valued   continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#RC1'>fcont_1</span></td></tr>
<tr><td>
cluster  Function-like   empty   ->  continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC2'>fcont_1</span></td></tr>
<tr><td>
cluster  Function-like   empty   ->  Lipschitzian   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC3'>fcont_1</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL  -valued   Function-like   empty   complex-valued   ext-real-valued   real-valued   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#RC2'>fcont_1</span></td></tr>
<tr><td>
cluster  Function-like  V8()  ->  Lipschitzian   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC4'>fcont_1</span></td></tr>
<tr><td>
cluster  Function-like   Lipschitzian   ->  continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC5'>fcont_1</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL  -valued   Function-like   non  empty   total   quasi_total   complex-valued   ext-real-valued   real-valued   continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#RC3'>fcont_1</span></td></tr>
<tr><td>
cluster  empty   ->  closed   for    Element of K19(REAL);
</td><td><span data-href='fcont_3.html#CC1'>fcont_3</span></td></tr>
<tr><td>
cluster  empty   ->  open   for    Element of K19(REAL);
</td><td><span data-href='fcont_3.html#CC2'>fcont_3</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( REAL )  Function-like   non  empty   total   non-zero   quasi_total   complex-valued   ext-real-valued   real-valued   0  -convergent   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='fdiff_1.html#RC1'>fdiff_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   0  -convergent   ->  convergent   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='fdiff_1.html#CC1'>fdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL )  Function-like   complex-valued   ext-real-valued   real-valued   RestFunc-like   for    Element of K19(K20(REAL,REAL));
</td><td><span data-href='fdiff_1.html#RC2'>fdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL )  Function-like   complex-valued   ext-real-valued   real-valued   linear   for    Element of K19(K20(REAL,REAL));
</td><td><span data-href='fdiff_1.html#RC3'>fdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL )  Function-like   non  empty   total   quasi_total   complex-valued   ext-real-valued   real-valued   differentiable   for    Element of K19(K20(REAL,REAL));
</td><td><span data-href='fdiff_1.html#RC4'>fdiff_1</span></td></tr>
<tr><td>
cluster   ->  with_non-empty_elements   for    Element of  bool A;
</td><td><span data-href='fib_num2.html#CC1'>fib_num2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  Omega -defined   StoppingSetExt T -valued   Function-like   total  V34(Omega, StoppingSetExt T)  ext-real-valued  MyFunc -StoppingTime-like   for    Element of K10(K11(Omega,(StoppingSetExt T)));
</td><td><span data-href='finance5.html#RC1'>finance5</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  Omega -defined  I -valued   Function-like   total  V34(Omega,I)  complex-valued   ext-real-valued   real-valued  Sigma, BorelSubsets I -random_variable-like  MyFunc -StoppingTime-like   for    Element of K10(K11(Omega,I));
</td><td><span data-href='finance5.html#RC2'>finance5</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  Omega -defined  [.0,+infty.] -valued   Function-like   total  V34(Omega,[.0,+infty.])  ext-real-valued  Sigma, ExtBorelsubsets  -random_variable-like  MyFunc -StoppingTime-like   for    Element of K10(K11(Omega,[.0,+infty.]));
</td><td><span data-href='finance5.html#RC3'>finance5</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like   FinSequence-like   for    Element of  bool [:NAT,D:];
</td><td><span data-href='finseq_1.html#RC1'>finseq_1</span></td></tr>
<tr><td>
cluster   ->  FinSequence-membered   for    Element of  bool X;
</td><td><span data-href='finseq_1.html#CC11'>finseq_1</span></td></tr>
<tr><td>
cluster   ->  FinSubsequence-like   for    Element of  bool fs;
</td><td><span data-href='finseq_6.html#CC1'>finseq_6</span></td></tr>
<tr><td>
cluster   ->  finite   for    Element of  bool B;
</td><td><span data-href='finset_1.html#CC2'>finset_1</span></td></tr>
<tr><td>
cluster  bool A ->  finite  ;
</td><td><span data-href='finset_1.html#FC17'>finset_1</span></td></tr>
<tr><td>
cluster  non  empty   finite   for    Element of  bool X;
</td><td><span data-href='finset_1.html#RC2'>finset_1</span></td></tr>
<tr><td>
cluster  Function-like  V18(A,B)  ->  finite   for    Element of  bool [:A,B:];
</td><td><span data-href='finset_1.html#CC3'>finset_1</span></td></tr>
<tr><td>
cluster  non  trivial   finite   for    Element of  bool X;
</td><td><span data-href='finset_1.html#RC7'>finset_1</span></td></tr>
<tr><td>
cluster  bool X ->  finite-membered  ;
</td><td><span data-href='finset_1.html#FC31'>finset_1</span></td></tr>
<tr><td>
cluster   ->  finite-membered   for    Element of  bool X;
</td><td><span data-href='finset_1.html#CC8'>finset_1</span></td></tr>
<tr><td>
cluster  bool A ->  preBoolean  ;
</td><td><span data-href='finsub_1.html#FC1'>finsub_1</span></td></tr>
<tr><td>
cluster  empty   ->  connected   for    Element of K32( the carrier of FT);
</td><td><span data-href='fintopo6.html#CC1'>fintopo6</span></td></tr>
<tr><td>
cluster  empty   ->  arcwise_connected   for    Element of K32( the carrier of FT);
</td><td><span data-href='fintopo6.html#CC3'>fintopo6</span></td></tr>
<tr><td>
cluster  open   for    Element of K24( the carrier of ET);
</td><td><span data-href='fintopo7.html#RC4'>fintopo7</span></td></tr>
<tr><td>
cluster  quasi_basis   for    Element of K24(K24( the carrier of ET));
</td><td><span data-href='fintopo7.html#RC5'>fintopo7</span></td></tr>
<tr><td>
cluster  open   for    Element of K24(K24( the carrier of ET));
</td><td><span data-href='fintopo7.html#RC6'>fintopo7</span></td></tr>
<tr><td>
cluster  quasi_basis   open   for    Element of K24(K24( the carrier of ET));
</td><td><span data-href='fintopo7.html#RC7'>fintopo7</span></td></tr>
<tr><td>
cluster  Relation-like  [:D,D:] -defined  D -valued   Function-like   total   quasi_total   associative   for    Element of  bool [:[:D,D:],D:];
</td><td><span data-href='fomodel0.html#RC1'>fomodel0</span></td></tr>
<tr><td>
cluster   ->  empty-membered   for    Element of  bool X;
</td><td><span data-href='fomodel0.html#CC2'>fomodel0</span></td></tr>
<tr><td>
cluster   -> D -prefix   for    Element of  bool (1 -tuples_on D);
</td><td><span data-href='fomodel0.html#CC3'>fomodel0</span></td></tr>
<tr><td>
cluster  quasi_total   ->  total   for    Element of  bool [:A,U:];
</td><td><span data-href='fomodel0.html#CC5'>fomodel0</span></td></tr>
<tr><td>
cluster  Relation-like  U -defined  U -valued   total   reflexive   for    Element of  bool [:U,U:];
</td><td><span data-href='fomodel0.html#RC9'>fomodel0</span></td></tr>
<tr><td>
cluster   ->  with_non-empty_elements   for    Element of  bool X;
</td><td><span data-href='fomodel0.html#CC18'>fomodel0</span></td></tr>
<tr><td>
cluster  non  empty   with_non-empty_elements   for    Element of  bool X;
</td><td><span data-href='fomodel0.html#RC12'>fomodel0</span></td></tr>
<tr><td>
cluster  denumerable   for    Element of  bool X;
</td><td><span data-href='fomodel0.html#RC13'>fomodel0</span></td></tr>
<tr><td>
cluster   ->  oneone   for    Element of  bool P;
</td><td><span data-href='fomodel0.html#CC24'>fomodel0</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   Function-like   one-to-one   non  empty   total   quasi_total   onto   bijective   symmetric   with_fixpoint   oneone   for    Element of  bool [:X,X:];
</td><td><span data-href='fomodel0.html#RC18'>fomodel0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  Function-yielding   for    Element of  bool [:X,(Funcs (Y,Z)):];
</td><td><span data-href='fomodel2.html#CC5'>fomodel2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  X -defined   Funcs (Y,Z) -valued   Function-like   total   quasi_total   Function-yielding  V171()  for    Element of  bool [:X,(Funcs (Y,Z)):];
</td><td><span data-href='fomodel2.html#RC2'>fomodel2</span></td></tr>
<tr><td>
cluster I -satisfied   for    Element of  bool X;
</td><td><span data-href='fomodel2.html#RC14'>fomodel2</span></td></tr>
<tr><td>
cluster   -> I -satisfied   for    Element of  bool X;
</td><td><span data-href='fomodel2.html#CC27'>fomodel2</span></td></tr>
<tr><td>
cluster S -correct   for    Element of  bool X;
</td><td><span data-href='fomodel2.html#RC16'>fomodel2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  X -defined  Y -valued   Function-like   total   quasi_total  E,F -respecting   for    Element of  bool [:X,Y:];
</td><td><span data-href='fomodel3.html#RC1'>fomodel3</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  Y -valued   onto   for    Element of  bool [:X,Y:];
</td><td><span data-href='fomodel3.html#RC4'>fomodel3</span></td></tr>
<tr><td>
cluster   -> S -sequents-like   for    Element of  bool (S -sequents);
</td><td><span data-href='fomodel4.html#CC1'>fomodel4</span></td></tr>
<tr><td>
cluster  Relation-like  S -sequents-like   for    Element of  bool (S -sequents);
</td><td><span data-href='fomodel4.html#RC2'>fomodel4</span></td></tr>
<tr><td>
cluster S -premises-like   for    Element of  bool X;
</td><td><span data-href='fomodel4.html#RC5'>fomodel4</span></td></tr>
<tr><td>
cluster   -> S -premises-like   for    Element of  bool X;
</td><td><span data-href='fomodel4.html#CC4'>fomodel4</span></td></tr>
<tr><td>
cluster  functional   isotone   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC8'>fomodel4</span></td></tr>
<tr><td>
cluster V18()  functional  V42()  FinSequence-membered   with_non-empty_elements  D -expanded   for    Element of  bool (AllFormulasOf S);
</td><td><span data-href='fomodel4.html#RC10'>fomodel4</span></td></tr>
<tr><td>
cluster  non  empty   functional   isotone   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC12'>fomodel4</span></td></tr>
<tr><td>
cluster 1 -ranked   ->  0  -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#CC17'>fomodel4</span></td></tr>
<tr><td>
cluster 2 -ranked   -> 1 -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#CC18'>fomodel4</span></td></tr>
<tr><td>
cluster  functional  2 -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC13'>fomodel4</span></td></tr>
<tr><td>
cluster  functional  1 -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC14'>fomodel4</span></td></tr>
<tr><td>
cluster  functional   0  -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC15'>fomodel4</span></td></tr>
<tr><td>
cluster  functional   0  -ranked  1 -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC16'>fomodel4</span></td></tr>
<tr><td>
cluster  0  -ranked   ->  non  empty   0  -ranked   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#CC19'>fomodel4</span></td></tr>
<tr><td>
cluster  functional   isotone   Correct   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC20'>fomodel4</span></td></tr>
<tr><td>
cluster  functional   isotone  2 -ranked   Correct   for    Element of  bool (Funcs ((bool (S -sequents)),(bool (S -sequents))));
</td><td><span data-href='fomodel4.html#RC21'>fomodel4</span></td></tr>
<tr><td>
cluster  open  x -quasi_basis   ->  non  empty   for    Element of K19(K19( the carrier of T));
</td><td><span data-href='frechet.html#CC1'>frechet</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  Y -valued   Function-like   constant   total   quasi_total   for    Element of  bool [:X,Y:];
</td><td><span data-href='funcop_1.html#RC3'>funcop_1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  Y -valued   Function-like   total   for    Element of  bool [:X,Y:];
</td><td><span data-href='funcop_1.html#RC4'>funcop_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  Function-yielding   for    Element of  bool [:X,(Funcs (Y,Z)):];
</td><td><span data-href='funcop_1.html#CC4'>funcop_1</span></td></tr>
<tr><td>
cluster   ->  Function-like   for    Element of  bool f;
</td><td><span data-href='funct_1.html#CC3'>funct_1</span></td></tr>
<tr><td>
cluster   ->  functional   for    Element of  bool A;
</td><td><span data-href='funct_1.html#CC9'>funct_1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  Y -valued   Function-like   quasi_total   for    Element of  bool [:X,Y:];
</td><td><span data-href='funct_2.html#RC1'>funct_2</span></td></tr>
<tr><td>
cluster  total   ->  quasi_total   for    Element of  bool [:X,Y:];
</td><td><span data-href='funct_2.html#CC1'>funct_2</span></td></tr>
<tr><td>
cluster  quasi_total   ->  total   for    Element of  bool [:X,Y:];
</td><td><span data-href='funct_2.html#CC2'>funct_2</span></td></tr>
<tr><td>
cluster  quasi_total   ->  total   for    Element of  bool [:X,Y:];
</td><td><span data-href='funct_2.html#CC3'>funct_2</span></td></tr>
<tr><td>
cluster  quasi_total   ->  total   for    Element of  bool [:X,X:];
</td><td><span data-href='funct_2.html#CC4'>funct_2</span></td></tr>
<tr><td>
cluster  quasi_total   ->  total   for    Element of  bool [:[:X,X:],X:];
</td><td><span data-href='funct_2.html#CC5'>funct_2</span></td></tr>
<tr><td>
cluster  Function-like   bijective   ->  one-to-one   onto   for    Element of  bool [:X,Y:];
</td><td><span data-href='funct_2.html#CC6'>funct_2</span></td></tr>
<tr><td>
cluster  Function-like   one-to-one   onto   ->  bijective   for    Element of  bool [:X,Y:];
</td><td><span data-href='funct_2.html#CC7'>funct_2</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   Function-like   total   quasi_total   bijective   for    Element of  bool [:X,X:];
</td><td><span data-href='funct_2.html#RC2'>funct_2</span></td></tr>
<tr><td>
cluster  reflexive   Function-like   total   quasi_total   ->  bijective   for    Element of  bool [:X,X:];
</td><td><span data-href='funct_2.html#CC8'>funct_2</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  non  empty   for    Element of  bool [:A,B:];
</td><td><span data-href='funct_2.html#CC9'>funct_2</span></td></tr>
<tr><td>
cluster  Relation-like  [:A,A:] -defined  A -valued   Function-like   quasi_total   idempotent   for    Element of  bool [:[:A,A:],A:];
</td><td><span data-href='funct_3.html#RC1'>funct_3</span></td></tr>
<tr><td>
cluster  complex-membered   symmetrical   for    Element of K16(COMPLEX);
</td><td><span data-href='funct_8.html#RC1'>funct_8</span></td></tr>
<tr><td>
cluster  complex-membered   ext-real-membered   real-membered   symmetrical   for    Element of K16(REAL);
</td><td><span data-href='funct_8.html#RC2'>funct_8</span></td></tr>
<tr><td>
cluster  Function-like   with_symmetrical_domain   quasi_even   ->  even   for    Element of K16(K17(X,Y));
</td><td><span data-href='funct_8.html#CC2'>funct_8</span></td></tr>
<tr><td>
cluster  Function-like   even   ->  with_symmetrical_domain   quasi_even   for    Element of K16(K17(X,Y));
</td><td><span data-href='funct_8.html#CC3'>funct_8</span></td></tr>
<tr><td>
cluster  Function-like   with_symmetrical_domain   quasi_odd   ->  odd   for    Element of K16(K17(X,Y));
</td><td><span data-href='funct_8.html#CC4'>funct_8</span></td></tr>
<tr><td>
cluster  Function-like   odd   ->  with_symmetrical_domain   quasi_odd   for    Element of K16(K17(X,Y));
</td><td><span data-href='funct_8.html#CC5'>funct_8</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like   complex-valued   ext-real-valued   real-valued   periodic   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='funct_9.html#RC2'>funct_9</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like  V30( REAL , REAL )  complex-valued   ext-real-valued   real-valued  t -periodic   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='funct_9.html#RC4'>funct_9</span></td></tr>
<tr><td>
cluster  Relation-like  [:A,A:] -defined  [:B,B:] -valued   Function-like   quasi_total   Covariant   Contravariant   for    Element of  bool [:[:A,A:],[:B,B:]:];
</td><td><span data-href='functor0.html#RC1'>functor0</span></td></tr>
<tr><td>
cluster V1() V4([:[.0,1.],[.0,1.]:]) V5([.0,1.])  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  with_properties_of_fuzzy_implication   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#RC1'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  with_properties_of_fuzzy_implication   ->  decreasing_on_1st   increasing_on_2nd   00-dominant   11-dominant   10-weak   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#CC1'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  decreasing_on_1st   increasing_on_2nd   00-dominant   11-dominant   10-weak   01-dominant   ->  with_properties_of_fuzzy_implication   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#CC2'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  with_properties_of_classical_implication   ->  00-dominant   11-dominant   10-weak   01-dominant   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#CC3'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  00-dominant   11-dominant   10-weak   01-dominant   ->  with_properties_of_classical_implication   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#CC4'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  with_properties_of_fuzzy_implication   ->  with_properties_of_classical_implication   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#CC5'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  decreasing_on_1st   increasing_on_2nd   00-dominant   11-dominant   10-weak   ->  satisfying_(LB)   satisfying_(RB)   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#CC6'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29(K17([.0,1.],[.0,1.]),[.0,1.])  satisfying_(LB)   ->  satisfying_(I3)   satisfying_(NC)   for    Element of K16(K17(K17([.0,1.],[.0,1.]),[.0,1.]));
</td><td><span data-href='fuzimpl2.html#CC1'>fuzimpl2</span></td></tr>
<tr><td>
cluster  Function-like  V29(K17([.0,1.],[.0,1.]),[.0,1.])  satisfying_(RB)   ->  satisfying_(I4)   satisfying_(NC)   for    Element of K16(K17(K17([.0,1.],[.0,1.]),[.0,1.]));
</td><td><span data-href='fuzimpl2.html#CC2'>fuzimpl2</span></td></tr>
<tr><td>
cluster  Function-like  V29(K17([.0,1.],[.0,1.]),[.0,1.])  satisfying_(NP)   ->  satisfying_(I4)   satisfying_(I5)   for    Element of K16(K17(K17([.0,1.],[.0,1.]),[.0,1.]));
</td><td><span data-href='fuzimpl2.html#CC3'>fuzimpl2</span></td></tr>
<tr><td>
cluster  Function-like  V29(K17([.0,1.],[.0,1.]),[.0,1.])  satisfying_(IP)   ->  satisfying_(I3)   satisfying_(I4)   for    Element of K16(K17(K17([.0,1.],[.0,1.]),[.0,1.]));
</td><td><span data-href='fuzimpl2.html#CC4'>fuzimpl2</span></td></tr>
<tr><td>
cluster  Function-like  V29(K17([.0,1.],[.0,1.]),[.0,1.])  satisfying_(OP)   ->  satisfying_(I3)   satisfying_(I4)   satisfying_(NC)   satisfying_(LB)   satisfying_(RB)   satisfying_(IP)   for    Element of K16(K17(K17([.0,1.],[.0,1.]),[.0,1.]));
</td><td><span data-href='fuzimpl2.html#CC5'>fuzimpl2</span></td></tr>
<tr><td>
cluster  Function-like  V29(K17([.0,1.],[.0,1.]),[.0,1.])  satisfying_(EP)   satisfying_(OP)   ->  satisfying_(I1)   satisfying_(I5)   satisfying_(NP)   for    Element of K16(K17(K17([.0,1.],[.0,1.]),[.0,1.]));
</td><td><span data-href='fuzimpl2.html#CC6'>fuzimpl2</span></td></tr>
<tr><td>
cluster  Relation-like  [:[.0,1.],[.0,1.]:] -defined  [.0,1.] -valued   Function-like  V26([:[.0,1.],[.0,1.]:]) V30([:[.0,1.],[.0,1.]:],[.0,1.])  commutative   associative   monotonic   with-1-identity   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuznorm1.html#RC1'>fuznorm1</span></td></tr>
<tr><td>
cluster  Relation-like  [:[.0,1.],[.0,1.]:] -defined  [.0,1.] -valued   Function-like  V26([:[.0,1.],[.0,1.]:]) V30([:[.0,1.],[.0,1.]:],[.0,1.])  commutative   associative   monotonic   with-0-identity   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuznorm1.html#RC2'>fuznorm1</span></td></tr>
<tr><td>
cluster  Function-like  V30([:[.0,1.],[.0,1.]:],[.0,1.])  commutative   monotonic   with-1-identity   ->  commutative   monotonic   with-1-identity   with-0-annihilating   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuznorm1.html#CC1'>fuznorm1</span></td></tr>
<tr><td>
cluster  Function-like  V30([:[.0,1.],[.0,1.]:],[.0,1.])  commutative   monotonic   with-0-identity   ->  commutative   monotonic   with-1-annihilating   with-0-identity   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuznorm1.html#CC2'>fuznorm1</span></td></tr>
<tr><td>
cluster V5([.0,1.])  Function-like  V30(C, REAL )  strictly-normalized   ->  normalized   for    Element of K16(K17(C,REAL));
</td><td><span data-href='fuznum_1.html#CC1'>fuznum_1</span></td></tr>
<tr><td>
cluster V1() V4(C) V5( REAL ) V5([.0,1.])  non  empty   Function-like   total  V30(C, REAL ) V39() V40() V41()  normalized   for    Element of K16(K17(C,REAL));
</td><td><span data-href='fuznum_1.html#RC1'>fuznum_1</span></td></tr>
<tr><td>
cluster  non  trivial  V49() V50() V51()  closed   closed_interval   for    Element of K16(REAL);
</td><td><span data-href='fuznum_1.html#RC2'>fuznum_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL ) V5([.0,1.])  non  empty   Function-like   total  V30( REAL , REAL ) V39() V40() V41()  triangular   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='fuznum_1.html#RC3'>fuznum_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL ) V5([.0,1.])  non  empty   Function-like   total  V30( REAL , REAL ) V39() V40() V41()  trapezoidal   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='fuznum_1.html#RC4'>fuznum_1</span></td></tr>
<tr><td>
cluster  Relation-like  C -defined   REAL  -valued  [.0,1.] -valued   non  empty   Function-like   total  V30(C, REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K16(K17(C,REAL));
</td><td><span data-href='fuzzy_1.html#RC1'>fuzzy_1</span></td></tr>
<tr><td>
cluster [.0,1.] -valued   Function-like  V30(X, REAL )  ->  real-valued   for    Element of K16(K17(X,REAL));
</td><td><span data-href='fuzzy_1.html#CC1'>fuzzy_1</span></td></tr>
<tr><td>
cluster V5([.0,1.])  Function-like   quasi_total   ->   for    Element of  bool [:C,REAL:];
</td><td><span data-href='fuzzy_2.html#CC1'>fuzzy_2</span></td></tr>
<tr><td>
cluster  Relation-like  A -defined   ExtREAL  -valued   Function-like  V40(A, ExtREAL )  e.i.-valued   for    Element of  bool [:A,ExtREAL:];
</td><td><span data-href='fvaluat1.html#RC4'>fvaluat1</span></td></tr>
<tr><td>
cluster  non  empty   convex   for    Element of K16( the carrier of (TOP-REAL 2));
</td><td><span data-href='goboard9.html#RC1'>goboard9</span></td></tr>
<tr><td>
cluster  Consistent   ->  satisfiable   for    Element of  bool (CQC-WFF Al);
</td><td><span data-href='goedcpuc.html#CC1'>goedcpuc</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of G -defined   the carrier of H -valued   Function-like   non  empty   total   quasi_total   additive   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='grcat_1.html#RC1'>grcat_1</span></td></tr>
<tr><td>
cluster   -> f -compatible   for    Element of K10(g);
</td><td><span data-href='grfunc_1.html#CC2'>grfunc_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of G -defined   the carrier of H -valued   Function-like   non  empty  V22( the carrier of G)  quasi_total   multiplicative   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='group_6.html#RC2'>group_6</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   multiplicative   ->  unity-preserving   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='group_6.html#CC1'>group_6</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of G -defined   the carrier of H -valued   Function-like   non  empty   total   quasi_total   multiplicative   homomorphic   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='group_9.html#RC9'>group_9</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   Funcs (E,E) -valued   non  empty   Function-like   total   quasi_total   being_left_operation   for    Element of  bool [: the carrier of S,(Funcs (E,E)):];
</td><td><span data-href='group_10.html#RC1'>group_10</span></td></tr>
<tr><td>
cluster  Relation-like  I -defined   the carrier of G -valued   Function-like   total   quasi_total   finite-support   for    Element of  bool [:I, the carrier of G:];
</td><td><span data-href='group_19.html#RC2'>group_19</span></td></tr>
<tr><td>
cluster  non  empty   functional   FinSequence-membered   antichain-like   for    Element of  bool GRZ-formula-set;
</td><td><span data-href='grzlog_1.html#RC1'>grzlog_1</span></td></tr>
<tr><td>
cluster  non  empty   for    Element of  bool (bool GRZ-formula-set);
</td><td><span data-href='grzlog_1.html#RC4'>grzlog_1</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  additive   ->  subadditive   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC1'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  homogeneous   ->  positively_homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC2'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  semi-homogeneous   ->  positively_homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC3'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  semi-homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC4'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  absolutely_homogeneous   ->  semi-homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC5'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  positively_homogeneous   0-preserving   ->  semi-homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC6'>hahnban</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   REAL  -valued   Function-like   non  empty   total  V18( the carrier of V, REAL )  additive   homogeneous   absolutely_homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#RC1'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V33( the carrier of V, the carrier of K)  homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='hahnban1.html#CC1'>hahnban1</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of K)  Function-like  V33( the carrier of V, the carrier of K)  additive   homogeneous   0-preserving   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='hahnban1.html#RC1'>hahnban1</span></td></tr>
<tr><td>
cluster  Function-like  V33( the carrier of V, REAL )  additive   ->  subadditive   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban1.html#CC2'>hahnban1</span></td></tr>
<tr><td>
cluster  Function-like  V33( the carrier of V, REAL )  Real_homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban1.html#CC3'>hahnban1</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( REAL )  Function-like  V33( the carrier of V, REAL )  additive   0-preserving   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban1.html#RC2'>hahnban1</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( REAL )  Function-like  V33( the carrier of V, REAL )  additive   Real_homogeneous   homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban1.html#RC3'>hahnban1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   NAT  -defined   bool F -valued   non  empty   Function-like   finite   FinSequence-like   FinSubsequence-like   for    FinSequence of  bool F;
</td><td><span data-href='hallmar1.html#RC1'>hallmar1</span></td></tr>
<tr><td>
cluster A . i ->  finite  ;
</td><td><span data-href='hallmar1.html#FC1'>hallmar1</span></td></tr>
<tr><td>
cluster  union (A,J) ->  finite  ;
</td><td><span data-href='hallmar1.html#FC2'>hallmar1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   bool F -valued   non  empty   Function-like   finite   FinSequence-like   FinSubsequence-like   Hall   for    FinSequence of  bool F;
</td><td><span data-href='hallmar1.html#RC2'>hallmar1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   bool F -valued   Function-like   finite   FinSequence-like   FinSubsequence-like   Hall   for    FinSequence of  bool F;
</td><td><span data-href='hallmar1.html#RC3'>hallmar1</span></td></tr>
<tr><td>
cluster  non  empty   Hall   ->  non-empty   non  empty   for    FinSequence of  bool F;
</td><td><span data-href='hallmar1.html#CC1'>hallmar1</span></td></tr>
<tr><td>
cluster   ->  non  empty   for    Singlification of A,k;
</td><td><span data-href='hallmar1.html#CC2'>hallmar1</span></td></tr>
<tr><td>
cluster   ->  non  empty   for    Singlification of A;
</td><td><span data-href='hallmar1.html#CC3'>hallmar1</span></td></tr>
<tr><td>
cluster  Consistent   for    Element of  bool (CQC-WFF Al);
</td><td><span data-href='henmodel.html#RC1'>henmodel</span></td></tr>
<tr><td>
cluster  Function-like  V30( the carrier of V, the carrier of F_Complex)  cmplxhomogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC1'>hermitan</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of F_Complex)  Function-like  V30( the carrier of V, the carrier of F_Complex)  additive   0-preserving  V190()  cmplxhomogeneous   for    Element of  bool [: the carrier of V, the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#RC1'>hermitan</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of F_Complex)  non  trivial   Function-like   non  constant  V30( the carrier of V, the carrier of F_Complex)  additive  V190()  cmplxhomogeneous   for    Element of  bool [: the carrier of V, the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#RC2'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  hermitan   ->  diagRvalued   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC2'>hermitan</span></td></tr>
<tr><td>
cluster V1() V4([: the carrier of V, the carrier of V:]) V5( the carrier of F_Complex)  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  additiveFAF   additiveSAF   homogeneousSAF  V190()  cmplxhomogeneousFAF   hermitan   diagRvalued   diagReR+0valued   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#RC3'>hermitan</span></td></tr>
<tr><td>
cluster V1() V4([: the carrier of V, the carrier of W:]) V5( the carrier of F_Complex)  Function-like  V30([: the carrier of V, the carrier of W:], the carrier of F_Complex)  additiveFAF   additiveSAF   homogeneousSAF  V190()  cmplxhomogeneousFAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#RC4'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  additiveFAF   hermitan   ->  additiveSAF   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC3'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  additiveSAF   hermitan   ->  additiveFAF   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC4'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  homogeneousSAF   hermitan   ->  cmplxhomogeneousFAF   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC5'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  cmplxhomogeneousFAF   hermitan   ->  homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC6'>hermitan</span></td></tr>
<tr><td>
cluster V1() V4([: the carrier of V, the carrier of W:]) V5( the carrier of F_Complex)  non  trivial   Function-like   non  constant  V30([: the carrier of V, the carrier of W:], the carrier of F_Complex)  additiveFAF   additiveSAF   homogeneousSAF  V190()  cmplxhomogeneousFAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#RC5'>hermitan</span></td></tr>
<tr><td>
cluster V1() V4([: the carrier of V, the carrier of V:]) V5( the carrier of F_Complex)  non  trivial   Function-like   non  constant  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  additiveFAF   additiveSAF   homogeneousSAF  V190()  cmplxhomogeneousFAF   hermitan   diagRvalued   diagReR+0valued   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#RC6'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  additiveSAF   positivediagvalued   ->  diagReR+0valued   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC7'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  additiveFAF   positivediagvalued   ->  diagReR+0valued   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC8'>hermitan</span></td></tr>
<tr><td>
cluster  Relation-like   Bags X -defined   INT  -valued   the carrier of F_Real -valued   Function-like   non  empty   total   quasi_total   complex-valued   ext-real-valued   real-valued   for    Element of K27(K28((Bags X), the carrier of F_Real));
</td><td><span data-href='hilb10_2.html#RC3'>hilb10_2</span></td></tr>
<tr><td>
cluster  Relation-like   Bags O -defined   INT  -valued   the carrier of F_Real -valued   Function-like   non  empty   total   quasi_total   complex-valued   ext-real-valued   real-valued   finite-Support   for    Element of K27(K28((Bags O), the carrier of F_Real));
</td><td><span data-href='hilb10_2.html#RC4'>hilb10_2</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   the carrier of F_Real -valued   Function-like   total   quasi_total   complex-valued   ext-real-valued   real-valued   natural-valued   for    Element of K27(K28(X, the carrier of F_Real));
</td><td><span data-href='hilb10_2.html#RC5'>hilb10_2</span></td></tr>
<tr><td>
cluster  Relation-like  O -defined   INT  -valued   the carrier of F_Real -valued   Function-like   total   quasi_total   complex-valued   ext-real-valued   real-valued   for    Element of K27(K28(O, the carrier of F_Real));
</td><td><span data-href='hilb10_2.html#RC6'>hilb10_2</span></td></tr>
<tr><td>
cluster  empty   ->  diophantine   for    Element of K27((n -xtuples_of NAT));
</td><td><span data-href='hilb10_2.html#CC2'>hilb10_2</span></td></tr>
<tr><td>
cluster   ->  diophantine   for    Element of K27((n -xtuples_of NAT));
</td><td><span data-href='hilb10_2.html#CC3'>hilb10_2</span></td></tr>
<tr><td>
cluster  functional   non  empty   diophantine   for    Element of K27((n -xtuples_of NAT));
</td><td><span data-href='hilb10_2.html#RC7'>hilb10_2</span></td></tr>
<tr><td>
cluster  functional   empty   diophantine   for    Element of K27((n -xtuples_of NAT));
</td><td><span data-href='hilb10_2.html#RC8'>hilb10_2</span></td></tr>
<tr><td>
cluster  Relation-like   Bags n -defined   the carrier of F_Real -valued   non  empty   Function-like   total   quasi_total   complex-valued   ext-real-valued   real-valued   natural-valued   finite-Support   for    Element of K16(K17((Bags n), the carrier of F_Real));
</td><td><span data-href='hilb10_5.html#RC1'>hilb10_5</span></td></tr>
<tr><td>
cluster  with_VERUM   with_implication   with_conjunction   with_propositional_variables   ->  HP-closed   for    Element of K16((NAT *));
</td><td><span data-href='hilbert1.html#CC2'>hilbert1</span></td></tr>
<tr><td>
cluster  Relation-like   SetVal (V,(p => q)) -defined   SetVal (V,(p => r)) -valued   non  empty   Function-like   total   quasi_total   Function-yielding  V59()  for    Element of  bool [:(SetVal (V,(p => q))),(SetVal (V,(p => r))):];
</td><td><span data-href='hilbert3.html#RC1'>hilbert3</span></td></tr>
<tr><td>
cluster  Relation-like  A -defined  A -valued   Function-like   one-to-one   total   quasi_total   onto   bijective   involutive   oneone   for    Element of  bool [:A,A:];
</td><td><span data-href='hilbert4.html#RC2'>hilbert4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  X -defined  X -valued   Function-like   one-to-one   total   quasi_total   onto   bijective  V67()  oneone   for    Element of  bool [:X,X:];
</td><td><span data-href='hilbert4.html#RC3'>hilbert4</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of F_Complex -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of F_Complex)  complex-valued   finite-Support   Hurwitz   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='hurwitz2.html#RC1'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of L -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of L)  finite-Support   even   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='hurwitz2.html#RC2'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of L -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of L)  finite-Support   odd   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='hurwitz2.html#RC3'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of L -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of L)  finite-Support   non  zero   even   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='hurwitz2.html#RC4'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of L -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of L)  finite-Support   non  zero   odd   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='hurwitz2.html#RC5'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of F_Complex -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of F_Complex)  complex-valued   finite-Support   non  zero   real   positive   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='hurwitz2.html#RC6'>hurwitz2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , the carrier of F_Complex)  finite-Support   real   ->  real-valued   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='hurwitz2.html#CC1'>hurwitz2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , the carrier of F_Complex)  finite-Support   real   with_positive_coefficients   ->  real   with_all_coefficients   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='hurwitz2.html#CC2'>hurwitz2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , the carrier of F_Complex)  finite-Support   real   with_negative_coefficients   ->  real   with_all_coefficients   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='hurwitz2.html#CC3'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of F_Complex -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of F_Complex)  complex-valued   ext-real-valued   real-valued   finite-Support   non  constant   real   with_positive_coefficients   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='hurwitz2.html#RC7'>hurwitz2</span></td></tr>
<tr><td>
cluster  non  empty   add-closed   for    Element of  bool  the carrier of L;
</td><td><span data-href='ideal_1.html#RC3'>ideal_1</span></td></tr>
<tr><td>
cluster  non  empty   left-ideal   for    Element of  bool  the carrier of L;
</td><td><span data-href='ideal_1.html#RC4'>ideal_1</span></td></tr>
<tr><td>
cluster  non  empty   right-ideal   for    Element of  bool  the carrier of L;
</td><td><span data-href='ideal_1.html#RC5'>ideal_1</span></td></tr>
<tr><td>
cluster  non  empty   add-closed   left-ideal   right-ideal   for    Element of  bool  the carrier of L;
</td><td><span data-href='ideal_1.html#RC6'>ideal_1</span></td></tr>
<tr><td>
cluster  non  empty   add-closed   right-ideal   for    Element of  bool  the carrier of L;
</td><td><span data-href='ideal_1.html#RC7'>ideal_1</span></td></tr>
<tr><td>
cluster  non  empty   add-closed   left-ideal   for    Element of  bool  the carrier of L;
</td><td><span data-href='ideal_1.html#RC8'>ideal_1</span></td></tr>
<tr><td>
cluster  non  empty   left-ideal   ->  non  empty   right-ideal   for    Element of  bool  the carrier of R;
</td><td><span data-href='ideal_1.html#CC1'>ideal_1</span></td></tr>
<tr><td>
cluster  non  empty   right-ideal   ->  non  empty   left-ideal   for    Element of  bool  the carrier of R;
</td><td><span data-href='ideal_1.html#CC2'>ideal_1</span></td></tr>
<tr><td>
cluster  non  empty   proper   add-closed   left-ideal   right-ideal   for    Element of  bool  the carrier of R;
</td><td><span data-href='ideal_1.html#RC9'>ideal_1</span></td></tr>
<tr><td>
cluster  non  empty   add-closed   left-ideal   right-ideal   finitely_generated   for    Element of  bool  the carrier of L;
</td><td><span data-href='ideal_1.html#RC13'>ideal_1</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   COMPLEX  -valued   Function-like   complex-valued   C1-curve-like   for    Element of  bool [:REAL,COMPLEX:];
</td><td><span data-href='integr1c.html#RC1'>integr1c</span></td></tr>
<tr><td>
cluster  closed_interval   ->  compact   for    Element of  bool REAL;
</td><td><span data-href='integra1.html#CC1'>integra1</span></td></tr>
<tr><td>
cluster  non  empty   closed_interval   ->  real-bounded   for    Element of  bool REAL;
</td><td><span data-href='integra1.html#CC2'>integra1</span></td></tr>
<tr><td>
cluster  non  empty   ordered   for    Element of K19(K19(X));
</td><td><span data-href='interva1.html#RC2'>interva1</span></td></tr>
<tr><td>
cluster  with_FALSUM   with_int_implication   with_int_conjunction   with_int_disjunction   with_int_propositional_variables   with_modal_operator   ->  MC-closed   for    Element of K16((NAT *));
</td><td><span data-href='intpro_1.html#CC2'>intpro_1</span></td></tr>
<tr><td>
cluster  closed   ->  supercondensed   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC1'>isomichi</span></td></tr>
<tr><td>
cluster  condensed   ->  supercondensed   subcondensed   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC2'>isomichi</span></td></tr>
<tr><td>
cluster  supercondensed   subcondensed   ->  condensed   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC3'>isomichi</span></td></tr>
<tr><td>
cluster  condensed   supercondensed   subcondensed   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#RC2'>isomichi</span></td></tr>
<tr><td>
cluster  subcondensed   ->  semi-open   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC4'>isomichi</span></td></tr>
<tr><td>
cluster  semi-open   ->  subcondensed   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC5'>isomichi</span></td></tr>
<tr><td>
cluster  empty   ->  regular_closed   regular_open   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC6'>isomichi</span></td></tr>
<tr><td>
cluster  regular_closed   regular_open   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#RC3'>isomichi</span></td></tr>
<tr><td>
cluster  regular_open   ->  open   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC7'>isomichi</span></td></tr>
<tr><td>
cluster  regular_closed   ->  closed   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC8'>isomichi</span></td></tr>
<tr><td>
cluster  regular_open   ->  open   condensed   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC9'>isomichi</span></td></tr>
<tr><td>
cluster  open   condensed   ->  regular_open   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC10'>isomichi</span></td></tr>
<tr><td>
cluster  regular_closed   ->  closed   condensed   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC11'>isomichi</span></td></tr>
<tr><td>
cluster  closed   condensed   ->  regular_closed   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC12'>isomichi</span></td></tr>
<tr><td>
cluster  1st_class   ->  non  2nd_class   non  3rd_class   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC13'>isomichi</span></td></tr>
<tr><td>
cluster  2nd_class   ->  non  1st_class   non  3rd_class   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC14'>isomichi</span></td></tr>
<tr><td>
cluster  3rd_class   ->  non  1st_class   non  2nd_class   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC15'>isomichi</span></td></tr>
<tr><td>
cluster  supercondensed   ->  1st_class   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC16'>isomichi</span></td></tr>
<tr><td>
cluster  subcondensed   ->  1st_class   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC17'>isomichi</span></td></tr>
<tr><td>
cluster  non  empty   proper   ->  2nd_class   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#CC18'>isomichi</span></td></tr>
<tr><td>
cluster  2nd_class   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#RC4'>isomichi</span></td></tr>
<tr><td>
cluster  1st_class   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#RC7'>isomichi</span></td></tr>
<tr><td>
cluster  2nd_class   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#RC8'>isomichi</span></td></tr>
<tr><td>
cluster  3rd_class   for    Element of  bool  the carrier of T;
</td><td><span data-href='isomichi.html#RC9'>isomichi</span></td></tr>
<tr><td>
cluster  non  empty   compact   vertical   ->  with_the_max_arc   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='jordan.html#CC1'>jordan</span></td></tr>
<tr><td>
cluster  empty   ->  bounded   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='jordan.html#CC2'>jordan</span></td></tr>
<tr><td>
cluster  non  bounded   ->  non  empty   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='jordan.html#CC3'>jordan</span></td></tr>
<tr><td>
cluster  functional   open   closed   non  bounded   convex   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='jordan.html#RC1'>jordan</span></td></tr>
<tr><td>
cluster  bounded   ->  proper   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='jordan.html#CC4'>jordan</span></td></tr>
<tr><td>
cluster  functional   non  empty   closed   bounded   convex   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='jordan.html#RC2'>jordan</span></td></tr>
<tr><td>
cluster  functional   non  empty   open   bounded   convex   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='jordan.html#RC3'>jordan</span></td></tr>
<tr><td>
cluster  convex   ->  connected   for    Element of K16( the carrier of (TOP-REAL n));
</td><td><span data-href='jordan1.html#CC1'>jordan1</span></td></tr>
<tr><td>
cluster  non  empty   being_simple_closed_curve   compact   non  horizontal   non  vertical   for    Element of K16( the U1 of (TOP-REAL 2));
</td><td><span data-href='jordan1a.html#RC1'>jordan1a</span></td></tr>
<tr><td>
cluster  bounded   for    Element of  bool  the carrier of M;
</td><td><span data-href='jordan2c.html#RC1'>jordan2c</span></td></tr>
<tr><td>
cluster  compact   ->  bounded   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='jordan2c.html#CC1'>jordan2c</span></td></tr>
<tr><td>
cluster  non  empty  V52() V53() V54()  finite   real-bounded   for    Element of K16(REAL);
</td><td><span data-href='jordan5a.html#RC2'>jordan5a</span></td></tr>
<tr><td>
cluster  finite   ->  compact   for    Element of K16(REAL);
</td><td><span data-href='jordan5a.html#CC1'>jordan5a</span></td></tr>
<tr><td>
cluster V23()  connected   compact   non  horizontal   non  vertical   for    Element of K16( the carrier of (TOP-REAL 2));
</td><td><span data-href='jordan10.html#RC1'>jordan10</span></td></tr>
<tr><td>
cluster  with_the_max_arc   ->  non  empty   for    Element of K16( the carrier of (TOP-REAL 2));
</td><td><span data-href='jordan21.html#CC1'>jordan21</span></td></tr>
<tr><td>
cluster  being_simple_closed_curve   ->  with_the_max_arc   for    Element of K16( the carrier of (TOP-REAL 2));
</td><td><span data-href='jordan21.html#CC2'>jordan21</span></td></tr>
<tr><td>
cluster  non  empty   closed   connected   compact   bounded   non  horizontal   non  vertical   being_simple_closed_curve   with_the_max_arc   for    Element of K16( the carrier of (TOP-REAL 2));
</td><td><span data-href='jordan21.html#RC1'>jordan21</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of (TopSpaceMetr M)) V5( the carrier of (TopSpaceMetr M))  non  empty   Function-like  V26( the carrier of (TopSpaceMetr M))  quasi_total   onto   isometric   for    Element of K16(K17( the carrier of (TopSpaceMetr M), the carrier of (TopSpaceMetr M)));
</td><td><span data-href='jordan24.html#RC1'>jordan24</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   isometric   ->  continuous   for    Element of K16(K17( the carrier of (TopSpaceMetr M), the carrier of (TopSpaceMetr M)));
</td><td><span data-href='jordan24.html#CC1'>jordan24</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   onto   isometric   ->  being_homeomorphism   for    Element of K16(K17( the carrier of (TopSpaceMetr M), the carrier of (TopSpaceMetr M)));
</td><td><span data-href='jordan24.html#CC2'>jordan24</span></td></tr>
<tr><td>
cluster  Relation-like  A -defined  B -valued   Function-like   quasi_total   c=-monotone   for    Element of  bool [:A,B:];
</td><td><span data-href='knaster.html#RC1'>knaster</span></td></tr>
<tr><td>
cluster  non  empty   with_suprema   with_infima   for    Element of  bool  the carrier of L;
</td><td><span data-href='knaster.html#RC2'>knaster</span></td></tr>
<tr><td>
cluster  Function-like  V35( NAT , bool X)  ->  non  empty   for    Element of  bool [:NAT,(bool X):];
</td><td><span data-href='kurato_0.html#CC1'>kurato_0</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   non-empty   NAT  -defined   bool T -valued   Function-like  V31( NAT ) V35( NAT , bool T)  for    Element of  bool [:NAT,(bool T):];
</td><td><span data-href='kurato_0.html#RC1'>kurato_0</span></td></tr>
<tr><td>
cluster  Function-like   constant  V35( NAT , bool T)  -> V52() V53()  convergent   for    Element of  bool [:NAT,(bool T):];
</td><td><span data-href='kurato_0.html#CC2'>kurato_0</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   NAT  -defined   bool T -valued   Function-like   constant  V31( NAT ) V35( NAT , bool T)  for    Element of  bool [:NAT,(bool T):];
</td><td><span data-href='kurato_0.html#RC2'>kurato_0</span></td></tr>
<tr><td>
cluster  with_non-empty_elements   with_proper_subsets   for    Element of  bool (bool  the carrier of R^1);
</td><td><span data-href='kurato_1.html#RC1'>kurato_1</span></td></tr>
<tr><td>
cluster  non  empty   Cl-closed   Int-closed   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='kurato_1.html#RC2'>kurato_1</span></td></tr>
<tr><td>
cluster  non  empty   compl-closed   Cl-closed   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='kurato_1.html#RC3'>kurato_1</span></td></tr>
<tr><td>
cluster  non  empty   meet-closed   join-closed   for    Element of  bool  the carrier of L;
</td><td><span data-href='lattad_1.html#RC6'>lattad_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L1 -defined   the carrier of L2 -valued   Function-like   non  empty  V19( the carrier of L1)  quasi_total   "\/"-preserving   "/\"-preserving   for    Element of  bool [: the carrier of L1, the carrier of L2:];
</td><td><span data-href='lattice4.html#RC1'>lattice4</span></td></tr>
<tr><td>
cluster  non  empty   meet-closed   join-closed   for    Element of  bool  the carrier of L;
</td><td><span data-href='lattice4.html#RC2'>lattice4</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L1 -defined   the carrier of L2 -valued   Function-like   quasi_total   meet-preserving   join-preserving   for    Element of  bool [: the carrier of L1, the carrier of L2:];
</td><td><span data-href='lattice5.html#RC1'>lattice5</span></td></tr>
<tr><td>
cluster  Relation-like  [:A,A:] -defined   the carrier of L -valued   Function-like   quasi_total   symmetric   zeroed   u.t.i.   for    Element of  bool [:[:A,A:], the carrier of L:];
</td><td><span data-href='lattice5.html#RC3'>lattice5</span></td></tr>
<tr><td>
cluster  non  empty   strongly_connected   for    Element of  bool  the carrier of L;
</td><td><span data-href='lattice7.html#RC1'>lattice7</span></td></tr>
<tr><td>
cluster  non  empty   final   meet-closed   maximal   ->  proper   for    Element of K19( the carrier of L);
</td><td><span data-href='latticea.html#CC1'>latticea</span></td></tr>
<tr><td>
cluster  non  empty   final   meet-closed   maximal   ->  being_ultrafilter   for    Element of K19( the carrier of L);
</td><td><span data-href='latticea.html#CC2'>latticea</span></td></tr>
<tr><td>
cluster  non  empty   final   meet-closed   being_ultrafilter   ->  maximal   for    Element of K19( the carrier of L);
</td><td><span data-href='latticea.html#CC3'>latticea</span></td></tr>
<tr><td>
cluster  non  empty   initial   join-closed   maximal   ->  max-ideal   for    Element of K19( the carrier of L);
</td><td><span data-href='latticea.html#CC4'>latticea</span></td></tr>
<tr><td>
cluster  non  empty   initial   join-closed   max-ideal   ->  maximal   for    Element of K19( the carrier of L);
</td><td><span data-href='latticea.html#CC5'>latticea</span></td></tr>
<tr><td>
cluster  non  empty   initial   join-closed   maximal   ->  proper   for    Element of K19( the carrier of L);
</td><td><span data-href='latticea.html#CC6'>latticea</span></td></tr>
<tr><td>
cluster  non  empty   final   meet-closed   maximal   ->  prime   for    Element of K19( the carrier of L);
</td><td><span data-href='latticea.html#CC7'>latticea</span></td></tr>
<tr><td>
cluster  non  empty   initial   join-closed   maximal   ->  prime   for    Element of K19( the carrier of L);
</td><td><span data-href='latticea.html#CC8'>latticea</span></td></tr>
<tr><td>
cluster  non  empty   initial   final   for   M3( bool  the carrier of L);
</td><td><span data-href='lattices.html#RC14'>lattices</span></td></tr>
<tr><td>
cluster  empty   ->  initial   final   for   M3( bool  the carrier of L);
</td><td><span data-href='lattices.html#CC8'>lattices</span></td></tr>
<tr><td>
cluster  initial   ->  meet-closed   for   M3( bool  the carrier of L);
</td><td><span data-href='lattices.html#CC9'>lattices</span></td></tr>
<tr><td>
cluster  final   ->  join-closed   for   M3( bool  the carrier of L);
</td><td><span data-href='lattices.html#CC10'>lattices</span></td></tr>
<tr><td>
cluster  non  empty   finite   with_finite-elements   for    Element of  bool (bool NAT);
</td><td><span data-href='lexbfs.html#RC1'>lexbfs</span></td></tr>
<tr><td>
cluster [.0,1.] -valued   Function-like   quasi_total   ->  real-valued   for    Element of  bool [:X,REAL:];
</td><td><span data-href='lfuzzy_1.html#CC1'>lfuzzy_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [:X,X:] -defined   REAL  -valued  [.0,1.] -valued   Function-like   total   quasi_total   complex-valued   ext-real-valued   real-valued   reflexive   symmetric   transitive   antisymmetric   for    Element of  bool [:[:X,X:],REAL:];
</td><td><span data-href='lfuzzy_1.html#RC1'>lfuzzy_1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   NAT  -valued   REAL  -valued   INT  -valued   non  empty   Function-like  V28( omega ) V32( omega , REAL ) V39() V40() V41()  for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#RC1'>liouvil1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   NAT  -valued   REAL  -valued   non  empty   Function-like  V28( omega ) V32( omega , REAL ) V39() V40() V41()  positive-yielding   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#RC2'>liouvil1</span></td></tr>
<tr><td>
cluster  Function-like  V32( omega , REAL )  eventually-nonzero   ->  eventually-non-zero   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#CC1'>liouvil1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   non  empty   Function-like  V28( omega ) V32( omega , REAL ) V39() V40() V41()  eventually-non-zero   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#RC3'>liouvil1</span></td></tr>
<tr><td>
cluster  non-zero   Function-like   constant  V32( omega , REAL )  ->  eventually-non-zero   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#CC2'>liouvil1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   non  empty   Function-like  V28( omega ) V32( omega , REAL ) V39() V40() V41()  nonnegative-yielding   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#RC4'>liouvil1</span></td></tr>
<tr><td>
cluster  Function-like  V44( NAT , the carrier of L)  finite-Support   monic   ->  non-zero   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='liouvil2.html#CC2'>liouvil2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   INT  -valued   the carrier of F_Complex -valued   Function-like  V44( NAT , the carrier of F_Complex)  complex-valued   finite-Support   monic   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='liouvil2.html#RC3'>liouvil2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   RAT  -valued   the carrier of F_Complex -valued   Function-like  V44( NAT , the carrier of F_Complex)  complex-valued   finite-Support   monic   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='liouvil2.html#RC4'>liouvil2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   the carrier of F_Complex -valued   Function-like  V44( NAT , the carrier of F_Complex)  complex-valued   finite-Support   monic   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='liouvil2.html#RC5'>liouvil2</span></td></tr>
<tr><td>
cluster  Function-like  V44( NAT , the carrier of L)  finite-Support   non-zero   ->  non  zero   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='liouvil2.html#CC3'>liouvil2</span></td></tr>
<tr><td>
cluster  Function-like  V44( NAT , the carrier of L)  finite-Support   zero   ->  non  non-zero   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='liouvil2.html#CC4'>liouvil2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (product X) -defined   the carrier of Y -valued   Function-like   non  empty   total   quasi_total   Multilinear   for    Element of K19(K20( the carrier of (product X), the carrier of Y));
</td><td><span data-href='lopban10.html#RC1'>lopban10</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (product X) -defined   the carrier of Y -valued   Function-like   non  empty   total   quasi_total   Multilinear   for    Element of K19(K20( the carrier of (product X), the carrier of Y));
</td><td><span data-href='lopban10.html#RC2'>lopban10</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (product X) -defined   the carrier of Y -valued   Function-like   non  empty   total   quasi_total   Multilinear   Lipschitzian   for    Element of K19(K20( the carrier of (product X), the carrier of Y));
</td><td><span data-href='lopban10.html#RC3'>lopban10</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:X,Y:] -defined   the carrier of (product <*X,Y*>) -valued   Function-like  V11() V14( the carrier of [:X,Y:])  quasi_total   bijective  V166([:X,Y:], product <*X,Y*>) V167([:X,Y:], product <*X,Y*>)  for    Element of K19(K20( the carrier of [:X,Y:], the carrier of (product <*X,Y*>)));
</td><td><span data-href='lopban12.html#RC1'>lopban12</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (product <*X,Y*>) -defined   the carrier of [:X,Y:] -valued   Function-like  V11() V14( the carrier of (product <*X,Y*>))  quasi_total   bijective  V166( product <*X,Y*>,[:X,Y:]) V167( product <*X,Y*>,[:X,Y:])  for    Element of K19(K20( the carrier of (product <*X,Y*>), the carrier of [:X,Y:]));
</td><td><span data-href='lopban12.html#RC2'>lopban12</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of X -defined   the carrier of Y -valued   Function-like   total   quasi_total   additive   homogeneous   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='lopban_1.html#RC1'>lopban_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of X -defined   the carrier of Y -valued   Function-like   total   quasi_total   additive   homogeneous   Lipschitzian   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='lopban_1.html#RC2'>lopban_1</span></td></tr>
<tr><td>
cluster V4()  Relation-like   NAT  -defined   the carrier of X -valued   Function-like  V32( NAT ) V33( NAT , the carrier of X)  summable   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='lopban_3.html#RC1'>lopban_3</span></td></tr>
<tr><td>
cluster V4()  Relation-like   NAT  -defined   the carrier of X -valued   Function-like  V32( NAT ) V33( NAT , the carrier of X)  norm_summable   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='lopban_3.html#RC2'>lopban_3</span></td></tr>
<tr><td>
cluster  Function-like  V33( NAT , the carrier of X)  summable   ->  convergent   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='lopban_3.html#CC1'>lopban_3</span></td></tr>
<tr><td>
cluster  Function-like  V33( NAT , the carrier of X)  norm_summable   ->  summable   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='lopban_3.html#CC2'>lopban_3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   homogeneous   closed   ->  Lipschitzian   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='lopban_7.html#CC1'>lopban_7</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of E, the carrier of F:] -defined   the carrier of G -valued   Function-like   total   quasi_total   Bilinear   for    Element of  bool [:[: the carrier of E, the carrier of F:], the carrier of G:];
</td><td><span data-href='lopban_8.html#RC1'>lopban_8</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:E,F:] -defined   the carrier of G -valued   non  empty   Function-like   total   quasi_total   Bilinear   for    Element of  bool [: the carrier of [:E,F:], the carrier of G:];
</td><td><span data-href='lopban_8.html#RC2'>lopban_8</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:E,F:] -defined   the carrier of G -valued   non  empty   Function-like   total   quasi_total   Bilinear   for    Element of  bool [: the carrier of [:E,F:], the carrier of G:];
</td><td><span data-href='lopban_8.html#RC3'>lopban_8</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:X,Y:] -defined   the carrier of Z -valued   non  empty   Function-like  V28( the carrier of [:X,Y:])  quasi_total   Bilinear   Lipschitzian   for    Element of  bool [: the carrier of [:X,Y:], the carrier of Z:];
</td><td><span data-href='lopban_9.html#RC1'>lopban_9</span></td></tr>
<tr><td>
cluster  non  empty   add-closed   multi-closed   for    Element of  bool  the carrier of V;
</td><td><span data-href='lpspacc1.html#RC1'>lpspacc1</span></td></tr>
<tr><td>
cluster  non  empty   add-closed   multi-closed   for    Element of  bool  the carrier of V;
</td><td><span data-href='lpspace1.html#RC1'>lpspace1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  boolean-valued   for    Element of  bool [:A,BOOLEAN:];
</td><td><span data-href='margrel1.html#CC3'>margrel1</span></td></tr>
<tr><td>
cluster  Relation-like  A *  -defined  A -valued   Function-like   non  empty   homogeneous   quasi_total   for    Element of  bool [:(A *),A:];
</td><td><span data-href='margrel1.html#RC3'>margrel1</span></td></tr>
<tr><td>
cluster  Relation-like   Seg (n + 2) -defined   Seg (n + 2) -valued   Function-like   one-to-one   non  empty   total   quasi_total   onto   bijective   finite   odd   for    Element of  bool [:(Seg (n + 2)),(Seg (n + 2)):];
</td><td><span data-href='matrix11.html#RC2'>matrix11</span></td></tr>
<tr><td>
cluster  empty   finite   without_zero   for    Element of  bool NAT;
</td><td><span data-href='matrix13.html#RC1'>matrix13</span></td></tr>
<tr><td>
cluster  non  empty   finite   without_zero   for    Element of  bool NAT;
</td><td><span data-href='matrix13.html#RC2'>matrix13</span></td></tr>
<tr><td>
cluster  Relation-like   Seg n -defined   Seg n -valued   Function-like   one-to-one   total   quasi_total   finite   FinSequence-like   for    Element of  bool [:(Seg n),(Seg n):];
</td><td><span data-href='matrix_9.html#RC2'>matrix_9</span></td></tr>
<tr><td>
cluster  Relation-like   Seg 2 -defined   Seg 2 -valued   Function-like   one-to-one   non  empty   total   quasi_total   onto   bijective   finite   odd   for    Element of  bool [:(Seg 2),(Seg 2):];
</td><td><span data-href='matrix_9.html#RC3'>matrix_9</span></td></tr>
<tr><td>
cluster  Relation-like   Seg n -defined   Seg n -valued   Function-like   one-to-one   total   quasi_total   onto   bijective   finite   even   for    Element of  bool [:(Seg n),(Seg n):];
</td><td><span data-href='matrix_9.html#RC4'>matrix_9</span></td></tr>
<tr><td>
cluster  Relation-like   Seg 3 -defined   Seg 3 -valued   Function-like   one-to-one   non  empty   total   quasi_total   onto   bijective   finite   odd   for    Element of  bool [:(Seg 3),(Seg 3):];
</td><td><span data-href='matrix_9.html#RC5'>matrix_9</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of V -valued   Function-like   non  empty   total  V18( the carrier of V, the carrier of V)  nilpotent   for    Element of  bool [: the carrier of V, the carrier of V:];
</td><td><span data-href='matrixj2.html#RC4'>matrixj2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of V -valued   Function-like   non  empty   total  V18( the carrier of V, the carrier of V)  additive   homogeneous   nilpotent   for    Element of  bool [: the carrier of V, the carrier of V:];
</td><td><span data-href='matrixj2.html#RC5'>matrixj2</span></td></tr>
<tr><td>
cluster  independent   for    Element of K19( the carrier of M);
</td><td><span data-href='matroid0.html#RC2'>matroid0</span></td></tr>
<tr><td>
cluster  finite   independent   for    Element of K19( the carrier of M);
</td><td><span data-href='matroid0.html#RC3'>matroid0</span></td></tr>
<tr><td>
cluster  empty   ->  independent   for    Element of K19( the carrier of M);
</td><td><span data-href='matroid0.html#CC1'>matroid0</span></td></tr>
<tr><td>
cluster  independent   ->  finite   independent   for    Element of K19( the carrier of M);
</td><td><span data-href='matroid0.html#CC6'>matroid0</span></td></tr>
<tr><td>
cluster  cycle   ->  non  empty   finite   for    Element of K19( the carrier of M);
</td><td><span data-href='matroid0.html#CC7'>matroid0</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (TOP-REAL n) -defined   the carrier of (TOP-REAL n) -valued   non  empty   Function-like   total   quasi_total   homogeneous   for    Element of  bool [: the carrier of (TOP-REAL n), the carrier of (TOP-REAL n):];
</td><td><span data-href='matrtop3.html#RC2'>matrtop3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  FinSequence-yielding   for    Element of  bool [: the carrier of (TOP-REAL n), the carrier of (TOP-REAL m):];
</td><td><span data-href='matrtop3.html#CC3'>matrtop3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (TOP-REAL n) -defined   the carrier of (TOP-REAL n) -valued   non  empty   Function-like   total   quasi_total   Function-yielding  V196()  FinSequence-yielding   base_rotation   for    Element of  bool [: the carrier of (TOP-REAL n), the carrier of (TOP-REAL n):];
</td><td><span data-href='matrtop3.html#RC3'>matrtop3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   base_rotation   ->  additive   homogeneous   being_homeomorphism   rotation   for    Element of  bool [: the carrier of (TOP-REAL n), the carrier of (TOP-REAL n):];
</td><td><span data-href='matrtop3.html#CC4'>matrtop3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   homogeneous   rotation   ->  being_homeomorphism   for    Element of  bool [: the carrier of (TOP-REAL n), the carrier of (TOP-REAL n):];
</td><td><span data-href='matrtop3.html#CC5'>matrtop3</span></td></tr>
<tr><td>
cluster  non  empty  V4() V7( the carrier of E) V8( the carrier of E)  Function-like   total   quasi_total   bijective   isometric   Affine   midpoints-preserving   for    Element of K10(K11( the carrier of E, the carrier of E));
</td><td><span data-href='mazurulm.html#RC1'>mazurulm</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   bijective   isometric   ->  midpoints-preserving   for    Element of K10(K11( the carrier of E, the carrier of F));
</td><td><span data-href='mazurulm.html#CC1'>mazurulm</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   isometric   midpoints-preserving   ->  Affine   for    Element of K10(K11( the carrier of E, the carrier of F));
</td><td><span data-href='mazurulm.html#CC2'>mazurulm</span></td></tr>
<tr><td>
cluster  cup-closed   compl-closed   ->  cap-closed   for    Element of  bool (bool X);
</td><td><span data-href='measure1.html#CC1'>measure1</span></td></tr>
<tr><td>
cluster  cap-closed   compl-closed   ->  cup-closed   for    Element of  bool (bool X);
</td><td><span data-href='measure1.html#CC2'>measure1</span></td></tr>
<tr><td>
cluster  cap-closed   compl-closed   ->  diff-closed   for    Element of  bool (bool X);
</td><td><span data-href='measure1.html#CC3'>measure1</span></td></tr>
<tr><td>
cluster  Relation-like  S -defined   ExtREAL  -valued   Function-like   non  empty  V14(S) V18(S, ExtREAL )  ext-real-valued   zeroed  V94()  additive   for    Element of  bool [:S,ExtREAL:];
</td><td><span data-href='measure1.html#RC1'>measure1</span></td></tr>
<tr><td>
cluster  non  empty   cap-closed   compl-closed   for    Element of  bool (bool X);
</td><td><span data-href='measure1.html#RC2'>measure1</span></td></tr>
<tr><td>
cluster  non  empty  V58()  for    Element of  bool (bool X);
</td><td><span data-href='measure1.html#RC3'>measure1</span></td></tr>
<tr><td>
cluster  non  empty   compl-closed   sigma-additive   for    Element of  bool (bool X);
</td><td><span data-href='measure1.html#RC4'>measure1</span></td></tr>
<tr><td>
cluster  compl-closed   sigma-multiplicative   ->  sigma-additive   for    Element of  bool (bool X);
</td><td><span data-href='measure1.html#CC4'>measure1</span></td></tr>
<tr><td>
cluster  compl-closed   sigma-additive   ->  sigma-multiplicative   for    Element of  bool (bool X);
</td><td><span data-href='measure1.html#CC5'>measure1</span></td></tr>
<tr><td>
cluster  non  empty   compl-closed   sigma-multiplicative   ->   for    Element of  bool (bool X);
</td><td><span data-href='measure1.html#CC6'>measure1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined  S -valued   Function-like   non  empty  V14( NAT ) V18( NAT ,S)  disjoint_valued   for    Element of  bool [:NAT,S:];
</td><td><span data-href='measure1.html#RC5'>measure1</span></td></tr>
<tr><td>
cluster  Relation-like  S -defined   ExtREAL  -valued   Function-like   non  empty  V14(S) V18(S, ExtREAL )  ext-real-valued   zeroed  V94()  sigma-additive   for    Element of  bool [:S,ExtREAL:];
</td><td><span data-href='measure1.html#RC6'>measure1</span></td></tr>
<tr><td>
cluster  non  empty   compl-closed   sigma-additive   ->  non  empty   cup-closed   for    Element of  bool (bool X);
</td><td><span data-href='measure1.html#CC7'>measure1</span></td></tr>
<tr><td>
cluster  Function-like  V18(S, ExtREAL )  zeroed  V94()  sigma-additive   ->  zeroed  V94()  additive   for    Element of  bool [:S,ExtREAL:];
</td><td><span data-href='measure1.html#CC8'>measure1</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   open_interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#RC1'>measure5</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   closed_interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#RC2'>measure5</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   right_open_interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#RC3'>measure5</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   left_open_interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#RC4'>measure5</span></td></tr>
<tr><td>
cluster  open_interval   ->  interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#CC1'>measure5</span></td></tr>
<tr><td>
cluster  closed_interval   ->  interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#CC2'>measure5</span></td></tr>
<tr><td>
cluster  right_open_interval   ->  interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#CC3'>measure5</span></td></tr>
<tr><td>
cluster  left_open_interval   ->  interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#CC4'>measure5</span></td></tr>
<tr><td>
cluster  empty   ->  open_interval   for    Element of K32(REAL);
</td><td><span data-href='measure5.html#CC5'>measure5</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   interval   for    Element of  bool REAL;
</td><td><span data-href='measure6.html#RC1'>measure6</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   without_zero   for    Element of  bool REAL;
</td><td><span data-href='measure6.html#RC4'>measure6</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   with_zero   for    Element of  bool REAL;
</td><td><span data-href='measure6.html#RC5'>measure6</span></td></tr>
<tr><td>
cluster  c=-linear   non  empty   with_non-empty_elements   ->  centered   for    Element of  bool (bool F);
</td><td><span data-href='measure6.html#CC1'>measure6</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   real-bounded   closed   for    Element of  bool REAL;
</td><td><span data-href='measure6.html#RC6'>measure6</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   omega  -defined  F -valued   Function-like  V30( omega )  quasi_total   disjoint_valued   for    Element of  bool [:omega,F:];
</td><td><span data-href='measure8.html#RC1'>measure8</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined  P -valued   non  empty   Function-like   total  V31( omega ,P)  disjoint_valued   for    Element of  bool [:omega,P:];
</td><td><span data-href='measure9.html#RC2'>measure9</span></td></tr>
<tr><td>
cluster  Relation-like  P -defined   ExtREAL  -valued   non  empty   Function-like   total  V31(P, ExtREAL )  ext-real-valued   zeroed  V224()  additive   for    Element of  bool [:P,ExtREAL:];
</td><td><span data-href='measure9.html#RC3'>measure9</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined  P -valued   non  empty   Function-like   total  V31( NAT ,P)  disjoint_valued   for    Element of  bool [:NAT,P:];
</td><td><span data-href='measure9.html#RC4'>measure9</span></td></tr>
<tr><td>
cluster   ->  complex-membered   for    Element of K18(X);
</td><td><span data-href='membered.html#CC13'>membered</span></td></tr>
<tr><td>
cluster   ->  ext-real-membered   for    Element of K18(X);
</td><td><span data-href='membered.html#CC14'>membered</span></td></tr>
<tr><td>
cluster   ->  real-membered   for    Element of K18(X);
</td><td><span data-href='membered.html#CC15'>membered</span></td></tr>
<tr><td>
cluster   ->  rational-membered   for    Element of K18(X);
</td><td><span data-href='membered.html#CC16'>membered</span></td></tr>
<tr><td>
cluster   ->  integer-membered   for    Element of K18(X);
</td><td><span data-href='membered.html#CC17'>membered</span></td></tr>
<tr><td>
cluster   ->  natural-membered   for    Element of K18(X);
</td><td><span data-href='membered.html#CC18'>membered</span></td></tr>
<tr><td>
cluster  Relation-like   FinPartSt S -defined   FinPartSt S -valued   Function-like   Function-yielding  V38()  data-only   for    Element of K10(K11((FinPartSt S),(FinPartSt S)));
</td><td><span data-href='memstr_0.html#RC9'>memstr_0</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   REAL  -valued   Function-like  V54() V55() V56()  nonnegative   for    Element of K16(K17(X,REAL));
</td><td><span data-href='mesfun6c.html#RC1'>mesfun6c</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   ExtREAL  -valued   Function-like  V69() E -measurable   for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='mesfun13.html#RC1'>mesfun13</span></td></tr>
<tr><td>
cluster  Function-like   nonnegative   -> ()  for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='mesfunc5.html#CC1'>mesfunc5</span></td></tr>
<tr><td>
cluster  Function-like   nonpositive   -> ()  for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='mesfunc5.html#CC2'>mesfunc5</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   ExtREAL  -valued   Function-like   extreal-yielding   nonnegative   for    Element of K16(K17(X,ExtREAL));
</td><td><span data-href='mesfunc7.html#RC1'>mesfunc7</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   PFuncs (X,Y) -valued   non  empty   Function-like   total  V32( NAT , PFuncs (X,Y))  with_the_same_dom   for    Element of  bool [:NAT,(PFuncs (X,Y)):];
</td><td><span data-href='mesfunc8.html#RC1'>mesfunc8</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   PFuncs (X,ExtREAL) -valued   non  empty   Function-like   total   quasi_total   with_the_same_dom   additive   for    Element of  bool [:NAT,(PFuncs (X,ExtREAL)):];
</td><td><span data-href='mesfunc9.html#RC1'>mesfunc9</span></td></tr>
<tr><td>
cluster  Function-like   constant  V33( NAT , the carrier of M)  ->  convergent   for    Element of  bool [:NAT, the carrier of M:];
</td><td><span data-href='metric_6.html#CC1'>metric_6</span></td></tr>
<tr><td>
cluster  Function-like  V33( NAT , the carrier of M)  Cauchy   ->  bounded   for    Element of  bool [:NAT, the carrier of M:];
</td><td><span data-href='metric_6.html#CC2'>metric_6</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   NAT  -defined   the carrier of M -valued   Function-like   constant  V32( NAT ) V33( NAT , the carrier of M)  convergent   Cauchy   bounded   for    Element of  bool [:NAT, the carrier of M:];
</td><td><span data-href='metric_6.html#RC1'>metric_6</span></td></tr>
<tr><td>
cluster  open   ->  F_sigma   for    Element of  bool  the carrier of TM;
</td><td><span data-href='metrizts.html#CC3'>metrizts</span></td></tr>
<tr><td>
cluster  closed   ->  G_delta   for    Element of  bool  the carrier of TM;
</td><td><span data-href='metrizts.html#CC4'>metrizts</span></td></tr>
<tr><td>
cluster  functional   ball   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='mfold_1.html#RC1'>mfold_1</span></td></tr>
<tr><td>
cluster  ball   ->  open   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='mfold_1.html#CC1'>mfold_1</span></td></tr>
<tr><td>
cluster  non  empty   functional   ball   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='mfold_1.html#RC2'>mfold_1</span></td></tr>
<tr><td>
cluster  connected   transitive   total   ->  beta-transitive   for    Element of  bool [:X,X:];
</td><td><span data-href='mmlquer2.html#CC1'>mmlquer2</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   reflexive   antisymmetric   connected   transitive   total   for    Element of  bool [:X,X:];
</td><td><span data-href='mmlquer2.html#RC1'>mmlquer2</span></td></tr>
<tr><td>
cluster  empty   Relation-like  X -defined  X -valued   for    Element of  bool [:X,X:];
</td><td><span data-href='mmlquer2.html#RC2'>mmlquer2</span></td></tr>
<tr><td>
cluster  reflexive   antisymmetric   transitive   total   ->  well_founded   for    Element of  bool [:X,X:];
</td><td><span data-href='mmlquer2.html#CC3'>mmlquer2</span></td></tr>
<tr><td>
cluster  reflexive   antisymmetric   connected   transitive   total   ->  connected   well-ordering   for    Element of  bool [:X,X:];
</td><td><span data-href='mmlquer2.html#CC4'>mmlquer2</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   filtering   for    Element of  bool [:X,X:];
</td><td><span data-href='mmlquery.html#RC1'>mmlquery</span></td></tr>
<tr><td>
cluster  base   for    Element of  bool  the carrier of V;
</td><td><span data-href='mod_3.html#RC2'>mod_3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   antilinear   ->  additive   unity-preserving   antimultiplicative   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC1'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   unity-preserving   antimultiplicative   ->  antilinear   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC2'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   monomorphism   ->  one-to-one   linear   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC3'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   one-to-one   quasi_total   linear   ->  monomorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC4'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   antimonomorphism   ->  one-to-one   antilinear   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC5'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   one-to-one   quasi_total   antilinear   ->  antimonomorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC6'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   epimorphism   ->  onto   linear   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC7'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   onto   linear   ->  epimorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC8'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   antiepimorphism   ->  onto   antilinear   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC9'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   onto   antilinear   ->  antiepimorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC10'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   isomorphism   ->  onto   monomorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC11'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   onto   monomorphism   ->  isomorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC12'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   antiisomorphism   ->  onto   antimonomorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC13'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   onto   antimonomorphism   ->  antiisomorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC14'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   endomorphism   ->  linear   for    Element of  bool [: the carrier of K, the carrier of K:];
</td><td><span data-href='mod_4.html#CC15'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   linear   ->  endomorphism   for    Element of  bool [: the carrier of K, the carrier of K:];
</td><td><span data-href='mod_4.html#CC16'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   antiendomorphism   ->  antilinear   for    Element of  bool [: the carrier of K, the carrier of K:];
</td><td><span data-href='mod_4.html#CC17'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   antilinear   ->  antiendomorphism   for    Element of  bool [: the carrier of K, the carrier of K:];
</td><td><span data-href='mod_4.html#CC18'>mod_4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of G -defined   the carrier of G -valued   Function-like  V17( the carrier of G)  quasi_total   bijective   additive   for    Element of  bool [: the carrier of G, the carrier of G:];
</td><td><span data-href='mod_4.html#RC1'>mod_4</span></td></tr>
<tr><td>
cluster  Relation-like  A -defined   NAT  -valued   Function-like   one-to-one  V18(A, NAT )  for    Element of  bool [:A,NAT:];
</td><td><span data-href='msafree4.html#RC4'>msafree4</span></td></tr>
<tr><td>
cluster  discrete   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='nagata_1.html#RC1'>nagata_1</span></td></tr>
<tr><td>
cluster  empty   discrete   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='nagata_1.html#RC2'>nagata_1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   bool (bool  the carrier of T) -valued   Function-like   non  empty  V14( omega )  quasi_total   sigma_discrete   for    Element of  bool [:omega,(bool (bool  the carrier of T)):];
</td><td><span data-href='nagata_1.html#RC3'>nagata_1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   bool (bool  the carrier of T) -valued   Function-like   non  empty  V14( omega )  quasi_total   sigma_locally_finite   for    Element of  bool [:omega,(bool (bool  the carrier of T)):];
</td><td><span data-href='nagata_1.html#RC4'>nagata_1</span></td></tr>
<tr><td>
cluster  non  empty   ordinal   for    Element of  bool REAL;
</td><td><span data-href='nat_1.html#RC4'>nat_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of M -defined   the carrier of M -valued   non  empty   Function-like   total   quasi_total   contraction   for    Element of K16(K17( the carrier of M, the carrier of M));
</td><td><span data-href='ncfcont2.html#RC1'>ncfcont2</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of S) V6()  Function-like   total   quasi_total   non-zero   0. S -convergent   for    Element of K16(K17(NAT, the carrier of S));
</td><td><span data-href='ndiff_1.html#RC1'>ndiff_1</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of S) V6()  Function-like   total   quasi_total   0. S -convergent   for    Element of K16(K17(NAT, the carrier of S));
</td><td><span data-href='ndiff_1.html#RC2'>ndiff_1</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of S) V6()  Function-like   constant   total   quasi_total   for    Element of K16(K17(NAT, the carrier of S));
</td><td><span data-href='ndiff_1.html#RC3'>ndiff_1</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of S) V5( the carrier of T)  Function-like   RestFunc-like   for    Element of K16(K17( the carrier of S, the carrier of T));
</td><td><span data-href='ndiff_1.html#RC4'>ndiff_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( the carrier of F)  Function-like   RestFunc-like   for    Element of K16(K17(REAL, the carrier of F));
</td><td><span data-href='ndiff_3.html#RC1'>ndiff_3</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( the carrier of F) V6()  Function-like   total   quasi_total   linear   for    Element of K16(K17(REAL, the carrier of F));
</td><td><span data-href='ndiff_3.html#RC2'>ndiff_3</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( the carrier of F) V6()  Function-like   total   quasi_total   differentiable   for    Element of K16(K17(REAL, the carrier of F));
</td><td><span data-href='ndiff_3.html#RC3'>ndiff_3</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL n -valued   non  empty   Function-like   total   quasi_total   Function-yielding  V237() V238() V239()  differentiable   for    Element of K16(K17(REAL,(REAL n)));
</td><td><span data-href='ndiff_4.html#RC1'>ndiff_4</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:X,Y:] -defined   the carrier of (product <*X,Y*>) -valued   non  empty   Function-like   one-to-one   total   quasi_total   onto  V152([:X,Y:], product <*X,Y*>) V153([:X,Y:], product <*X,Y*>)  isometric   for    Element of  bool [: the carrier of [:X,Y:], the carrier of (product <*X,Y*>):];
</td><td><span data-href='ndiff_7.html#RC1'>ndiff_7</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (product <*X,Y*>) -defined   the carrier of [:X,Y:] -valued   non  empty   Function-like   one-to-one   total   quasi_total   onto  V152( product <*X,Y*>,[:X,Y:]) V153( product <*X,Y*>,[:X,Y:])  isometric   for    Element of  bool [: the carrier of (product <*X,Y*>), the carrier of [:X,Y:]:];
</td><td><span data-href='ndiff_7.html#RC2'>ndiff_7</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total  V152(S,T) V153(S,T)  isometric   ->  Lipschitzian   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='ndiff_7.html#CC1'>ndiff_7</span></td></tr>
<tr><td>
cluster   ->  trivial   for    Element of  bool [:X,Y:];
</td><td><span data-href='neckla_3.html#CC1'>neckla_3</span></td></tr>
<tr><td>
cluster   ->  trivial   reflexive   symmetric   strongly_connected   transitive   for    Element of  bool [:X,X:];
</td><td><span data-href='neckla_3.html#CC2'>neckla_3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of M -defined   the carrier of M -valued   non  empty   Function-like   total   quasi_total   contraction   for    Element of K16(K17( the carrier of M, the carrier of M));
</td><td><span data-href='nfcont_2.html#RC1'>nfcont_2</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  continuous   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC1'>nfcont_3</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   the carrier of S -valued   Function-like   continuous   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#RC1'>nfcont_3</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  continuous   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC2'>nfcont_3</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  Lipschitzian   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC3'>nfcont_3</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   the carrier of S -valued   empty   Function-like   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#RC2'>nfcont_3</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  Lipschitzian   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC4'>nfcont_3</span></td></tr>
<tr><td>
cluster  Function-like   Lipschitzian   ->  continuous   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC5'>nfcont_3</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC1'>nfcont_4</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL n -valued   Function-like  V158() V231() V232() V233()  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#RC1'>nfcont_4</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC2'>nfcont_4</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  Lipschitzian   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC3'>nfcont_4</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL n -valued   empty   Function-like  V158() V231() V232() V233()  for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#RC2'>nfcont_4</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  Lipschitzian   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC4'>nfcont_4</span></td></tr>
<tr><td>
cluster  Function-like   Lipschitzian   ->  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC5'>nfcont_4</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   INT  -valued   the carrier of F_Real -valued   Function-like   non  empty   total  V18( NAT , the carrier of F_Real)  complex-valued   ext-real-valued   real-valued   finite-Support   monic   for    Element of K19(K20(NAT, the carrier of F_Real));
</td><td><span data-href='niven.html#RC2'>niven</span></td></tr>
<tr><td>
cluster  Relation-like  V -defined  A -valued   Function-like   finite   for    Element of  bool [:V,A:];
</td><td><span data-href='nomin_1.html#RC1'>nomin_1</span></td></tr>
<tr><td>
cluster  closed   open   for    Element of  bool  the carrier of X;
</td><td><span data-href='normsp_3.html#RC1'>normsp_3</span></td></tr>
<tr><td>
cluster  closed   open   dense   for    Element of  bool  the carrier of X;
</td><td><span data-href='normsp_3.html#RC2'>normsp_3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   homogeneous   isomorphism   ->  one-to-one   onto   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='normsp_3.html#CC1'>normsp_3</span></td></tr>
<tr><td>
cluster  Function-like   one-to-one   quasi_total   onto   additive   homogeneous   ->  isomorphism   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='normsp_3.html#CC2'>normsp_3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   homogeneous   isomorphism   ->  one-to-one   onto   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='normsp_3.html#CC3'>normsp_3</span></td></tr>
<tr><td>
cluster  Relation-like   irreflexive   asymmetric   transitive   for    Element of K19(([#] (X,X)));
</td><td><span data-href='oposet_1.html#RC1'>oposet_1</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like  V14(O) V18(O,O)  involutive   for    Element of K19(([#] (O,O)));
</td><td><span data-href='oposet_1.html#RC3'>oposet_1</span></td></tr>
<tr><td>
cluster  Function-like  V22()  quasi_total   ->  contraction   for    Element of K16(K17( the carrier of X, the carrier of X));
</td><td><span data-href='ordeq_01.html#CC1'>ordeq_01</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   contraction   ->  with_unique_fixpoint   for    Element of K16(K17( the carrier of X, the carrier of X));
</td><td><span data-href='ordeq_01.html#CC2'>ordeq_01</span></td></tr>
<tr><td>
cluster  closed   for    Element of K16( the carrier of (R_NormSpace_of_BoundedFunctions (X,Y)));
</td><td><span data-href='ordeq_01.html#RC1'>ordeq_01</span></td></tr>
<tr><td>
cluster  empty   ->  strongly_connected   for    Element of  bool  the carrier of A;
</td><td><span data-href='orders_2.html#CC2'>orders_2</span></td></tr>
<tr><td>
cluster  strongly_connected   for    Element of  bool  the carrier of A;
</td><td><span data-href='orders_2.html#RC3'>orders_2</span></td></tr>
<tr><td>
cluster  finite   for    Element of K16(X);
</td><td><span data-href='orders_5.html#RC1'>orders_5</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   REAL  -valued   Function-like   total   quasi_total  V53() V54() V55()  nonnegative-yielding   finite-support   for    Element of K16(K17(X,REAL));
</td><td><span data-href='orders_5.html#RC3'>orders_5</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   COMPLEX  -valued   Function-like   total   quasi_total  V53()  nonnegative-yielding   finite-support   for    Element of K16(K17(X,COMPLEX));
</td><td><span data-href='orders_5.html#RC4'>orders_5</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of A -defined   the carrier of A -valued   total   quasi_total   reflexive   symmetric   transitive   EqRelOf-like   for    Element of K16(K17( the carrier of A, the carrier of A));
</td><td><span data-href='orders_5.html#RC7'>orders_5</span></td></tr>
<tr><td>
cluster   ->  c=-linear   for    Element of  bool X;
</td><td><span data-href='ordinal1.html#CC10'>ordinal1</span></td></tr>
<tr><td>
cluster  Function-like  V28( On W, On W)  ->  Sequence-like   Ordinal-yielding   for    Element of  bool [:(On W),(On W):];
</td><td><span data-href='ordinal4.html#CC1'>ordinal4</span></td></tr>
<tr><td>
cluster  Relation-like   On U -defined   On U -valued   Function-like   Sequence-like   non  empty  V28( On U) V32( On U, On U)  Ordinal-yielding   normal   for    Element of  bool [:(On U),(On U):];
</td><td><span data-href='ordinal6.html#RC4'>ordinal6</span></td></tr>
<tr><td>
cluster  Function-like  V32(a, On U)  ->  Sequence-like   Ordinal-yielding   for    Element of  bool [:a,(On U):];
</td><td><span data-href='ordinal6.html#CC6'>ordinal6</span></td></tr>
<tr><td>
cluster  Function-like  V32(a,b)  ->  Sequence-like   Ordinal-yielding   for    Element of  bool [:a,b:];
</td><td><span data-href='ordinal6.html#CC7'>ordinal6</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  Y -valued   Function-like   for    Element of  bool [:X,Y:];
</td><td><span data-href='partfun1.html#RC1'>partfun1</span></td></tr>
<tr><td>
cluster   ->  total   for    Element of  bool [:X,Y:];
</td><td><span data-href='partfun1.html#CC1'>partfun1</span></td></tr>
<tr><td>
cluster   ->  non  total   for    Element of  bool [:X,Y:];
</td><td><span data-href='partfun1.html#CC2'>partfun1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   reflexive   symmetric   antisymmetric   transitive   total   for    Element of  bool [:X,X:];
</td><td><span data-href='partfun1.html#RC2'>partfun1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  Y -valued   Function-like   non  empty   for    Element of  bool [:X,Y:];
</td><td><span data-href='partfun1.html#RC3'>partfun1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   REAL  -valued   Function-like   total  V36(X, REAL )  complex-valued   ext-real-valued   real-valued   negative-yielding   for    Element of K16(K17(X,REAL));
</td><td><span data-href='partfun3.html#RC1'>partfun3</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   REAL  -valued   Function-like   total  V36(X, REAL )  complex-valued   ext-real-valued   real-valued   positive-yielding   for    Element of K16(K17(X,REAL));
</td><td><span data-href='partfun3.html#RC2'>partfun3</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of T) V5( REAL )  non  empty   Function-like  V32( the carrier of T) V36( the carrier of T, REAL ) V145() V146() V147()  continuous   positive-yielding   for    Element of K16(K17( the carrier of T,REAL));
</td><td><span data-href='partfun4.html#RC1'>partfun4</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of T) V5( REAL )  non  empty   Function-like  V32( the carrier of T) V36( the carrier of T, REAL ) V145() V146() V147()  continuous   negative-yielding   for    Element of K16(K17( the carrier of T,REAL));
</td><td><span data-href='partfun4.html#RC2'>partfun4</span></td></tr>
<tr><td>
cluster  empty   ->  pcs-self-coherent   for    Element of  bool  the carrier of P;
</td><td><span data-href='pcs_0.html#CC14'>pcs_0</span></td></tr>
<tr><td>
cluster  non  empty   pcs-self-coherent-membered   for    Element of  bool (bool  the carrier of P);
</td><td><span data-href='pcs_0.html#RC16'>pcs_0</span></td></tr>
<tr><td>
cluster  pcs-self-coherent   for    Element of  bool  the carrier of P;
</td><td><span data-href='pcs_0.html#RC17'>pcs_0</span></td></tr>
<tr><td>
cluster  Function-like   RestFunc-like   ->  total   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='pdiff_3.html#CC1'>pdiff_3</span></td></tr>
<tr><td>
cluster  Relation-like   REAL m -defined   REAL n -valued   non  empty   Function-like   total  V30( REAL m, REAL n)  Function-yielding   complex-functions-valued   ext-real-functions-valued   real-functions-valued   additive   homogeneous   for    Element of K16(K17((REAL m),(REAL n)));
</td><td><span data-href='pdiff_6.html#RC1'>pdiff_6</span></td></tr>
<tr><td>
cluster  Function-like  V30( REAL m, REAL n)  additive   homogeneous   ->  Lipschitzian   for    Element of K16(K17((REAL m),(REAL n)));
</td><td><span data-href='pdiff_6.html#CC1'>pdiff_6</span></td></tr>
<tr><td>
cluster  Function-like  V30( the carrier of (REAL-NS m), the carrier of (REAL-NS n))  additive   homogeneous   ->  Lipschitzian   for    Element of K16(K17( the carrier of (REAL-NS m), the carrier of (REAL-NS n)));
</td><td><span data-href='pdiff_6.html#CC2'>pdiff_6</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   isomorphic   for    Element of  bool [: the carrier of S, the carrier of S:];
</td><td><span data-href='pencil_2.html#RC1'>pencil_2</span></td></tr>
<tr><td>
cluster  with_implication   with_FALSUM   with_propositional_variables   ->  PL-closed   for    Element of  bool (NAT *);
</td><td><span data-href='pl_axiom.html#CC2'>pl_axiom</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   bool X -valued   Function-like  V38()  FinSequence-like   FinSubsequence-like  V107()  for    FinSequence of  bool X;
</td><td><span data-href='polnot_1.html#RC1'>polnot_1</span></td></tr>
<tr><td>
cluster   ->  FinSequence-membered   antichain-like   for    Element of  bool B;
</td><td><span data-href='polnot_1.html#CC3'>polnot_1</span></td></tr>
<tr><td>
cluster  functional   non  empty   FinSequence-membered   antichain-like   for    Element of  bool (T *);
</td><td><span data-href='polnot_1.html#RC3'>polnot_1</span></td></tr>
<tr><td>
cluster  non  empty   antichain-like   ->  FinSequence-membered   for    Element of  bool (T *);
</td><td><span data-href='polnot_1.html#CC4'>polnot_1</span></td></tr>
<tr><td>
cluster   -> B -headed   for    Element of  bool P;
</td><td><span data-href='polnot_1.html#CC5'>polnot_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   bool X -valued   Function-like  V38()  FinSequence-like   FinSubsequence-like  V107()  non  exhaustive   for    FinSequence of  bool X;
</td><td><span data-href='polnot_1.html#RC6'>polnot_1</span></td></tr>
<tr><td>
cluster  Function-like  V28( REAL , REAL )  differentiable   ->  continuous   for    Element of K10(K11(REAL,REAL));
</td><td><span data-href='polydiff.html#CC1'>polydiff</span></td></tr>
<tr><td>
cluster  Function-like   constant  V28( REAL , REAL )  ->  differentiable   for    Element of K10(K11(REAL,REAL));
</td><td><span data-href='polydiff.html#CC2'>polydiff</span></td></tr>
<tr><td>
cluster  Relation-like   Bags n -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   finite-Support   for    Element of  bool [:(Bags n), the carrier of S:];
</td><td><span data-href='polynom1.html#RC3'>polynom1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of L -valued   Function-like   non  empty   total   quasi_total   finite-Support   with_roots   for    Element of K1(K2(NAT, the carrier of L));
</td><td><span data-href='polynom5.html#RC1'>polynom5</span></td></tr>
<tr><td>
cluster  Relation-like   Bags X -defined   the carrier of R -valued   Function-like   quasi_total   non-zero   for    Element of  bool [:(Bags X), the carrier of R:];
</td><td><span data-href='polynom7.html#RC2'>polynom7</span></td></tr>
<tr><td>
cluster  Relation-like   Bags n -defined   the carrier of R -valued   Function-like   quasi_total   finite-Support   non-zero   for    Element of  bool [:(Bags n), the carrier of R:];
</td><td><span data-href='polynom7.html#RC3'>polynom7</span></td></tr>
<tr><td>
cluster  Relation-like   Bags X -defined   the carrier of L -valued   Function-like   quasi_total   monomial-like   for    Element of  bool [:(Bags X), the carrier of L:];
</td><td><span data-href='polynom7.html#RC5'>polynom7</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   monomial-like   ->  finite-Support   for    Element of  bool [:(Bags X), the carrier of L:];
</td><td><span data-href='polynom7.html#CC2'>polynom7</span></td></tr>
<tr><td>
cluster  Relation-like   Bags X -defined   the carrier of L -valued   Function-like   quasi_total   Constant   for    Element of  bool [:(Bags X), the carrier of L:];
</td><td><span data-href='polynom7.html#RC6'>polynom7</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   Constant   ->  monomial-like   for    Element of  bool [:(Bags X), the carrier of L:];
</td><td><span data-href='polynom7.html#CC3'>polynom7</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   Bags n -defined   the carrier of R -valued   Function-like   total  V49( Bags n, the carrier of R)  non-zero   monomial-like   finite-Support   for    Element of  bool [:(Bags n), the carrier of R:];
</td><td><span data-href='polyred.html#RC1'>polyred</span></td></tr>
<tr><td>
cluster  non  empty   strongly_connected   for    Element of K19( the carrier of P);
</td><td><span data-href='poset_1.html#RC1'>poset_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of P -defined   the carrier of Q -valued   Function-like   quasi_total   continuous   for    Element of K19(K20( the carrier of P, the carrier of Q));
</td><td><span data-href='poset_1.html#RC3'>poset_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   continuous   ->  monotone   for    Element of K19(K20( the carrier of P, the carrier of Q));
</td><td><span data-href='poset_1.html#CC2'>poset_1</span></td></tr>
<tr><td>
cluster  strongly_connected   ->  finite   for    Element of  bool  the carrier of L;
</td><td><span data-href='poset_2.html#CC6'>poset_2</span></td></tr>
<tr><td>
cluster  non  empty   for    Element of  bool (Fin X);
</td><td><span data-href='pre_poly.html#RC2'>pre_poly</span></td></tr>
<tr><td>
cluster  non  empty   with_non-empty_elements   for    Element of  bool (Fin X);
</td><td><span data-href='pre_poly.html#RC3'>pre_poly</span></td></tr>
<tr><td>
cluster  with_non-empty_element   for    Element of  bool (Fin X);
</td><td><span data-href='pre_poly.html#RC5'>pre_poly</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   total   quasi_total   reflexive   antisymmetric   transitive   well-ordering   being_linear-order   for    Element of  bool [:X,X:];
</td><td><span data-href='pre_poly.html#RC9'>pre_poly</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   NAT  -valued   Function-like   total   quasi_total   complex-valued   ext-real-valued   real-valued   natural-valued   finite-support   for    Element of  bool [:X,NAT:];
</td><td><span data-href='pre_poly.html#RC13'>pre_poly</span></td></tr>
<tr><td>
cluster   ->  functional   for    Element of  bool (Bags X);
</td><td><span data-href='pre_poly.html#CC9'>pre_poly</span></td></tr>
<tr><td>
cluster  closed   for    Element of  bool  the carrier of T;
</td><td><span data-href='pre_topc.html#RC6'>pre_topc</span></td></tr>
<tr><td>
cluster  non  empty   closed   for    Element of  bool  the carrier of T;
</td><td><span data-href='pre_topc.html#RC7'>pre_topc</span></td></tr>
<tr><td>
cluster  empty   ->  closed   for    Element of  bool  the carrier of T;
</td><td><span data-href='pre_topc.html#CC2'>pre_topc</span></td></tr>
<tr><td>
cluster V7() V10( the carrier of S) V11( the carrier of T) V12() V21( the carrier of S, the carrier of T)  continuous   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='pre_topc.html#RC8'>pre_topc</span></td></tr>
<tr><td>
cluster  open   for    Element of  bool  the carrier of T;
</td><td><span data-href='pre_topc.html#RC10'>pre_topc</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   total   reflexive   antisymmetric   connected   transitive   being_linear-order   for    Element of  bool [:X,X:];
</td><td><span data-href='prefer_1.html#RC1'>prefer_1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   RAT  -valued   Function-like  V11() V14( omega ) V18( omega , REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K19(K20(omega,REAL));
</td><td><span data-href='prepower.html#RC1'>prepower</span></td></tr>
<tr><td>
cluster  bool X ->  cap-closed  ;
</td><td><span data-href='prob_1.html#FC1'>prob_1</span></td></tr>
<tr><td>
cluster  bool X ->  compl-closed   for  Subset-Family of X;
</td><td><span data-href='prob_1.html#FC2'>prob_1</span></td></tr>
<tr><td>
cluster  bool X ->  sigma-multiplicative   for  Subset-Family of X;
</td><td><span data-href='prob_1.html#FC4'>prob_1</span></td></tr>
<tr><td>
cluster  non-decreasing-closed   non-increasing-closed   for    Element of K10(K10(X));
</td><td><span data-href='prob_3.html#RC1'>prob_3</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( bool X)  non  empty   Function-like  V25( NAT ) V29( NAT , bool X) V126()  for    Element of  bool [:NAT,(bool X):];
</td><td><span data-href='prob_4.html#RC1'>prob_4</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5(Si) V5( bool X)  non  empty   Function-like  V25( NAT ) V29( NAT , bool X) V126()  for    Element of  bool [:NAT,(bool X):];
</td><td><span data-href='prob_4.html#RC2'>prob_4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of T -defined   REAL  -valued   Function-like  V31( the carrier of T) V32( the carrier of T, REAL )  complex-valued   ext-real-valued   real-valued   bounded   for    Element of K32(K33( the carrier of T,REAL));
</td><td><span data-href='pscomp_1.html#RC1'>pscomp_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of T -defined   REAL  -valued   Function-like  V31( the carrier of T) V32( the carrier of T, REAL )  complex-valued   ext-real-valued   real-valued   continuous   for    Element of K32(K33( the carrier of T,REAL));
</td><td><span data-href='pscomp_1.html#RC2'>pscomp_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of S -defined   REAL  -valued   Function-like  V31( the carrier of S) V32( the carrier of S, REAL )  complex-valued   ext-real-valued   real-valued   continuous   for    Element of K32(K33( the carrier of S,REAL));
</td><td><span data-href='pscomp_1.html#RC3'>pscomp_1</span></td></tr>
<tr><td>
cluster  Function-like  V32( the carrier of T, REAL )  continuous   ->  with_max   with_min   bounded   for    Element of K32(K33( the carrier of T,REAL));
</td><td><span data-href='pscomp_1.html#CC2'>pscomp_1</span></td></tr>
<tr><td>
cluster  non  empty   Consistent   for    Element of  bool (CQC-WFF Al);
</td><td><span data-href='qc_trans.html#RC3'>qc_trans</span></td></tr>
<tr><td>
cluster  Consistent   -> Al -Consistent   for    Element of  bool (CQC-WFF Al);
</td><td><span data-href='qc_trans.html#CC1'>qc_trans</span></td></tr>
<tr><td>
cluster Al -Consistent   ->  Consistent   for    Element of  bool (CQC-WFF Al);
</td><td><span data-href='qc_trans.html#CC2'>qc_trans</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( the carrier of L) V11( the carrier of L)  Function-like  V17( the carrier of L) V21( the carrier of L, the carrier of L)  inflationary   deflationary   monotone   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='quantal1.html#RC9'>quantal1</span></td></tr>
<tr><td>
cluster  Relation-like  Omega1 -defined  Omega2 -valued   non  empty   Function-like   total   quasi_total  S1,S2 -random_variable-like   for    Element of  bool [:Omega1,Omega2:];
</td><td><span data-href='random_3.html#RC1'>random_3</span></td></tr>
<tr><td>
cluster  finite  V143(F,V)  for    Element of K16( the carrier of V);
</td><td><span data-href='ranknull.html#RC1'>ranknull</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of W -valued   Function-like   quasi_total   additive   homogeneous   for    Element of K16(K17( the carrier of V, the carrier of W));
</td><td><span data-href='ranknull.html#RC2'>ranknull</span></td></tr>
<tr><td>
cluster  linearly-dependent   for    Element of K16( the carrier of V);
</td><td><span data-href='ranknull.html#RC3'>ranknull</span></td></tr>
<tr><td>
cluster V1() V4( omega ) V5( the carrier of L)  Function-like  V11()  total  V18( omega , the carrier of L)  finite-Support   zero   for    Element of K19(K20(omega, the carrier of L));
</td><td><span data-href='ratfunc1.html#RC1'>ratfunc1</span></td></tr>
<tr><td>
cluster V1() V4( omega ) V5( the carrier of L)  Function-like  V11()  total  V18( omega , the carrier of L)  finite-Support   non  zero   for    Element of K19(K20(omega, the carrier of L));
</td><td><span data-href='ratfunc1.html#RC2'>ratfunc1</span></td></tr>
<tr><td>
cluster V1() V4( omega ) V5( the carrier of L)  Function-like  V11()  total  V18( omega , the carrier of L)  finite-Support   non  zero   constant   for    Element of K19(K20(omega, the carrier of L));
</td><td><span data-href='ratfunc1.html#RC3'>ratfunc1</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of L)  finite-Support   zero   ->  constant   for    Element of K19(K20(omega, the carrier of L));
</td><td><span data-href='ratfunc1.html#CC3'>ratfunc1</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of L)  finite-Support   non  constant   ->  non  zero   for    Element of K19(K20(omega, the carrier of L));
</td><td><span data-href='ratfunc1.html#CC4'>ratfunc1</span></td></tr>
<tr><td>
cluster V1() V4( omega ) V5( the carrier of L)  Function-like  V11()  total  V18( omega , the carrier of L)  finite-Support   non  constant   for    Element of K19(K20(omega, the carrier of L));
</td><td><span data-href='ratfunc1.html#RC4'>ratfunc1</span></td></tr>
<tr><td>
cluster  compact   ->  closed   for    Element of K19(REAL);
</td><td><span data-href='rcomp_1.html#CC1'>rcomp_1</span></td></tr>
<tr><td>
cluster V57() V58() V59()  open   for    Element of K19(REAL);
</td><td><span data-href='rcomp_1.html#RC1'>rcomp_1</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   open   real-bounded   interval   for    Element of K34(REAL);
</td><td><span data-href='rcomp_3.html#RC1'>rcomp_3</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   closed   open   non  real-bounded   interval   for    Element of K34(REAL);
</td><td><span data-href='rcomp_3.html#RC2'>rcomp_3</span></td></tr>
<tr><td>
cluster  connected   ->  interval   for    Element of K34( the carrier of R^1);
</td><td><span data-href='rcomp_3.html#CC2'>rcomp_3</span></td></tr>
<tr><td>
cluster  interval   ->  connected   for    Element of K34( the carrier of R^1);
</td><td><span data-href='rcomp_3.html#CC3'>rcomp_3</span></td></tr>
<tr><td>
cluster  open   closed   connected   for    Element of K34( the carrier of T);
</td><td><span data-href='rcomp_3.html#RC3'>rcomp_3</span></td></tr>
<tr><td>
cluster  non  empty   open   closed   connected   for    Element of K34( the carrier of T);
</td><td><span data-href='rcomp_3.html#RC4'>rcomp_3</span></td></tr>
<tr><td>
cluster  non  empty   open   closed   connected   for    Element of K34(K34( the carrier of T));
</td><td><span data-href='rcomp_3.html#RC5'>rcomp_3</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   INT  -valued  V6()  Function-like  V29( omega ) V33( omega , REAL ) V67() V68() V69()  for    Element of K16(K17(omega,REAL));
</td><td><span data-href='real_3.html#RC1'>real_3</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   strongly_reflexive   for    Element of  bool [:X,X:];
</td><td><span data-href='realalg1.html#RC1'>realalg1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   totally_connected   for    Element of  bool [:X,X:];
</td><td><span data-href='realalg1.html#RC2'>realalg1</span></td></tr>
<tr><td>
cluster  strongly_reflexive   ->  reflexive   for    Element of  bool [:X,X:];
</td><td><span data-href='realalg1.html#CC1'>realalg1</span></td></tr>
<tr><td>
cluster  totally_connected   ->  strongly_connected   for    Element of  bool [:X,X:];
</td><td><span data-href='realalg1.html#CC2'>realalg1</span></td></tr>
<tr><td>
cluster  strongly_reflexive   ->  non  empty   for    Element of  bool [:X,X:];
</td><td><span data-href='realalg1.html#CC3'>realalg1</span></td></tr>
<tr><td>
cluster  totally_connected   ->  non  empty   for    Element of  bool [:X,X:];
</td><td><span data-href='realalg1.html#CC4'>realalg1</span></td></tr>
<tr><td>
cluster  with_squares   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#RC4'>realalg1</span></td></tr>
<tr><td>
cluster  with_sums_of_squares   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#RC5'>realalg1</span></td></tr>
<tr><td>
cluster  with_squares   ->  non  empty   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#CC6'>realalg1</span></td></tr>
<tr><td>
cluster  with_sums_of_squares   ->  non  empty   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#CC7'>realalg1</span></td></tr>
<tr><td>
cluster  with_sums_of_squares   ->  with_squares   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#CC8'>realalg1</span></td></tr>
<tr><td>
cluster  add-closed   with_squares   ->  with_sums_of_squares   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#CC9'>realalg1</span></td></tr>
<tr><td>
cluster  prepositive_cone   ->  non  empty   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#CC10'>realalg1</span></td></tr>
<tr><td>
cluster  positive_cone   ->  non  empty   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#CC11'>realalg1</span></td></tr>
<tr><td>
cluster  prepositive_cone   ->  add-closed   mult-closed   negative-disjoint   with_squares   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#CC12'>realalg1</span></td></tr>
<tr><td>
cluster  add-closed   mult-closed   negative-disjoint   with_squares   ->  prepositive_cone   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#CC13'>realalg1</span></td></tr>
<tr><td>
cluster  positive_cone   ->  add-closed   mult-closed   negative-disjoint   spanning   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#CC14'>realalg1</span></td></tr>
<tr><td>
cluster  add-closed   mult-closed   negative-disjoint   spanning   ->  positive_cone   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#CC15'>realalg1</span></td></tr>
<tr><td>
cluster  positive_cone   ->  prepositive_cone   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#CC16'>realalg1</span></td></tr>
<tr><td>
cluster  prepositive_cone   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#RC8'>realalg1</span></td></tr>
<tr><td>
cluster  positive_cone   for    Element of  bool  the carrier of R;
</td><td><span data-href='realalg1.html#RC9'>realalg1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of R -valued   antisymmetric   transitive   strongly_reflexive   respecting_addition   respecting_multiplication   for    Element of  bool [: the carrier of R, the carrier of R:];
</td><td><span data-href='realalg1.html#RC10'>realalg1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of R -valued   antisymmetric   transitive   strongly_reflexive   totally_connected   respecting_addition   respecting_multiplication   for    Element of  bool [: the carrier of R, the carrier of R:];
</td><td><span data-href='realalg1.html#RC11'>realalg1</span></td></tr>
<tr><td>
cluster  prepositive_cone   ->  spanning   for    Element of  bool  the carrier of INT.Ring;
</td><td><span data-href='realalg2.html#CC2'>realalg2</span></td></tr>
<tr><td>
cluster  prepositive_cone   ->  spanning   for    Element of  bool  the carrier of F_Rat;
</td><td><span data-href='realalg2.html#CC3'>realalg2</span></td></tr>
<tr><td>
cluster  prepositive_cone   ->  spanning   for    Element of  bool  the carrier of F_Real;
</td><td><span data-href='realalg2.html#CC4'>realalg2</span></td></tr>
<tr><td>
cluster  spanning   prepositive_cone   ->  maximal   for    Element of  bool  the carrier of F;
</td><td><span data-href='realalg2.html#CC5'>realalg2</span></td></tr>
<tr><td>
cluster  prepositive_cone   maximal   ->  spanning   for    Element of  bool  the carrier of F;
</td><td><span data-href='realalg2.html#CC6'>realalg2</span></td></tr>
<tr><td>
cluster F -binopclosed   for    Element of  bool X;
</td><td><span data-href='realset1.html#RC1'>realset1</span></td></tr>
<tr><td>
cluster  Relation-like  [:X,X:] -defined  X -valued   Function-like  V14([:X,X:]) V18([:X,X:],X) A -subsetpreserving   for    Element of  bool [:[:X,X:],X:];
</td><td><span data-href='realset1.html#RC2'>realset1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   bool D -valued   Function-like   finite   FinSequence-like   FinSubsequence-like   terms've_same_card_as_number   ascending   lenght_equal_card_of_set   for    FinSequence of  bool D;
</td><td><span data-href='rearran1.html#RC1'>rearran1</span></td></tr>
<tr><td>
cluster   ->  Relation-like   for    Element of  bool R;
</td><td><span data-href='relat_1.html#CC2'>relat_1</span></td></tr>
<tr><td>
cluster   -> X -defined   for    Element of  bool R;
</td><td><span data-href='relat_1.html#CC5'>relat_1</span></td></tr>
<tr><td>
cluster   -> X -valued   for    Element of  bool R;
</td><td><span data-href='relat_1.html#CC6'>relat_1</span></td></tr>
<tr><td>
cluster   ->  Relation-like   for    Element of  bool [:X,Y:];
</td><td><span data-href='relset_1.html#CC1'>relset_1</span></td></tr>
<tr><td>
cluster   -> X -defined  Y -valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='relset_1.html#CC2'>relset_1</span></td></tr>
<tr><td>
cluster   ->  empty   for    Element of  bool [:A,B:];
</td><td><span data-href='relset_1.html#CC3'>relset_1</span></td></tr>
<tr><td>
cluster   ->  empty   for    Element of  bool [:B,A:];
</td><td><span data-href='relset_1.html#CC4'>relset_1</span></td></tr>
<tr><td>
cluster  empty   Relation-like  X -defined  Y -valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='relset_1.html#RC1'>relset_1</span></td></tr>
<tr><td>
cluster  Relation-like   symmetric   for    Element of K16(([#] ((E ^omega),(E ^omega))));
</td><td><span data-href='rewrite2.html#RC2'>rewrite2</span></td></tr>
<tr><td>
cluster  Function-like   non-decreasing   ->  monotone   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC1'>rfunct_2</span></td></tr>
<tr><td>
cluster  Function-like   non-increasing   ->  monotone   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC2'>rfunct_2</span></td></tr>
<tr><td>
cluster  Function-like   non  monotone   ->  non  non-decreasing   non  non-increasing   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC3'>rfunct_2</span></td></tr>
<tr><td>
cluster  Function-like   non-decreasing   non-increasing   -> V8()  for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC4'>rfunct_2</span></td></tr>
<tr><td>
cluster  Function-like  V8()  ->  non-decreasing   non-increasing   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC5'>rfunct_2</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL  -valued   Function-like   trivial   complex-valued   ext-real-valued   real-valued   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#RC1'>rfunct_2</span></td></tr>
<tr><td>
cluster  prime   ->  proper   quasi-prime   for    Element of K34( the carrier of K);
</td><td><span data-href='ring_1.html#CC1'>ring_1</span></td></tr>
<tr><td>
cluster  proper   quasi-prime   ->  prime   for    Element of K34( the carrier of K);
</td><td><span data-href='ring_1.html#CC2'>ring_1</span></td></tr>
<tr><td>
cluster  maximal   ->  proper   quasi-maximal   for    Element of K34( the carrier of R);
</td><td><span data-href='ring_1.html#CC3'>ring_1</span></td></tr>
<tr><td>
cluster  proper   quasi-maximal   ->  maximal   for    Element of K34( the carrier of R);
</td><td><span data-href='ring_1.html#CC4'>ring_1</span></td></tr>
<tr><td>
cluster  non  empty   add-closed   left-ideal   right-ideal   maximal   ->  prime   for    Element of K34( the carrier of R);
</td><td><span data-href='ring_1.html#CC5'>ring_1</span></td></tr>
<tr><td>
cluster  non  empty   add-closed   left-ideal   right-ideal   maximal   for    Element of K34( the carrier of R);
</td><td><span data-href='ring_1.html#RC1'>ring_1</span></td></tr>
<tr><td>
cluster  non  empty   add-closed   left-ideal   right-ideal   maximal   for    Element of K34( the carrier of R);
</td><td><span data-href='ring_1.html#RC2'>ring_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined  X -valued   Function-like   non  empty   total   quasi_total   ascending   stagnating   for    Element of  bool [:NAT,X:];
</td><td><span data-href='ring_2.html#RC1'>ring_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   additive   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_2.html#RC2'>ring_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   multiplicative   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_2.html#RC3'>ring_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   unity-preserving   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_2.html#RC4'>ring_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   additive   multiplicative   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_2.html#RC5'>ring_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   additive   unity-preserving   multiplicative   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_2.html#RC12'>ring_2</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   unity-preserving   multiplicative   ->  monomorphism   for    Element of  bool [: the carrier of E, the carrier of F:];
</td><td><span data-href='ring_2.html#CC2'>ring_2</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ascending   ->  stagnating   for    Element of  bool [:NAT,(Ideals R):];
</td><td><span data-href='ring_2.html#CC12'>ring_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty  V14( the carrier of R)  quasi_total   unity-preserving   additive   monomorphism   multiplicative   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_3.html#RC17'>ring_3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty  V14( the carrier of R)  quasi_total   unity-preserving   additive   isomorphism   multiplicative   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_3.html#RC28'>ring_3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of R -valued   Function-like   non  empty  V14( the carrier of S)  quasi_total   unity-preserving   additive   isomorphism   multiplicative   for    Element of  bool [: the carrier of S, the carrier of R:];
</td><td><span data-href='ring_3.html#RC29'>ring_3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of INT.Ring -defined   the carrier of R -valued   Function-like   non  empty  V14( the carrier of INT.Ring)  quasi_total   unity-preserving   additive   monomorphism   multiplicative   for    Element of  bool [: the carrier of INT.Ring, the carrier of R:];
</td><td><span data-href='ring_3.html#RC31'>ring_3</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of R)  Function-like   non  empty   total   quasi_total   finite-Support   zero   for    Element of  bool [:NAT, the carrier of R:];
</td><td><span data-href='ring_4.html#RC5'>ring_4</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of L)  Function-like   non  empty   total   quasi_total   finite-Support   non  zero   constant   for    Element of  bool [:NAT, the carrier of L:];
</td><td><span data-href='ring_4.html#RC12'>ring_4</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of L)  Function-like   non  empty   total   quasi_total   finite-Support   monic   for    Element of  bool [:NAT, the carrier of L:];
</td><td><span data-href='ring_4.html#RC13'>ring_4</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of L)  Function-like   non  empty   total   quasi_total   finite-Support   non  monic   for    Element of  bool [:NAT, the carrier of L:];
</td><td><span data-href='ring_4.html#RC14'>ring_4</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of R)  finite-Support   non  zero   ->  non  zero   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#CC1'>ring_5</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of R)  finite-Support   monic   ->  non  zero   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#CC2'>ring_5</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of R)  finite-Support   non  zero   with_roots   ->  non  constant   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#CC3'>ring_5</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of R)  finite-Support   non  with_roots   ->  non  zero   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#CC4'>ring_5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   the carrier of R -valued   Function-like  V18( omega , the carrier of R)  finite-Support   non  zero   non  with_roots   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#RC2'>ring_5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   the carrier of R -valued   Function-like  V18( omega , the carrier of R)  finite-Support   non  zero   with_roots   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#RC3'>ring_5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   the carrier of R -valued   Function-like  V18( omega , the carrier of R)  finite-Support   non  constant   monic   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#RC4'>ring_5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   the carrier of R -valued   Function-like  V18( omega , the carrier of R)  finite-Support   monic   with_roots   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#RC5'>ring_5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   the carrier of R -valued   Function-like  V18( omega , the carrier of R)  finite-Support   monic   non  with_roots   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#RC6'>ring_5</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of F)  finite-Support   non  constant   ->  non  constant   with_roots   for    Element of K19(K20(omega, the carrier of F));
</td><td><span data-href='ring_5.html#CC6'>ring_5</span></td></tr>
<tr><td>
cluster V6() V31( the carrier of G, the carrier of H)  linear   ->  unity-preserving   multiplicative   additive   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='ringcat1.html#CC1'>ringcat1</span></td></tr>
<tr><td>
cluster V6() V31( the carrier of G, the carrier of H)  unity-preserving   multiplicative   additive   ->  linear   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='ringcat1.html#CC2'>ringcat1</span></td></tr>
<tr><td>
cluster  empty   ->  affinely-independent   for    Element of K19( the carrier of V);
</td><td><span data-href='rlaffin1.html#CC1'>rlaffin1</span></td></tr>
<tr><td>
cluster 1 -element   affinely-independent   for    Element of K19( the carrier of V);
</td><td><span data-href='rlaffin1.html#RC1'>rlaffin1</span></td></tr>
<tr><td>
cluster  linearly-independent   ->  affinely-independent   for    Element of K19( the carrier of V);
</td><td><span data-href='rlaffin1.html#CC2'>rlaffin1</span></td></tr>
<tr><td>
cluster  empty   ->  affinely-independent   for    Element of K19(K19( the carrier of V));
</td><td><span data-href='rlaffin1.html#CC3'>rlaffin1</span></td></tr>
<tr><td>
cluster  empty   affinely-independent   for    Element of K19(K19( the carrier of V));
</td><td><span data-href='rlaffin1.html#RC2'>rlaffin1</span></td></tr>
<tr><td>
cluster  non  empty   affinely-independent   for    Element of K19(K19( the carrier of V));
</td><td><span data-href='rlaffin1.html#RC3'>rlaffin1</span></td></tr>
<tr><td>
cluster  affinely-independent   ->  finite   affinely-independent   for    Element of  bool  the carrier of V;
</td><td><span data-href='rlaffin3.html#CC1'>rlaffin3</span></td></tr>
<tr><td>
cluster  Affine   ->  closed   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='rlaffin3.html#CC2'>rlaffin3</span></td></tr>
<tr><td>
cluster  non  empty   convex-membered   for    Element of  bool (bool  the carrier of V);
</td><td><span data-href='rltopsp1.html#RC2'>rltopsp1</span></td></tr>
<tr><td>
cluster  non  empty   symmetric   for    Element of  bool  the carrier of X;
</td><td><span data-href='rltopsp1.html#RC3'>rltopsp1</span></td></tr>
<tr><td>
cluster  empty   ->  circled   for    Element of  bool  the carrier of X;
</td><td><span data-href='rltopsp1.html#CC1'>rltopsp1</span></td></tr>
<tr><td>
cluster  non  empty   circled   for    Element of  bool  the carrier of X;
</td><td><span data-href='rltopsp1.html#RC4'>rltopsp1</span></td></tr>
<tr><td>
cluster  circled   ->  symmetric   for    Element of  bool  the carrier of X;
</td><td><span data-href='rltopsp1.html#CC2'>rltopsp1</span></td></tr>
<tr><td>
cluster  non  empty   circled-membered   for    Element of  bool (bool  the carrier of V);
</td><td><span data-href='rltopsp1.html#RC5'>rltopsp1</span></td></tr>
<tr><td>
cluster  empty   ->  bounded   for    Element of  bool  the carrier of X;
</td><td><span data-href='rltopsp1.html#CC3'>rltopsp1</span></td></tr>
<tr><td>
cluster  bounded   for    Element of  bool  the carrier of X;
</td><td><span data-href='rltopsp1.html#RC9'>rltopsp1</span></td></tr>
<tr><td>
cluster  being_line   for    Element of  bool  the carrier of V;
</td><td><span data-href='rltopsp1.html#RC10'>rltopsp1</span></td></tr>
<tr><td>
cluster  non  trivial   being_line   for    Element of  bool  the carrier of V;
</td><td><span data-href='rltopsp1.html#RC11'>rltopsp1</span></td></tr>
<tr><td>
cluster  linearly-independent   for    Element of  bool  the carrier of V;
</td><td><span data-href='rlvect_3.html#RC1'>rlvect_3</span></td></tr>
<tr><td>
cluster  exact   for    Element of  bool  the carrier of A;
</td><td><span data-href='roughs_1.html#RC6'>roughs_1</span></td></tr>
<tr><td>
cluster  rough   for    Element of  bool  the carrier of A;
</td><td><span data-href='roughs_1.html#RC7'>roughs_1</span></td></tr>
<tr><td>
cluster   ->  exact   for    Element of  bool  the carrier of A;
</td><td><span data-href='roughs_1.html#CC7'>roughs_1</span></td></tr>
<tr><td>
cluster  id (bool A) ->  empty-preserving   universe-preserving   for  Function of (bool A),(bool A);
</td><td><span data-href='roughs_2.html#FC3'>roughs_2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool A -defined   bool A -valued   Function-like   total  V29( bool A, bool A)  empty-preserving   universe-preserving   for    Element of  bool [:(bool A),(bool A):];
</td><td><span data-href='roughs_2.html#RC2'>roughs_2</span></td></tr>
<tr><td>
cluster  Flip f ->  empty-preserving  ;
</td><td><span data-href='roughs_2.html#FC4'>roughs_2</span></td></tr>
<tr><td>
cluster  Flip f ->  universe-preserving  ;
</td><td><span data-href='roughs_2.html#FC5'>roughs_2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool  the carrier of T -defined   bool  the carrier of T -valued   Function-like   total  V29( bool  the carrier of T, bool  the carrier of T)  closed-valued   for    Element of  bool [:(bool  the carrier of T),(bool  the carrier of T):];
</td><td><span data-href='roughs_2.html#RC3'>roughs_2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool  the carrier of T -defined   bool  the carrier of T -valued   Function-like   total  V29( bool  the carrier of T, bool  the carrier of T)  open-valued   for    Element of  bool [:(bool  the carrier of T),(bool  the carrier of T):];
</td><td><span data-href='roughs_2.html#RC4'>roughs_2</span></td></tr>
<tr><td>
cluster  bool X ->  d.union-closed  ;
</td><td><span data-href='roughs_3.html#FC1'>roughs_3</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool A -defined   bool A -valued   Function-like  V25( bool A)  quasi_total   \/-preserving   /\-preserving   for    Element of  bool [:(bool A),(bool A):];
</td><td><span data-href='roughs_3.html#RC1'>roughs_3</span></td></tr>
<tr><td>
cluster  Flip f ->  \/-preserving  ;
</td><td><span data-href='roughs_3.html#FC3'>roughs_3</span></td></tr>
<tr><td>
cluster  Flip f ->  /\-preserving  ;
</td><td><span data-href='roughs_3.html#FC4'>roughs_3</span></td></tr>
<tr><td>
cluster  GeneratedRelStr H ->  non  empty  ;
</td><td><span data-href='roughs_3.html#FC6'>roughs_3</span></td></tr>
<tr><td>
cluster  topology-like   for    Element of  bool (bool X);
</td><td><span data-href='roughs_4.html#RC1'>roughs_4</span></td></tr>
<tr><td>
cluster  Function-like  V21( bool X, bool X)  \/-preserving   ->  c=-monotone   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='roughs_4.html#CC1'>roughs_4</span></td></tr>
<tr><td>
cluster  Function-like  V21( bool X, bool X)  /\-preserving   ->  c=-monotone   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='roughs_4.html#CC2'>roughs_4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool X -defined   bool X -valued   Function-like  V17( bool X) V21( bool X, bool X)  closure   interior   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='roughs_4.html#RC2'>roughs_4</span></td></tr>
<tr><td>
cluster  Function-like  V21( bool X, bool X)  closure   ->  preclosure   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='roughs_4.html#CC3'>roughs_4</span></td></tr>
<tr><td>
cluster  op-closed   for    Element of  bool  the carrier of X;
</td><td><span data-href='roughs_4.html#RC8'>roughs_4</span></td></tr>
<tr><td>
cluster  op-open   for    Element of  bool  the carrier of X;
</td><td><span data-href='roughs_4.html#RC10'>roughs_4</span></td></tr>
<tr><td>
cluster  1st_class   ->  exact   for    Element of  bool  the carrier of T;
</td><td><span data-href='roughs_4.html#CC8'>roughs_4</span></td></tr>
<tr><td>
cluster  exact   ->  1st_class   for    Element of  bool  the carrier of T;
</td><td><span data-href='roughs_4.html#CC9'>roughs_4</span></td></tr>
<tr><td>
cluster  2nd_class   ->  rough   for    Element of  bool  the carrier of T;
</td><td><span data-href='roughs_4.html#CC10'>roughs_4</span></td></tr>
<tr><td>
cluster  rough   ->  2nd_class   for    Element of  bool  the carrier of T;
</td><td><span data-href='roughs_4.html#CC11'>roughs_4</span></td></tr>
<tr><td>
cluster  ff_0 f ->  empty-preserving  ;
</td><td><span data-href='roughs_5.html#FC2'>roughs_5</span></td></tr>
<tr><td>
cluster 1 -element   ->  finite   for    Element of K21(E);
</td><td><span data-href='rpr_1.html#CC1'>rpr_1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   the carrier of Y -valued   non  empty   Function-like  V26(X)  quasi_total   bounded   for    Element of  bool [:X, the carrier of Y:];
</td><td><span data-href='rsspace4.html#RC1'>rsspace4</span></td></tr>
<tr><td>
cluster  non  empty   Affine   for    Element of K21( the carrier of V);
</td><td><span data-href='rusub_4.html#RC4'>rusub_4</span></td></tr>
<tr><td>
cluster  empty   Affine   for    Element of K21( the carrier of V);
</td><td><span data-href='rusub_4.html#RC5'>rusub_4</span></td></tr>
<tr><td>
cluster  Relation-like   empty-yielding   omega  -defined   COMPLEX  -valued   non  empty   Function-like  V32( omega ) V33( omega , COMPLEX )  complex-valued   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#RC1'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   empty-yielding   omega  -defined   REAL  -valued   non  empty   Function-like  V32( omega ) V33( omega , REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K16(K17(omega,REAL));
</td><td><span data-href='rvsum_4.html#RC2'>rvsum_4</span></td></tr>
<tr><td>
cluster  empty-yielding   Function-like  V33( omega , COMPLEX )  ->  natural-valued   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#CC1'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   COMPLEX  -valued   non  empty   Function-like   constant  V32( omega ) V33( omega , COMPLEX )  complex-valued   real-valued   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#RC3'>rvsum_4</span></td></tr>
<tr><td>
cluster  empty-yielding   Function-like  V33( omega , COMPLEX )  ->  absolutely_summable   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#CC2'>rvsum_4</span></td></tr>
<tr><td>
cluster  empty-yielding   Function-like  V33( omega , REAL )  ->  absolutely_summable   for    Element of K16(K17(omega,REAL));
</td><td><span data-href='rvsum_4.html#CC3'>rvsum_4</span></td></tr>
<tr><td>
cluster  Function-like  V33( omega , COMPLEX )  ->  Sequence-like   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#CC4'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   COMPLEX  -valued   non  empty   Function-like  V32( omega ) V33( omega , COMPLEX )  complex-valued   summable   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#RC4'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   empty-yielding   omega  -defined   REAL  -valued   non  empty   Function-like  V32( omega ) V33( omega , REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K16(K17(omega,REAL));
</td><td><span data-href='rvsum_4.html#RC7'>rvsum_4</span></td></tr>
<tr><td>
cluster  Function-like  V33( omega , REAL )  ->  Sequence-like   for    Element of K16(K17(omega,REAL));
</td><td><span data-href='rvsum_4.html#CC5'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   COMPLEX  -valued   non  empty   Sequence-like   Function-like  V32( omega ) V33( omega , COMPLEX )  complex-valued   ext-real-valued   real-valued   summable   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#RC9'>rvsum_4</span></td></tr>
<tr><td>
cluster   -> n -at_most_dimensional   for    Element of  bool X;
</td><td><span data-href='scmyciel.html#CC3'>scmyciel</span></td></tr>
<tr><td>
cluster  finite-membered  1 -at_most_dimensional   SimpleGraph-like   for    Element of  bool G;
</td><td><span data-href='scmyciel.html#RC8'>scmyciel</span></td></tr>
<tr><td>
cluster  non  empty  V38()  finite-membered  V243() V278()  subset-closed  1 -at_most_dimensional   SimpleGraph-like   clique   for    Element of  bool G;
</td><td><span data-href='scmyciel.html#RC10'>scmyciel</span></td></tr>
<tr><td>
cluster  non  empty  V38()  finite   finite-membered  V243() V278()  subset-closed  1 -at_most_dimensional   SimpleGraph-like   clique   for    Element of  bool G;
</td><td><span data-href='scmyciel.html#RC11'>scmyciel</span></td></tr>
<tr><td>
cluster  trivial   ->  stable   for    Element of  bool (Vertices G);
</td><td><span data-href='scmyciel.html#CC9'>scmyciel</span></td></tr>
<tr><td>
cluster  stable   for    Element of  bool (Vertices G);
</td><td><span data-href='scmyciel.html#RC15'>scmyciel</span></td></tr>
<tr><td>
cluster  finite   stable   for    Element of  bool (Vertices G);
</td><td><span data-href='scmyciel.html#RC16'>scmyciel</span></td></tr>
<tr><td>
cluster  stable   ->  finite   for    Element of  bool (Vertices G);
</td><td><span data-href='scmyciel.html#CC12'>scmyciel</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   non-zero   complex-valued   ext-real-valued   real-valued   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seq_1.html#RC1'>seq_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   constant   non  empty   total  V18( NAT , REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seq_1.html#RC2'>seq_1</span></td></tr>
<tr><td>
cluster  Function-like   constant  V32( NAT , REAL )  ->  convergent   for    Element of K21(K22(NAT,REAL));
</td><td><span data-href='seq_2.html#CC3'>seq_2</span></td></tr>
<tr><td>
cluster  Function-like  V32( NAT , REAL )  convergent   ->  bounded   for    Element of K21(K22(NAT,REAL));
</td><td><span data-href='seq_2.html#CC4'>seq_2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , REAL ) V47()  bounded_above   ->  convergent   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='seq_4.html#CC1'>seq_4</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , REAL ) V48()  bounded_below   ->  convergent   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='seq_4.html#CC2'>seq_4</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , REAL )  monotone   bounded   ->  convergent   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='seq_4.html#CC3'>seq_4</span></td></tr>
<tr><td>
cluster  non  empty   complex-membered   ext-real-membered   real-membered   bounded_below   bounded_above   for    Element of  bool REAL;
</td><td><span data-href='seq_4.html#RC1'>seq_4</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  non-decreasing   non-increasing   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seqm_3.html#CC1'>seqm_3</span></td></tr>
<tr><td>
cluster  Function-like   non-decreasing   non-increasing   ->  constant   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seqm_3.html#CC2'>seqm_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   non  empty   total  V18( NAT , REAL )  complex-valued   ext-real-valued   real-valued   natural-valued   increasing   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seqm_3.html#RC1'>seqm_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   NAT  -valued   Function-like   non  empty   total  V18( NAT , NAT )  complex-valued   ext-real-valued   real-valued   natural-valued   increasing   for    Element of K19(K20(NAT,NAT));
</td><td><span data-href='seqm_3.html#RC2'>seqm_3</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , REAL )  absolutely_summable   ->  summable   for    Element of K19(K20(omega,REAL));
</td><td><span data-href='series_1.html#CC1'>series_1</span></td></tr>
<tr><td>
cluster  with_proper_subsets   for    Element of  bool (bool TS);
</td><td><span data-href='setfam_1.html#RC4'>setfam_1</span></td></tr>
<tr><td>
cluster  with_non-empty_element   finite   finite-membered   subset-closed   for    Element of  bool (bool D);
</td><td><span data-href='simplex0.html#RC1'>simplex0</span></td></tr>
<tr><td>
cluster  empty   simplex-like   for    Element of  bool (bool  the carrier of K);
</td><td><span data-href='simplex0.html#RC2'>simplex0</span></td></tr>
<tr><td>
cluster  simplex-like   ->  finite   for    Element of  bool (bool  the carrier of K);
</td><td><span data-href='simplex0.html#CC11'>simplex0</span></td></tr>
<tr><td>
cluster  simplex-like   ->  finite-membered   for    Element of  bool (bool  the carrier of K);
</td><td><span data-href='simplex0.html#CC12'>simplex0</span></td></tr>
<tr><td>
cluster  empty   ->  simplex-like   for    Element of  bool  the carrier of K;
</td><td><span data-href='simplex0.html#CC13'>simplex0</span></td></tr>
<tr><td>
cluster  empty   simplex-like   for    Element of  bool  the carrier of K;
</td><td><span data-href='simplex0.html#RC7'>simplex0</span></td></tr>
<tr><td>
cluster  finite   simplex-like   for    Element of  bool  the carrier of K;
</td><td><span data-href='simplex0.html#RC8'>simplex0</span></td></tr>
<tr><td>
cluster 1 -element   affinely-independent   for    Element of  bool  the carrier of V;
</td><td><span data-href='simplex1.html#RC3'>simplex1</span></td></tr>
<tr><td>
cluster  finite   ->  bounded   for    Element of  bool  the carrier of M;
</td><td><span data-href='simplex2.html#CC1'>simplex2</span></td></tr>
<tr><td>
cluster  closed   bounded   ->  compact   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='simplex2.html#CC6'>simplex2</span></td></tr>
<tr><td>
cluster  non  trivial   horizontal   ->  non  vertical   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='sppol_1.html#CC1'>sppol_1</span></td></tr>
<tr><td>
cluster  non  trivial   vertical   ->  non  horizontal   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='sppol_1.html#CC2'>sppol_1</span></td></tr>
<tr><td>
cluster  non  empty   functional   compact   horizontal   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='sppol_1.html#RC1'>sppol_1</span></td></tr>
<tr><td>
cluster  non  empty   functional   compact   vertical   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='sppol_1.html#RC2'>sppol_1</span></td></tr>
<tr><td>
cluster  being_S-P_arc   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='sppol_2.html#RC3'>sppol_2</span></td></tr>
<tr><td>
cluster  special_polygonal   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='sppol_2.html#RC4'>sppol_2</span></td></tr>
<tr><td>
cluster  special_polygonal   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='sppol_2.html#RC5'>sppol_2</span></td></tr>
<tr><td>
cluster  special_polygonal   ->  non  empty   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='sppol_2.html#CC4'>sppol_2</span></td></tr>
<tr><td>
cluster  special_polygonal   ->  non  trivial   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='sppol_2.html#CC5'>sppol_2</span></td></tr>
<tr><td>
cluster  special_polygonal   ->  compact   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='sppol_2.html#CC6'>sppol_2</span></td></tr>
<tr><td>
cluster  non  empty   compact   non  horizontal   non  vertical   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='sprect_1.html#RC2'>sprect_1</span></td></tr>
<tr><td>
cluster  cap-finite-partition-closed   for    Element of  bool (bool X);
</td><td><span data-href='srings_1.html#RC1'>srings_1</span></td></tr>
<tr><td>
cluster  cap-closed   ->  cap-finite-partition-closed   for    Element of  bool (bool X);
</td><td><span data-href='srings_1.html#CC1'>srings_1</span></td></tr>
<tr><td>
cluster  diff-finite-partition-closed   for    Element of  bool (bool X);
</td><td><span data-href='srings_1.html#RC2'>srings_1</span></td></tr>
<tr><td>
cluster  diff-closed   ->  diff-finite-partition-closed   for    Element of  bool (bool X);
</td><td><span data-href='srings_1.html#CC2'>srings_1</span></td></tr>
<tr><td>
cluster  diff-finite-partition-closed   ->  diff-c=-finite-partition-closed   for    Element of  bool (bool X);
</td><td><span data-href='srings_1.html#CC3'>srings_1</span></td></tr>
<tr><td>
cluster  with_empty_element   cap-finite-partition-closed   diff-finite-partition-closed   diff-c=-finite-partition-closed   for    Element of  bool (bool X);
</td><td><span data-href='srings_1.html#RC3'>srings_1</span></td></tr>
<tr><td>
cluster  cap-finite-partition-closed   diff-c=-finite-partition-closed   ->  cap-finite-partition-closed   diff-finite-partition-closed   for    Element of  bool (bool X);
</td><td><span data-href='srings_1.html#CC4'>srings_1</span></td></tr>
<tr><td>
cluster  with_empty_element   cap-finite-partition-closed   diff-finite-partition-closed   diff-c=-finite-partition-closed   with_countable_Cover   for    Element of  bool (bool X);
</td><td><span data-href='srings_1.html#RC4'>srings_1</span></td></tr>
<tr><td>
cluster  non  empty   compl-closed   sigma-multiplicative   ->  cap-finite-partition-closed   diff-c=-finite-partition-closed   with_countable_Cover   with_empty_element   for    Element of  bool (bool X);
</td><td><span data-href='srings_2.html#CC1'>srings_2</span></td></tr>
<tr><td>
cluster  bool X ->  cap-finite-partition-closed   diff-c=-finite-partition-closed   with_countable_Cover   with_empty_element   for  Subset-Family of X;
</td><td><span data-href='srings_2.html#FC1'>srings_2</span></td></tr>
<tr><td>
cluster  non  empty   diff-closed   ->  with_empty_element   for    Element of K6(K6(X));
</td><td><span data-href='srings_3.html#CC1'>srings_3</span></td></tr>
<tr><td>
cluster K6(X) ->  semi-diff-closed  ;
</td><td><span data-href='srings_3.html#FC1'>srings_3</span></td></tr>
<tr><td>
cluster  non  empty   cap-closed   semi-diff-closed   for    Element of K6(K6(X));
</td><td><span data-href='srings_3.html#RC1'>srings_3</span></td></tr>
<tr><td>
cluster  with_empty_element   cap-closed   semi-diff-closed   for    Element of K6(K6(X));
</td><td><span data-href='srings_3.html#RC2'>srings_3</span></td></tr>
<tr><td>
cluster  non  empty   preBoolean   for    Element of K6(K6(X));
</td><td><span data-href='srings_3.html#RC3'>srings_3</span></td></tr>
<tr><td>
cluster  cap-closed   cap-finite-partition-closed   with_empty_element   for    Element of  bool (bool X);
</td><td><span data-href='srings_4.html#RC1'>srings_4</span></td></tr>
<tr><td>
cluster  non  empty   cup-closed   cap-closed  V22()  cap-finite-partition-closed   with_empty_element   for    Element of  bool (bool X);
</td><td><span data-href='srings_4.html#RC2'>srings_4</span></td></tr>
<tr><td>
cluster  non  empty   cap-closed  V22()  cap-finite-partition-closed   diff-finite-partition-closed   diff-c=-finite-partition-closed   non  with_non-empty_elements   for    Element of  bool (bool X);
</td><td><span data-href='srings_4.html#RC5'>srings_4</span></td></tr>
<tr><td>
cluster  countable   simplex-like   quasi_basis   for    Element of  bool (bool  the carrier of (TOP-REAL n));
</td><td><span data-href='srings_5.html#RC1'>srings_5</span></td></tr>
<tr><td>
cluster  countable   simplex-like   quasi_basis   for    Element of  bool (bool  the carrier of (TOP-REAL n));
</td><td><span data-href='srings_5.html#RC2'>srings_5</span></td></tr>
<tr><td>
cluster  non  empty   for    Element of  bool  the carrier of S;
</td><td><span data-href='struct_0.html#RC4'>struct_0</span></td></tr>
<tr><td>
cluster  non  empty   trivial   for    Element of  bool  the carrier of S;
</td><td><span data-href='struct_0.html#RC21'>struct_0</span></td></tr>
<tr><td>
cluster  non  trivial   for    Element of  bool  the carrier of T;
</td><td><span data-href='struct_0.html#RC22'>struct_0</span></td></tr>
<tr><td>
cluster  bool X ->  non  empty  ;
</td><td><span data-href='subset_1.html#FC1'>subset_1</span></td></tr>
<tr><td>
cluster  non  empty   for    Element of  bool X;
</td><td><span data-href='subset_1.html#RC1'>subset_1</span></td></tr>
<tr><td>
cluster  empty   for    Element of  bool E;
</td><td><span data-href='subset_1.html#RC2'>subset_1</span></td></tr>
<tr><td>
cluster   ->  empty   for    Element of  bool X;
</td><td><span data-href='subset_1.html#CC1'>subset_1</span></td></tr>
<tr><td>
cluster  non  proper   for    Element of  bool E;
</td><td><span data-href='subset_1.html#RC3'>subset_1</span></td></tr>
<tr><td>
cluster  non  proper   ->  non  empty   for    Element of  bool E;
</td><td><span data-href='subset_1.html#CC2'>subset_1</span></td></tr>
<tr><td>
cluster  empty   ->  proper   for    Element of  bool E;
</td><td><span data-href='subset_1.html#CC3'>subset_1</span></td></tr>
<tr><td>
cluster  proper   for    Element of  bool E;
</td><td><span data-href='subset_1.html#RC4'>subset_1</span></td></tr>
<tr><td>
cluster   ->  non  proper   for    Element of  bool E;
</td><td><span data-href='subset_1.html#CC4'>subset_1</span></td></tr>
<tr><td>
cluster  non  empty   trivial   for    Element of  bool X;
</td><td><span data-href='subset_1.html#RC5'>subset_1</span></td></tr>
<tr><td>
cluster   ->  trivial   for    Element of  bool X;
</td><td><span data-href='subset_1.html#CC5'>subset_1</span></td></tr>
<tr><td>
cluster  non  trivial   for    Element of  bool X;
</td><td><span data-href='subset_1.html#RC6'>subset_1</span></td></tr>
<tr><td>
cluster  non  empty   with_non-empty_elements   for    Element of  bool (bool X);
</td><td><span data-href='supinf_1.html#RC1'>supinf_1</span></td></tr>
<tr><td>
cluster  Function-like  V18(X,Y)  bounded   ->  bounded_above   bounded_below   for    Element of K19(K20(X,Y));
</td><td><span data-href='supinf_2.html#CC1'>supinf_2</span></td></tr>
<tr><td>
cluster  Function-like  V18(X,Y)  bounded_above   bounded_below   ->  bounded   for    Element of K19(K20(X,Y));
</td><td><span data-href='supinf_2.html#CC2'>supinf_2</span></td></tr>
<tr><td>
cluster  non  empty   ext-real-membered  V85()  for    Element of K19(ExtREAL);
</td><td><span data-href='supinf_2.html#RC1'>supinf_2</span></td></tr>
<tr><td>
cluster  ext-real-membered  V85()  nonnegative   for    Element of K19(ExtREAL);
</td><td><span data-href='supinf_2.html#RC2'>supinf_2</span></td></tr>
<tr><td>
cluster  mutually-disjoint   for    Element of  bool (bool Y);
</td><td><span data-href='taxonom2.html#RC3'>taxonom2</span></td></tr>
<tr><td>
cluster  Function-like  V35( omega , the carrier of M)  convergent   ->  Cauchy   for    Element of K10(K11(omega, the carrier of M));
</td><td><span data-href='tbsp_1.html#CC1'>tbsp_1</span></td></tr>
<tr><td>
cluster  empty   ->  bounded   for    Element of K10( the carrier of N);
</td><td><span data-href='tbsp_1.html#CC2'>tbsp_1</span></td></tr>
<tr><td>
cluster  bounded   for    Element of K10( the carrier of N);
</td><td><span data-href='tbsp_1.html#RC2'>tbsp_1</span></td></tr>
<tr><td>
cluster  finite   ->  bounded   for    Element of K10( the carrier of T);
</td><td><span data-href='tbsp_1.html#CC3'>tbsp_1</span></td></tr>
<tr><td>
cluster  non  empty   finite   for    Element of K10( the carrier of T);
</td><td><span data-href='tbsp_1.html#RC3'>tbsp_1</span></td></tr>
<tr><td>
cluster  Relation-like   Bags n -defined   Bags n -valued   total  V18( Bags n, Bags n)  reflexive   antisymmetric   connected   transitive   admissible   for    Element of K19(K20((Bags n),(Bags n)));
</td><td><span data-href='termord.html#RC3'>termord</span></td></tr>
<tr><td>
cluster  total   reflexive   antisymmetric   transitive   admissible   ->  well_founded   admissible   for    Element of K19(K20((Bags n),(Bags n)));
</td><td><span data-href='termord.html#CC1'>termord</span></td></tr>
<tr><td>
cluster  proper   ->  empty   for    Element of  bool S;
</td><td><span data-href='tex_2.html#CC1'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   ->  non  proper   for    Element of  bool S;
</td><td><span data-href='tex_2.html#CC2'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   non  proper   ->  non  empty   trivial   for    Element of  bool S;
</td><td><span data-href='tex_2.html#CC3'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   trivial   ->  non  empty   proper   for    Element of  bool S;
</td><td><span data-href='tex_2.html#CC4'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   non  proper   ->  non  empty   non  trivial   for    Element of  bool S;
</td><td><span data-href='tex_2.html#CC5'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   trivial   proper   for    Element of  bool S;
</td><td><span data-href='tex_2.html#RC1'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   non  proper   for    Element of  bool S;
</td><td><span data-href='tex_2.html#RC2'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   ->  non  empty   non  proper   for    Element of  bool  the carrier of Y;
</td><td><span data-href='tex_2.html#CC6'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   non  proper   ->  non  empty   trivial   for    Element of  bool  the carrier of Y;
</td><td><span data-href='tex_2.html#CC7'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   trivial   ->  non  empty   proper   for    Element of  bool  the carrier of Y;
</td><td><span data-href='tex_2.html#CC8'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   non  proper   ->  non  empty   non  trivial   for    Element of  bool  the carrier of Y;
</td><td><span data-href='tex_2.html#CC9'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   trivial   proper   for    Element of  bool  the carrier of Y;
</td><td><span data-href='tex_2.html#RC3'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   non  proper   for    Element of  bool  the carrier of Y;
</td><td><span data-href='tex_2.html#RC4'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   trivial   proper   for    Element of  bool  the carrier of Y;
</td><td><span data-href='tex_2.html#RC5'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   NAT  -defined   REAL  -valued   Function-like   constant   total   quasi_total   complex-valued   ext-real-valued   real-valued   summable   convergent   for    Element of K10(K11(NAT,REAL));
</td><td><span data-href='tietze.html#RC1'>tietze</span></td></tr>
<tr><td>
cluster  functional   convex   non  boundary   compact  V256() V257() V258()  for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='tietze_2.html#RC1'>tietze_2</span></td></tr>
<tr><td>
cluster  non  empty   convex   for    Element of  bool  the carrier of (TOP-REAL n);
</td><td><span data-href='topalg_2.html#RC1'>topalg_2</span></td></tr>
<tr><td>
cluster  non  empty  V168() V169() V170()  interval   for    Element of  bool  the carrier of R^1;
</td><td><span data-href='topalg_2.html#RC3'>topalg_2</span></td></tr>
<tr><td>
cluster V168() V169() V170()  interval   for    Element of  bool  the carrier of T;
</td><td><span data-href='topalg_2.html#RC4'>topalg_2</span></td></tr>
<tr><td>
cluster  non  empty   open   closed   mutually-disjoint   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='topalg_3.html#RC1'>topalg_3</span></td></tr>
<tr><td>
cluster  Function-like   constant   quasi_total   ->  continuous   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='topalg_6.html#CC1'>topalg_6</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R^1 -defined   the carrier of T -valued   Function-like   parametrized-curve   for    Element of  bool [: the carrier of R^1, the carrier of T:];
</td><td><span data-href='topalg_6.html#RC2'>topalg_6</span></td></tr>
<tr><td>
cluster  finite   ->  finite-ind   for    Element of  bool  the carrier of T;
</td><td><span data-href='topdim_1.html#CC1'>topdim_1</span></td></tr>
<tr><td>
cluster  empty   ->  finite-ind   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='topdim_1.html#CC2'>topdim_1</span></td></tr>
<tr><td>
cluster  non  empty   finite-ind   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='topdim_1.html#RC1'>topdim_1</span></td></tr>
<tr><td>
cluster  non  empty   finite-ind   for    Element of  bool  the carrier of T;
</td><td><span data-href='topdim_1.html#RC2'>topdim_1</span></td></tr>
<tr><td>
cluster   ->  finite-ind   for    Element of  bool  the carrier of Tf;
</td><td><span data-href='topdim_1.html#CC4'>topdim_1</span></td></tr>
<tr><td>
cluster  finite-order   for    Element of  bool (bool X);
</td><td><span data-href='topdim_2.html#RC1'>topdim_2</span></td></tr>
<tr><td>
cluster  finite   ->  finite-order   for    Element of  bool (bool X);
</td><td><span data-href='topdim_2.html#CC1'>topdim_2</span></td></tr>
<tr><td>
cluster  countable   ->  finite-ind   for    Element of  bool  the carrier of TM;
</td><td><span data-href='topdim_2.html#CC2'>topdim_2</span></td></tr>
<tr><td>
cluster  non  open   for    Element of K10( the carrier of T);
</td><td><span data-href='topgen_1.html#RC4'>topgen_1</span></td></tr>
<tr><td>
cluster  non  closed   for    Element of K10( the carrier of T);
</td><td><span data-href='topgen_1.html#RC5'>topgen_1</span></td></tr>
<tr><td>
cluster  perfect   ->  closed   dense-in-itself   for    Element of K10( the carrier of T);
</td><td><span data-href='topgen_1.html#CC2'>topgen_1</span></td></tr>
<tr><td>
cluster  closed   dense-in-itself   ->  perfect   for    Element of K10( the carrier of T);
</td><td><span data-href='topgen_1.html#CC3'>topgen_1</span></td></tr>
<tr><td>
cluster  empty   ->  perfect   for    Element of K10( the carrier of T);
</td><td><span data-href='topgen_1.html#CC4'>topgen_1</span></td></tr>
<tr><td>
cluster  perfect   for    Element of K10( the carrier of T);
</td><td><span data-href='topgen_1.html#RC6'>topgen_1</span></td></tr>
<tr><td>
cluster  non  empty   scattered   ->  non  dense-in-itself   for    Element of K10( the carrier of T);
</td><td><span data-href='topgen_1.html#CC5'>topgen_1</span></td></tr>
<tr><td>
cluster  non  empty   dense-in-itself   ->  non  scattered   for    Element of K10( the carrier of T);
</td><td><span data-href='topgen_1.html#CC6'>topgen_1</span></td></tr>
<tr><td>
cluster  empty   ->  scattered   for    Element of K10( the carrier of T);
</td><td><span data-href='topgen_1.html#CC7'>topgen_1</span></td></tr>
<tr><td>
cluster   ->  open   closed   for    Element of K10( the carrier of T);
</td><td><span data-href='topgen_1.html#CC8'>topgen_1</span></td></tr>
<tr><td>
cluster  non  empty   open   for    Element of K32(K32( the carrier of T));
</td><td><span data-href='topgen_2.html#RC1'>topgen_2</span></td></tr>
<tr><td>
cluster  non  empty   compl-closed   sigma-multiplicative   ->  closed_for_countable_unions   for    Element of  bool (bool T);
</td><td><span data-href='topgen_4.html#CC5'>topgen_4</span></td></tr>
<tr><td>
cluster  closed_for_countable_unions   ->  non  empty   for    Element of  bool (bool T);
</td><td><span data-href='topgen_4.html#CC6'>topgen_4</span></td></tr>
<tr><td>
cluster  compl-closed   all-open-containing   closed_for_countable_unions   ->  all-closed-containing   closed_for_countable_meets   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='topgen_4.html#CC7'>topgen_4</span></td></tr>
<tr><td>
cluster  compl-closed   all-closed-containing   closed_for_countable_meets   ->  all-open-containing   closed_for_countable_unions   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='topgen_4.html#CC8'>topgen_4</span></td></tr>
<tr><td>
cluster  empty   ->  open   closed   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='topgen_4.html#CC9'>topgen_4</span></td></tr>
<tr><td>
cluster  countable   open   closed   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='topgen_4.html#RC2'>topgen_4</span></td></tr>
<tr><td>
cluster  empty   ->  F_sigma   G_delta   for    Element of  bool  the carrier of T;
</td><td><span data-href='topgen_4.html#CC11'>topgen_4</span></td></tr>
<tr><td>
cluster  compl-closed   all-open-containing   all-closed-containing   closed_for_countable_unions   closed_for_countable_meets   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='topgen_4.html#RC4'>topgen_4</span></td></tr>
<tr><td>
cluster  non  empty   compl-closed   sigma-additive   closed_for_countable_unions   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='topgen_4.html#RC5'>topgen_4</span></td></tr>
<tr><td>
cluster  non  empty   compl-closed   sigma-multiplicative   ->  closed_for_countable_unions   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='topgen_4.html#CC14'>topgen_4</span></td></tr>
<tr><td>
cluster  non  empty  V21() V22() V23()  compl-closed   sigma-multiplicative   sigma-additive   all-open-containing   closed_for_countable_unions   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='topgen_4.html#RC6'>topgen_4</span></td></tr>
<tr><td>
cluster  F_sigma   ->  Borel   for    Element of  bool  the carrier of T;
</td><td><span data-href='topgen_4.html#CC15'>topgen_4</span></td></tr>
<tr><td>
cluster  G_delta   ->  Borel   for    Element of  bool  the carrier of T;
</td><td><span data-href='topgen_4.html#CC16'>topgen_4</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   Function-like   one-to-one  V14(X)  quasi_total   onto   for    Element of  bool [:X,X:];
</td><td><span data-href='topgrp_1.html#RC1'>topgrp_1</span></td></tr>
<tr><td>
cluster  non  empty   dense   for    Element of  bool  the carrier of T;
</td><td><span data-href='topgrp_1.html#RC3'>topgrp_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   being_homeomorphism   ->  one-to-one   onto   continuous   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='topgrp_1.html#CC2'>topgrp_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   being_homeomorphism   ->  open   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='topgrp_1.html#CC3'>topgrp_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of T -defined   the carrier of T -valued   Function-like  V14( the carrier of T)  quasi_total   being_homeomorphism   for    Element of  bool [: the carrier of T, the carrier of T:];
</td><td><span data-href='topgrp_1.html#RC4'>topgrp_1</span></td></tr>
<tr><td>
cluster  empty   ->  sequentially_compact   for    Element of K19( the carrier of M);
</td><td><span data-href='topmetr4.html#CC1'>topmetr4</span></td></tr>
<tr><td>
cluster  being_S-P_arc   ->  non  empty   for    Element of K10( the carrier of (TOP-REAL 2));
</td><td><span data-href='topreal1.html#CC1'>topreal1</span></td></tr>
<tr><td>
cluster  functional   non  empty   being_simple_closed_curve   for    Element of K19( the carrier of (TOP-REAL 2));
</td><td><span data-href='topreal2.html#RC1'>topreal2</span></td></tr>
<tr><td>
cluster  being_simple_closed_curve   ->  non  empty   compact   for    Element of K19( the carrier of (TOP-REAL 2));
</td><td><span data-href='topreal2.html#CC1'>topreal2</span></td></tr>
<tr><td>
cluster  being_simple_closed_curve   ->  non  horizontal   non  vertical   for    Element of K16( the carrier of (TOP-REAL 2));
</td><td><span data-href='topreal5.html#CC1'>topreal5</span></td></tr>
<tr><td>
cluster  empty   ->  connected   for    Element of  bool  the carrier of T;
</td><td><span data-href='topreal6.html#CC1'>topreal6</span></td></tr>
<tr><td>
cluster  non  horizontal   ->  non  empty   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='topreal6.html#CC2'>topreal6</span></td></tr>
<tr><td>
cluster  non  vertical   ->  non  empty   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='topreal6.html#CC3'>topreal6</span></td></tr>
<tr><td>
cluster  being_Region   ->  open   connected   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='topreal6.html#CC4'>topreal6</span></td></tr>
<tr><td>
cluster  open   connected   ->  being_Region   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='topreal6.html#CC5'>topreal6</span></td></tr>
<tr><td>
cluster  empty   ->  horizontal   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='topreal6.html#CC6'>topreal6</span></td></tr>
<tr><td>
cluster  empty   ->  vertical   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='topreal6.html#CC7'>topreal6</span></td></tr>
<tr><td>
cluster  non  empty   convex   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='topreal6.html#RC1'>topreal6</span></td></tr>
<tr><td>
cluster  being_simple_closed_curve   ->  connected   for    Element of  bool  the carrier of (TOP-REAL 2);
</td><td><span data-href='topreal6.html#CC8'>topreal6</span></td></tr>
<tr><td>
cluster V1() V21() V30( the carrier of (TOP-REAL n), the carrier of (TOP-REAL n))  continuous   additive   homogeneous   for    Element of K16(K17( the carrier of (TOP-REAL n), the carrier of (TOP-REAL n)));
</td><td><span data-href='topreal9.html#RC1'>topreal9</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  continuous   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='topreala.html#CC3'>topreala</span></td></tr>
<tr><td>
cluster  Function-like   empty   quasi_total   ->  continuous   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='topreala.html#CC4'>topreala</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   the carrier of T -defined   the carrier of R^1 -valued   Function-like   non  empty   total  V18( the carrier of T, the carrier of R^1)  complex-valued   ext-real-valued   real-valued   continuous   for    Element of  bool [: the carrier of T, the carrier of R^1:];
</td><td><span data-href='toprealc.html#RC3'>toprealc</span></td></tr>
<tr><td>
cluster  open   for    Element of K10( the carrier of T);
</td><td><span data-href='tops_1.html#RC1'>tops_1</span></td></tr>
<tr><td>
cluster  empty   ->  open   for    Element of K10( the carrier of T);
</td><td><span data-href='tops_1.html#CC1'>tops_1</span></td></tr>
<tr><td>
cluster  open   closed   for    Element of K10( the carrier of T);
</td><td><span data-href='tops_1.html#RC2'>tops_1</span></td></tr>
<tr><td>
cluster  non  empty   open   closed   for    Element of K10( the carrier of T);
</td><td><span data-href='tops_1.html#RC3'>tops_1</span></td></tr>
<tr><td>
cluster  dense   for    Element of K10( the carrier of GX);
</td><td><span data-href='tops_1.html#RC4'>tops_1</span></td></tr>
<tr><td>
cluster  empty   ->  boundary   for    Element of K10( the carrier of GX);
</td><td><span data-href='tops_1.html#CC2'>tops_1</span></td></tr>
<tr><td>
cluster  boundary   for    Element of K10( the carrier of GX);
</td><td><span data-href='tops_1.html#RC5'>tops_1</span></td></tr>
<tr><td>
cluster  non  empty   non  boundary   for    Element of K10( the carrier of GX);
</td><td><span data-href='tops_1.html#RC6'>tops_1</span></td></tr>
<tr><td>
cluster  empty   ->  nowhere_dense   for    Element of K10( the carrier of TS);
</td><td><span data-href='tops_1.html#CC3'>tops_1</span></td></tr>
<tr><td>
cluster  nowhere_dense   for    Element of K10( the carrier of TS);
</td><td><span data-href='tops_1.html#RC7'>tops_1</span></td></tr>
<tr><td>
cluster  nowhere_dense   ->  boundary   for    Element of K10( the carrier of TS);
</td><td><span data-href='tops_1.html#CC4'>tops_1</span></td></tr>
<tr><td>
cluster  closed   boundary   ->  nowhere_dense   for    Element of K10( the carrier of TS);
</td><td><span data-href='tops_1.html#CC5'>tops_1</span></td></tr>
<tr><td>
cluster  open   nowhere_dense   ->  empty   for    Element of K10( the carrier of TS);
</td><td><span data-href='tops_1.html#CC6'>tops_1</span></td></tr>
<tr><td>
cluster  open   for    Element of  bool (bool  the carrier of X);
</td><td><span data-href='tops_2.html#RC1'>tops_2</span></td></tr>
<tr><td>
cluster  Relation-like   non  empty   for    Element of  bool [:a,b:];
</td><td><span data-href='trees_2.html#RC9'>trees_2</span></td></tr>
<tr><td>
cluster   ->  constituted-Trees   for    Element of  bool X;
</td><td><span data-href='trees_3.html#CC3'>trees_3</span></td></tr>
<tr><td>
cluster   ->  constituted-FinTrees   for    Element of  bool X;
</td><td><span data-href='trees_3.html#CC4'>trees_3</span></td></tr>
<tr><td>
cluster   ->  constituted-DTrees   for    Element of  bool X;
</td><td><span data-href='trees_3.html#CC5'>trees_3</span></td></tr>
<tr><td>
cluster  non  empty   constituted-Trees   constituted-FinTrees   for    Element of  bool Trees;
</td><td><span data-href='trees_3.html#RC3'>trees_3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  DecoratedTree-like   for    Element of  bool [:T,D:];
</td><td><span data-href='trees_3.html#CC12'>trees_3</span></td></tr>
<tr><td>
cluster  non  empty   cap-closed   ->  non  empty   quasi_basis   for    Element of  bool (bool [:X,X:]);
</td><td><span data-href='uniform2.html#CC7'>uniform2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of US1 -defined   the carrier of US2 -valued   Function-like  V31( the carrier of US1, the carrier of US2)  uniformly_continuous   for    Element of  bool [: the carrier of US1, the carrier of US2:];
</td><td><span data-href='uniform3.html#RC3'>uniform3</span></td></tr>
<tr><td>
cluster  union-closed   ->  cup-closed   for    Element of  bool (bool X);
</td><td><span data-href='uniform3.html#CC1'>uniform3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of L -valued   Function-like   non  empty   total   quasi_total   finite-Support   non-zero   for    Element of  bool [:NAT, the carrier of L:];
</td><td><span data-href='uproots.html#RC1'>uproots</span></td></tr>
<tr><td>
cluster   ->  complex-valued   for    Element of  bool R;
</td><td><span data-href='valued_0.html#CC10'>valued_0</span></td></tr>
<tr><td>
cluster   ->  ext-real-valued   for    Element of  bool R;
</td><td><span data-href='valued_0.html#CC11'>valued_0</span></td></tr>
<tr><td>
cluster   ->  real-valued   for    Element of  bool R;
</td><td><span data-href='valued_0.html#CC12'>valued_0</span></td></tr>
<tr><td>
cluster   ->  RAT  -valued   for    Element of  bool R;
</td><td><span data-href='valued_0.html#CC13'>valued_0</span></td></tr>
<tr><td>
cluster   ->  INT  -valued   for    Element of  bool R;
</td><td><span data-href='valued_0.html#CC14'>valued_0</span></td></tr>
<tr><td>
cluster   ->  natural-valued   for    Element of  bool R;
</td><td><span data-href='valued_0.html#CC15'>valued_0</span></td></tr>
<tr><td>
cluster   ->  complex-valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='valued_0.html#CC16'>valued_0</span></td></tr>
<tr><td>
cluster   ->  ext-real-valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='valued_0.html#CC17'>valued_0</span></td></tr>
<tr><td>
cluster   ->  real-valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='valued_0.html#CC18'>valued_0</span></td></tr>
<tr><td>
cluster   ->  RAT  -valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='valued_0.html#CC19'>valued_0</span></td></tr>
<tr><td>
cluster   ->  INT  -valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='valued_0.html#CC20'>valued_0</span></td></tr>
<tr><td>
cluster   ->  natural-valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='valued_0.html#CC21'>valued_0</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   NAT  -valued   Function-like   non  empty   total   quasi_total   complex-valued   ext-real-valued   real-valued   natural-valued   increasing   for    Element of  bool [:omega,NAT:];
</td><td><span data-href='valued_0.html#RC3'>valued_0</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined  X -valued   Function-like   constant   quasi_total   for    Element of  bool [:omega,X:];
</td><td><span data-href='valued_0.html#RC4'>valued_0</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined  X -valued   Function-like   non  empty   total   quasi_total   for    Element of  bool [:omega,X:];
</td><td><span data-href='valued_0.html#RC5'>valued_0</span></td></tr>
<tr><td>
cluster   ->  complex-functions-membered   for    Element of K19(X);
</td><td><span data-href='valued_2.html#CC9'>valued_2</span></td></tr>
<tr><td>
cluster   ->  ext-real-functions-membered   for    Element of K19(X);
</td><td><span data-href='valued_2.html#CC10'>valued_2</span></td></tr>
<tr><td>
cluster   ->  real-functions-membered   for    Element of K19(X);
</td><td><span data-href='valued_2.html#CC11'>valued_2</span></td></tr>
<tr><td>
cluster   ->  rational-functions-membered   for    Element of K19(X);
</td><td><span data-href='valued_2.html#CC12'>valued_2</span></td></tr>
<tr><td>
cluster   ->  integer-functions-membered   for    Element of K19(X);
</td><td><span data-href='valued_2.html#CC13'>valued_2</span></td></tr>
<tr><td>
cluster   ->  natural-functions-membered   for    Element of K19(X);
</td><td><span data-href='valued_2.html#CC14'>valued_2</span></td></tr>
<tr><td>
cluster  Function-like   ->  complex-functions-valued   for    Element of K19(K20(X,Y));
</td><td><span data-href='valued_2.html#CC28'>valued_2</span></td></tr>
<tr><td>
cluster  Function-like   ->  ext-real-functions-valued   for    Element of K19(K20(X,Y));
</td><td><span data-href='valued_2.html#CC29'>valued_2</span></td></tr>
<tr><td>
cluster  Function-like   ->  real-functions-valued   for    Element of K19(K20(X,Y));
</td><td><span data-href='valued_2.html#CC30'>valued_2</span></td></tr>
<tr><td>
cluster  Function-like   ->  rational-functions-valued   for    Element of K19(K20(X,Y));
</td><td><span data-href='valued_2.html#CC31'>valued_2</span></td></tr>
<tr><td>
cluster  Function-like   ->  integer-functions-valued   for    Element of K19(K20(X,Y));
</td><td><span data-href='valued_2.html#CC32'>valued_2</span></td></tr>
<tr><td>
cluster  Function-like   ->  natural-functions-valued   for    Element of K19(K20(X,Y));
</td><td><span data-href='valued_2.html#CC33'>valued_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of V -valued   non  empty   Function-like   total   quasi_total   onto   isometric   for    Element of  bool [: the carrier of V, the carrier of V:];
</td><td><span data-href='vectmetr.html#RC2'>vectmetr</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   isometric   ->  one-to-one   for    Element of  bool [: the carrier of V, the carrier of V:];
</td><td><span data-href='vectmetr.html#CC2'>vectmetr</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of K)  Function-like   non  empty  V14( the carrier of V)  quasi_total   additive   0-preserving   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#RC5'>vectsp10</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#CC1'>vectsp10</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#CC2'>vectsp10</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of K)  Function-like   constant   non  empty  V14( the carrier of V)  quasi_total   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#RC6'>vectsp10</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of K)  Function-like   constant   non  empty  V14( the carrier of V)  quasi_total   additive   0-preserving   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#RC7'>vectsp10</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of K)  Function-like   non  constant   non  empty   non  trivial  V14( the carrier of V)  quasi_total   additive   homogeneous   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#RC8'>vectsp10</span></td></tr>
<tr><td>
cluster  Function-like   trivial   quasi_total   ->  constant   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#CC3'>vectsp10</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   0-preserving   non  degenerated   ->  non  constant   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#CC4'>vectsp10</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of V -valued   Function-like   non  empty   total   quasi_total   additive   homogeneous   with_eigenvalues   for    Element of  bool [: the carrier of V, the carrier of V:];
</td><td><span data-href='vectsp11.html#RC2'>vectsp11</span></td></tr>
<tr><td>
cluster  empty   ->  linearly-independent   for    Element of  bool  the carrier of V;
</td><td><span data-href='vectsp_7.html#CC1'>vectsp_7</span></td></tr>
<tr><td>
cluster  finite   linearly-independent   for    Element of  bool  the carrier of V;
</td><td><span data-href='vectsp_7.html#RC1'>vectsp_7</span></td></tr>
<tr><td>
cluster  base   for    Element of  bool  the carrier of V;
</td><td><span data-href='vectsp_7.html#RC2'>vectsp_7</span></td></tr>
<tr><td>
cluster  non  empty   for    Element of K1( the carrier of S);
</td><td><span data-href='vectsp_9.html#RC1'>vectsp_9</span></td></tr>
<tr><td>
cluster  linearly-independent   for    Element of K1( the carrier of V);
</td><td><span data-href='vectsp_9.html#RC2'>vectsp_9</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like  V24( the carrier of S)  quasi_total   monotone   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel10.html#RC1'>waybel10</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   projection   ->  idempotent   monotone   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel10.html#CC1'>waybel10</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L -defined   the carrier of L -valued   Function-like  V7()  non  empty  V24( the carrier of L)  quasi_total   infs-preserving   sups-preserving   closure   kernel   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel10.html#RC2'>waybel10</span></td></tr>
<tr><td>
cluster  non  empty   finite   directed   for    Element of  bool  the carrier of T;
</td><td><span data-href='waybel11.html#RC1'>waybel11</span></td></tr>
<tr><td>
cluster   ->  finite   for    Element of  bool  the carrier of T;
</td><td><span data-href='waybel11.html#CC1'>waybel11</span></td></tr>
<tr><td>
cluster  empty   ->  lower   upper   for    Element of  bool  the carrier of R;
</td><td><span data-href='waybel11.html#CC2'>waybel11</span></td></tr>
<tr><td>
cluster   ->  upper   for    Element of  bool  the carrier of R;
</td><td><span data-href='waybel11.html#CC3'>waybel11</span></td></tr>
<tr><td>
cluster  empty   ->  directly_closed   property(S)   for    Element of  bool  the carrier of T;
</td><td><span data-href='waybel11.html#CC4'>waybel11</span></td></tr>
<tr><td>
cluster  directly_closed   property(S)   for    Element of  bool  the carrier of T;
</td><td><span data-href='waybel11.html#RC3'>waybel11</span></td></tr>
<tr><td>
cluster   ->  inaccessible   for    Element of  bool  the carrier of T;
</td><td><span data-href='waybel11.html#CC5'>waybel11</span></td></tr>
<tr><td>
cluster  lower   upper   inaccessible   directly_closed   for    Element of  bool  the carrier of T;
</td><td><span data-href='waybel11.html#RC5'>waybel11</span></td></tr>
<tr><td>
cluster  lower   ->  property(S)   for    Element of  bool  the carrier of T;
</td><td><span data-href='waybel11.html#CC6'>waybel11</span></td></tr>
<tr><td>
cluster  lower   Open   ->  filtered   for    Element of  bool  the carrier of L;
</td><td><span data-href='waybel12.html#CC1'>waybel12</span></td></tr>
<tr><td>
cluster  lower   ->  Open   for    Element of  bool  the carrier of L;
</td><td><span data-href='waybel12.html#CC2'>waybel12</span></td></tr>
<tr><td>
cluster  non  empty   finite   countable   dense   for    Element of  bool  the carrier of L;
</td><td><span data-href='waybel12.html#RC3'>waybel12</span></td></tr>
<tr><td>
cluster  non  empty   directed   lower   principal   for    Element of K32( the carrier of L);
</td><td><span data-href='waybel13.html#RC1'>waybel13</span></td></tr>
<tr><td>
cluster  Function-like  V21( the carrier of L1, the carrier of L2)  isomorphic   ->  infs-preserving   sups-preserving   for    Element of K32(K33( the carrier of L1, the carrier of L2));
</td><td><span data-href='waybel13.html#CC1'>waybel13</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   directed-sups-preserving   ->  monotone   for    Element of K32(K33( the carrier of S, the carrier of T));
</td><td><span data-href='waybel17.html#CC1'>waybel17</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   continuous   ->  monotone   for    Element of K32(K33( the carrier of S, the carrier of T));
</td><td><span data-href='waybel17.html#CC2'>waybel17</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   continuous   ->  directed-sups-preserving   for    Element of K32(K33( the carrier of S, the carrier of T));
</td><td><span data-href='waybel17.html#CC3'>waybel17</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   directed-sups-preserving   ->  continuous   for    Element of K32(K33( the carrier of S, the carrier of T));
</td><td><span data-href='waybel17.html#CC4'>waybel17</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of L -defined   the carrier of L -valued   Function-like  V17( the carrier of L) V28( the carrier of L, the carrier of L)  directed-sups-preserving   kernel   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel20.html#RC1'>waybel20</span></td></tr>
<tr><td>
cluster  Function-like  V29( the carrier of S, the carrier of T)  meet-preserving   ->  monotone   for    Element of K22(K23( the carrier of S, the carrier of T));
</td><td><span data-href='waybel21.html#CC1'>waybel21</span></td></tr>
<tr><td>
cluster  infs-closed   ->  meet-closed   for    Element of K32( the carrier of L);
</td><td><span data-href='waybel23.html#CC1'>waybel23</span></td></tr>
<tr><td>
cluster  sups-closed   ->  join-closed   for    Element of K32( the carrier of L);
</td><td><span data-href='waybel23.html#CC2'>waybel23</span></td></tr>
<tr><td>
cluster  non  empty   infs-closed   sups-closed   for    Element of K32( the carrier of L);
</td><td><span data-href='waybel23.html#RC1'>waybel23</span></td></tr>
<tr><td>
cluster  meet-closed   ->  filtered   for    Element of K32( the carrier of L);
</td><td><span data-href='waybel23.html#CC3'>waybel23</span></td></tr>
<tr><td>
cluster  join-closed   ->  directed   for    Element of K32( the carrier of L);
</td><td><span data-href='waybel23.html#CC4'>waybel23</span></td></tr>
<tr><td>
cluster  with_bottom   ->  non  empty   for    Element of K32( the carrier of L);
</td><td><span data-href='waybel23.html#CC5'>waybel23</span></td></tr>
<tr><td>
cluster  with_top   ->  non  empty   for    Element of K32( the carrier of L);
</td><td><span data-href='waybel23.html#CC6'>waybel23</span></td></tr>
<tr><td>
cluster  with_bottom   for    Element of K32( the carrier of L);
</td><td><span data-href='waybel23.html#RC2'>waybel23</span></td></tr>
<tr><td>
cluster  with_top   for    Element of K32( the carrier of L);
</td><td><span data-href='waybel23.html#RC3'>waybel23</span></td></tr>
<tr><td>
cluster  Function-like   constant   quasi_total   ->  monotone   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel24.html#CC1'>waybel24</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like  V14( the carrier of S)  quasi_total   antitone   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel24.html#RC1'>waybel24</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   continuous   ->  monotone   for    Element of  bool [: the carrier of (Omega X), the carrier of (Omega Y):];
</td><td><span data-href='waybel25.html#CC3'>waybel25</span></td></tr>
<tr><td>
cluster  open   ->  upper   for    Element of  bool  the carrier of (Omega T);
</td><td><span data-href='waybel25.html#CC4'>waybel25</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   continuous   ->  directed-sups-preserving   for    Element of  bool [: the carrier of (Omega X), the carrier of (Omega Y):];
</td><td><span data-href='waybel25.html#CC9'>waybel25</span></td></tr>
<tr><td>
cluster   ->  Relation-like   for    Element of  bool  the carrier of [:X,Y:];
</td><td><span data-href='waybel26.html#CC1'>waybel26</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of N -defined   the carrier of N -valued   Function-like  V37( the carrier of N) V38( the carrier of N, the carrier of N)  greater_or_equal_to_id   for    Element of  bool [: the carrier of N, the carrier of N:];
</td><td><span data-href='waybel28.html#RC1'>waybel28</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of N -defined   the carrier of N -valued   Function-like  V37( the carrier of N) V38( the carrier of N, the carrier of N)  greater_or_equal_to_id   for    Element of  bool [: the carrier of N, the carrier of N:];
</td><td><span data-href='waybel28.html#RC2'>waybel28</span></td></tr>
<tr><td>
cluster  lower   ->  property(S)   for    Element of  bool  the carrier of T;
</td><td><span data-href='waybel32.html#CC4'>waybel32</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like   non  empty  V22( the carrier of S)  quasi_total   infs-preserving   directed-sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#RC2'>waybel34</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like   non  empty  V22( the carrier of S)  quasi_total   sups-preserving   filtered-infs-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#RC3'>waybel34</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   sups-preserving   ->  bottom-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#CC1'>waybel34</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like   non  empty  V22( the carrier of S)  quasi_total   sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#RC4'>waybel34</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   sups-preserving   ->  finite-sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#CC6'>waybel34</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   finite-sups-preserving   ->  join-preserving   bottom-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#CC7'>waybel34</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like   non  empty  V22( the carrier of S)  quasi_total   sups-preserving   finite-sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#RC6'>waybel34</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L -defined   the carrier of L -valued   auxiliary(i)   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#RC1'>waybel35</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L -defined   the carrier of L -valued   auxiliary(i)   auxiliary(ii)   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#RC2'>waybel35</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L -defined   the carrier of L -valued   auxiliary(iii)   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#RC3'>waybel35</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L -defined   the carrier of L -valued   auxiliary(iv)   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#RC4'>waybel35</span></td></tr>
<tr><td>
cluster  extra-order   ->  auxiliary(i)   auxiliary(ii)   auxiliary(iv)   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#CC1'>waybel35</span></td></tr>
<tr><td>
cluster  auxiliary(i)   auxiliary(ii)   auxiliary(iv)   ->  extra-order   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#CC2'>waybel35</span></td></tr>
<tr><td>
cluster  auxiliary(iii)   extra-order   ->  auxiliary   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#CC3'>waybel35</span></td></tr>
<tr><td>
cluster  auxiliary   ->  extra-order   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#CC4'>waybel35</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L -defined   the carrier of L -valued   extra-order   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#RC5'>waybel35</span></td></tr>
<tr><td>
cluster  empty   ->  directed   filtered   for    Element of K10( the carrier of L);
</td><td><span data-href='waybel_0.html#CC1'>waybel_0</span></td></tr>
<tr><td>
cluster  directed   filtered   for    Element of K10( the carrier of L);
</td><td><span data-href='waybel_0.html#RC1'>waybel_0</span></td></tr>
<tr><td>
cluster  non  empty   finite   directed   filtered   for    Element of K10( the carrier of L);
</td><td><span data-href='waybel_0.html#RC2'>waybel_0</span></td></tr>
<tr><td>
cluster  lower   upper   for    Element of K10( the carrier of L);
</td><td><span data-href='waybel_0.html#RC7'>waybel_0</span></td></tr>
<tr><td>
cluster  non  empty   lower   upper   for    Element of K10( the carrier of L);
</td><td><span data-href='waybel_0.html#RC8'>waybel_0</span></td></tr>
<tr><td>
cluster  non  empty   directed   lower   for    Element of K10( the carrier of L);
</td><td><span data-href='waybel_0.html#RC9'>waybel_0</span></td></tr>
<tr><td>
cluster  non  empty   filtered   upper   for    Element of K10( the carrier of L);
</td><td><span data-href='waybel_0.html#RC10'>waybel_0</span></td></tr>
<tr><td>
cluster  non  empty   directed   filtered   lower   upper   for    Element of K10( the carrier of L);
</td><td><span data-href='waybel_0.html#RC11'>waybel_0</span></td></tr>
<tr><td>
cluster  Function-like  V21( the carrier of L1, the carrier of L2)  infs-preserving   ->  meet-preserving   filtered-infs-preserving   for    Element of K10(K11( the carrier of L1, the carrier of L2));
</td><td><span data-href='waybel_0.html#CC7'>waybel_0</span></td></tr>
<tr><td>
cluster  Function-like  V21( the carrier of L1, the carrier of L2)  sups-preserving   ->  join-preserving   directed-sups-preserving   for    Element of K10(K11( the carrier of L1, the carrier of L2));
</td><td><span data-href='waybel_0.html#CC8'>waybel_0</span></td></tr>
<tr><td>
cluster  Function-like  V21( the carrier of S, the carrier of T)  isomorphic   ->  one-to-one   monotone   for    Element of K10(K11( the carrier of S, the carrier of T));
</td><td><span data-href='waybel_0.html#CC9'>waybel_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   upper_adjoint   ->  infs-preserving   for   M3( bool [: the carrier of S, the carrier of T:]);
</td><td><span data-href='waybel_1.html#CC1'>waybel_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   lower_adjoint   ->  sups-preserving   for   M3( bool [: the carrier of S, the carrier of T:]);
</td><td><span data-href='waybel_1.html#CC2'>waybel_1</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( the carrier of L) V11( the carrier of L)  Function-like  V27( the carrier of L)  quasi_total   projection   for   M3( bool [: the carrier of L, the carrier of L:]);
</td><td><span data-href='waybel_1.html#RC1'>waybel_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   closure   ->  projection   for   M3( bool [: the carrier of L, the carrier of L:]);
</td><td><span data-href='waybel_1.html#CC3'>waybel_1</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( the carrier of L) V11( the carrier of L)  Function-like  V27( the carrier of L)  quasi_total   closure   for   M3( bool [: the carrier of L, the carrier of L:]);
</td><td><span data-href='waybel_1.html#RC2'>waybel_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   kernel   ->  projection   for   M3( bool [: the carrier of L, the carrier of L:]);
</td><td><span data-href='waybel_1.html#CC4'>waybel_1</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( the carrier of L) V11( the carrier of L)  Function-like  V27( the carrier of L)  quasi_total   kernel   for   M3( bool [: the carrier of L, the carrier of L:]);
</td><td><span data-href='waybel_1.html#RC3'>waybel_1</span></td></tr>
<tr><td>
cluster   ->  directed   filtered   for    Element of K10( the carrier of L);
</td><td><span data-href='waybel_3.html#CC1'>waybel_3</span></td></tr>
<tr><td>
cluster  auxiliary   ->  auxiliary(i)   auxiliary(ii)   auxiliary(iii)   auxiliary(iv)   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#CC1'>waybel_4</span></td></tr>
<tr><td>
cluster  auxiliary(i)   auxiliary(ii)   auxiliary(iii)   auxiliary(iv)   ->  auxiliary   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#CC2'>waybel_4</span></td></tr>
<tr><td>
cluster  Relation-like   auxiliary   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#RC1'>waybel_4</span></td></tr>
<tr><td>
cluster  auxiliary(i)   auxiliary(ii)   ->  transitive   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#CC3'>waybel_4</span></td></tr>
<tr><td>
cluster  Relation-like   auxiliary   approximating   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#RC2'>waybel_4</span></td></tr>
<tr><td>
cluster  satisfying_SI   ->  satisfying_INT   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#CC5'>waybel_4</span></td></tr>
<tr><td>
cluster  auxiliary   approximating   satisfying_INT   ->  auxiliary   approximating   satisfying_SI   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#CC6'>waybel_4</span></td></tr>
<tr><td>
cluster  strongly_connected   ->  directed   filtered   for    Element of  bool  the carrier of L;
</td><td><span data-href='waybel_6.html#CC1'>waybel_6</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like  V35( the carrier of S, the carrier of T)  sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel_6.html#RC2'>waybel_6</span></td></tr>
<tr><td>
cluster  non  empty   filtered   upper   Open   for    Element of  bool  the carrier of L;
</td><td><span data-href='waybel_6.html#RC3'>waybel_6</span></td></tr>
<tr><td>
cluster  non  empty   proper   filtered   upper   for    Element of  bool  the carrier of L;
</td><td><span data-href='waybel_7.html#RC2'>waybel_7</span></td></tr>
<tr><td>
cluster  non  empty   directed   lower   prime   for    Element of  bool  the carrier of L;
</td><td><span data-href='waybel_7.html#RC3'>waybel_7</span></td></tr>
<tr><td>
cluster  non  empty   filtered   upper   prime   for    Element of  bool  the carrier of L;
</td><td><span data-href='waybel_7.html#RC4'>waybel_7</span></td></tr>
<tr><td>
cluster  non  empty   filtered   upper   ultra   ->  proper   for    Element of  bool  the carrier of L;
</td><td><span data-href='waybel_7.html#CC1'>waybel_7</span></td></tr>
<tr><td>
cluster  non  empty   filtered   upper   ultra   for    Element of  bool  the carrier of (BoolePoset X);
</td><td><span data-href='waybel_7.html#RC5'>waybel_7</span></td></tr>
<tr><td>
cluster  non  empty   directed   for    Element of  bool  the carrier of (Image c);
</td><td><span data-href='waybel_8.html#RC2'>waybel_8</span></td></tr>
<tr><td>
cluster  well_founded   for    Element of  bool  the carrier of R;
</td><td><span data-href='wellfnd1.html#RC3'>wellfnd1</span></td></tr>
<tr><td>
cluster  empty   ->  Open   for   M3( bool  the carrier of S);
</td><td><span data-href='yellow10.html#CC1'>yellow10</span></td></tr>
<tr><td>
cluster  non  empty   interval   ->  directed   for    Element of  bool  the carrier of L;
</td><td><span data-href='yellow11.html#CC2'>yellow11</span></td></tr>
<tr><td>
cluster  non  empty   interval   ->  filtered   for    Element of  bool  the carrier of L;
</td><td><span data-href='yellow11.html#CC3'>yellow11</span></td></tr>
<tr><td>
cluster  open   quasi_basis   ->  non  empty   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='yellow12.html#CC1'>yellow12</span></td></tr>
<tr><td>
cluster  open  V228(T,x)  ->  non  empty   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='yellow12.html#CC2'>yellow12</span></td></tr>
<tr><td>
cluster  finite   ->  closed   for    Element of  bool  the carrier of T;
</td><td><span data-href='yellow13.html#CC1'>yellow13</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   isomorphic   ->  onto   for    Element of K6(K7( the carrier of S, the carrier of T));
</td><td><span data-href='yellow14.html#CC2'>yellow14</span></td></tr>
<tr><td>
cluster  open   ->  upper   inaccessible   for    Element of K6( the carrier of T);
</td><td><span data-href='yellow14.html#CC4'>yellow14</span></td></tr>
<tr><td>
cluster  upper   inaccessible   ->  open   for    Element of K6( the carrier of T);
</td><td><span data-href='yellow14.html#CC5'>yellow14</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like   non  empty  V24( the carrier of S)  quasi_total   monotone   directed-sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='yellow16.html#RC1'>yellow16</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of S -valued   Function-like  V24( the carrier of S)  quasi_total   idempotent   for    Element of  bool [: the carrier of S, the carrier of S:];
</td><td><span data-href='yellow16.html#RC2'>yellow16</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   well-ordering   reflexive   antisymmetric   transitive  V24(X)  quasi_total   upper-bounded   for    Element of  bool [:X,X:];
</td><td><span data-href='yellow21.html#RC4'>yellow21</span></td></tr>
<tr><td>
cluster  open  x -quasi_basis   for    Element of  bool (bool  the carrier of T);
</td><td><span data-href='yellow_8.html#RC1'>yellow_8</span></td></tr>
<tr><td>
cluster  irreducible   ->  non  empty   for    Element of  bool  the carrier of T;
</td><td><span data-href='yellow_8.html#CC1'>yellow_8</span></td></tr>
<tr><td>
cluster  irreducible   for    Element of  bool  the carrier of T;
</td><td><span data-href='yellow_8.html#RC2'>yellow_8</span></td></tr>
<tr><td>
cluster  irreducible   ->  trivial   for    Element of  bool  the carrier of T;
</td><td><span data-href='yellow_8.html#CC2'>yellow_8</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like  V27( the carrier of S)  quasi_total   infs-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='yellow_9.html#RC2'>yellow_9</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like  V27( the carrier of S)  quasi_total   sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='yellow_9.html#RC3'>yellow_9</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   non  empty   total   quasi_total  V53() V54() V55()  additive   homogeneous   0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC3'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   non  empty   total   quasi_total  V53() V54() V55()  additive   0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC4'>zmatrlin</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#CC1'>zmatrlin</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#CC2'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   constant   non  empty   total   quasi_total  V53() V54() V55()  for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC5'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   constant   non  empty   total   quasi_total  V53() V54() V55()  additive   0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC6'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   non  constant   non  empty   non  trivial   total   quasi_total  V53() V54() V55()  additive   homogeneous   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC7'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of INT.Ring -valued   Function-like   non  empty   total   quasi_total  V53() V54() V55()  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC8'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of INT.Ring -valued   Function-like   non  constant   non  empty   non  trivial   total   quasi_total  V53() V54() V55()  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC9'>zmatrlin</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, the carrier of F_Real)  homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#CC3'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of F_Real -valued   Function-like   non  empty   total  V18( the carrier of V, the carrier of F_Real) V71() V72() V73()  additive   homogeneous   0-preserving   for    Element of  bool [: the carrier of V, the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC14'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of F_Real -valued   Function-like   non  empty   total  V18([: the carrier of V, the carrier of W:], the carrier of F_Real) V71() V72() V73()  additiveFAF   additiveSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC15'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of F_Real -valued   Function-like   non  empty   total  V18([: the carrier of V, the carrier of W:], the carrier of F_Real) V71() V72() V73()  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC16'>zmodlat1</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, the carrier of F_Real)  homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#CC4'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of F_Real -valued   Function-like   non  empty   total  V18( the carrier of V, the carrier of F_Real) V71() V72() V73()  additive   homogeneous   0-preserving   for    Element of  bool [: the carrier of V, the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC17'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of F_Real -valued   Function-like   non  constant   non  empty   non  trivial   total  V18( the carrier of V, the carrier of F_Real) V71() V72() V73()  additive   homogeneous   for    Element of  bool [: the carrier of V, the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC18'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of F_Real -valued   Function-like   non  constant   non  empty   non  trivial   total  V18([: the carrier of V, the carrier of W:], the carrier of F_Real) V71() V72() V73()  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC19'>zmodlat1</span></td></tr>
<tr><td>
cluster  base   ->  non  empty   for    Element of  bool  the carrier of V;
</td><td><span data-href='zmodlat2.html#CC1'>zmodlat2</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of F_Real -valued   Function-like   non  empty   total   quasi_total  V71() V72() V73()  symmetric   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Real:];
</td><td><span data-href='zmodlat2.html#RC2'>zmodlat2</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of F_Real -valued   Function-like   non  empty   total   quasi_total  V71() V72() V73() V252(V,V) V253(V,V) V254(V,V) V255(V,V)  symmetric   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Real:];
</td><td><span data-href='zmodlat2.html#RC3'>zmodlat2</span></td></tr>
<tr><td>
cluster  linearly-closed   for    Element of  bool  the carrier of V;
</td><td><span data-href='zmodul01.html#RC2'>zmodul01</span></td></tr>
<tr><td>
cluster  linearly-independent   for    Element of  bool  the carrier of V;
</td><td><span data-href='zmodul02.html#RC2'>zmodul02</span></td></tr>
<tr><td>
cluster  finite   linearly-independent   for    Element of  bool  the carrier of V;
</td><td><span data-href='zmodul03.html#RC2'>zmodul03</span></td></tr>
<tr><td>
cluster  base   for    Element of  bool  the carrier of V;
</td><td><span data-href='zmodul03.html#RC5'>zmodul03</span></td></tr>
<tr><td>
cluster  base   ->  finite   for    Element of  bool  the carrier of V;
</td><td><span data-href='zmodul03.html#CC2'>zmodul03</span></td></tr>
<tr><td>
cluster  finite   base   for    Element of K10( the carrier of V);
</td><td><span data-href='zmodul05.html#RC1'>zmodul05</span></td></tr>
<tr><td>
cluster  base   ->  finite   for    Element of K10( the carrier of V);
</td><td><span data-href='zmodul05.html#CC1'>zmodul05</span></td></tr>
<tr><td>
cluster  linearly-dependent   for    Element of K10( the carrier of V);
</td><td><span data-href='zmodul05.html#RC2'>zmodul05</span></td></tr>
<tr><td>
cluster  linearly-independent   ->  finite   for    Element of  bool  the carrier of V;
</td><td><span data-href='zmodul07.html#CC2'>zmodul07</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
</body>
</html>
