<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<title>INT.Ring</title>
</head>
<body>
<div class='mml-summary'>
<h1>func INT.Ring</h1>
<h2>List of Definitions (2)</h2>
<ol>
<li><span data-link='4294.html#ELM12468'>INT.Ring</span> [<span data-href='int_3.html#K1'>int_3</span>]</li>
<li><span data-link='4294.html#ELM12476'>INT.Ring</span> [<span data-href='int_3.html#K9'>int_3</span>]</li>
</ol>
</div>
<div class='mml-element' id='ELM12468'>
<h2>1.   <span data-link='4294.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='int_3.html#K1'>int_3</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K1"><span class="kw">func</span> </a> <span title="INT_3:func.1" data-link="4294.html#ELM12468">INT.Ring</span> <span class="kw"> -&gt; </span>   <span title="ALGSTR_0:struct.6" data-link="324.html#ELM743">doubleLoopStr</span> <span class="kw"> equals </span><a name="D3"><span class="comment"><font color="firebrick">:: INT_3:def 3</font></span><br></a> <span title="ALGSTR_0:aggr.6" data-href="algstr_0.html#G6">doubleLoopStr</span>(# <span title="NUMBERS:func.4" data-link="2849.html#ELM18627">INT</span>,<span title="BINOP_2:func.20" data-link="1146.html#ELM2780">addint</span>,<span title="BINOP_2:func.22" data-link="1148.html#ELM2782">multint</span>,<span class="p1">(<span class="default"><span title="SUBSET_1:func.10" data-link="8054.html#ELM25879">In</span> (1,<span title="NUMBERS:func.4" data-link="2849.html#ELM18627">INT</span>)</span>)</span>,<span class="p1">(<span class="default"><span title="SUBSET_1:func.10" data-link="8054.html#ELM25879">In</span> (<span title="NUMBERS:func.5" data-link="6192.html#ELM18628">0</span>,<span title="NUMBERS:func.4" data-link="2849.html#ELM18627">INT</span>)</span>)</span> #);<br>
</div>
<span class="kw">coherence</span> <br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  non  empty   non  degenerated  V62()  left_add-cancelable   right_add-cancelable   left_complementable   right_complementable   almost_left_cancelable   almost_right_cancelable   non  almost_left_invertible   right-distributive   left-distributive   right_unital   well-unital  V111()  left_unital   Abelian   add-associative   right_zeroed  V128()  unital  V133() V135()  domRing-like  V250() V251() V252() V253() K717() -homomorphic   factorial   for    doubleLoopStr ;
</td><td><span data-href='field_1.html#RC1'>field_1</span></td></tr>
<tr><td>
cluster  non  empty   left_add-cancelable   right_add-cancelable   left_complementable   right_complementable   right-distributive   left-distributive   right_unital   well-unital  V111()  left_unital   Abelian   add-associative   right_zeroed  V128()  unital  V133() V250() V251() V252() V253() R -homomorphic  K717() -homomorphic  K717() -homomorphic  R -monomorphic   for    doubleLoopStr ;
</td><td><span data-href='field_1.html#RC2'>field_1</span></td></tr>
<tr><td>
cluster  non  empty   left_add-cancelable   right_add-cancelable   left_complementable   right_complementable   right-distributive   left-distributive   right_unital   well-unital  V111()  left_unital   Abelian   add-associative   right_zeroed  V128()  unital  V133() V250() V251() V252() V253() R -homomorphic  K717() -homomorphic  K717() -homomorphic  R -isomorphic   for    doubleLoopStr ;
</td><td><span data-href='field_1.html#RC3'>field_1</span></td></tr>
<tr><td>
cluster  non  empty   for    AlgebraStr over  INT.Ring ;
</td><td><span data-href='gaussint.html#RC1'>gaussint</span></td></tr>
<tr><td>
cluster  non  empty   right_complementable   associative   commutative   Abelian   add-associative   right_zeroed   right-distributive   right_unital   vector-distributive   scalar-distributive   scalar-associative   strict   mix-associative   for    AlgebraStr over  INT.Ring ;
</td><td><span data-href='gaussint.html#RC2'>gaussint</span></td></tr>
<tr><td>
cluster  INT.Ring  ->  Noetherian  ;
</td><td><span data-href='ideal_1.html#FC32'>ideal_1</span></td></tr>
<tr><td>
cluster  INT.Ring  ->  non  empty   strict  ;
</td><td><span data-href='int_3.html#FC1'>int_3</span></td></tr>
<tr><td>
cluster  the carrier of INT.Ring ->  integer-membered  ;
</td><td><span data-href='int_3.html#FC2'>int_3</span></td></tr>
<tr><td>
cluster  INT.Ring  ->  well-unital  ;
</td><td><span data-href='int_3.html#FC3'>int_3</span></td></tr>
<tr><td>
cluster  INT.Ring  ->  non  degenerated   right_complementable   associative   commutative   Abelian   add-associative   right_zeroed   distributive   domRing-like  ;
</td><td><span data-href='int_3.html#FC4'>int_3</span></td></tr>
<tr><td>
cluster  INT.Ring  ->  Euclidian  ;
</td><td><span data-href='int_3.html#FC5'>int_3</span></td></tr>
<tr><td>
cluster  INT.Ring  ->  infinite  ;
</td><td><span data-href='int_3.html#FC8'>int_3</span></td></tr>
<tr><td>
cluster  non  empty   non  degenerated   non  trivial   left_add-cancelable   right_add-cancelable   add-cancelable   left_complementable   right_complementable   complementable   almost_left_cancelable   almost_right_cancelable   almost_cancelable   almost_left_invertible   almost_right_invertible   almost_invertible   unital   associative   commutative   Abelian   add-associative   right_zeroed  V116()  right-distributive   left-distributive   right_unital   well-unital   distributive   left_unital   domRing-like  V189() V190() V191() V192()  Euclidian  V295( INT.Ring )  preordered   for    doubleLoopStr ;
</td><td><span data-href='realalg1.html#RC6'>realalg1</span></td></tr>
<tr><td>
cluster  non  empty   non  degenerated   non  trivial   left_add-cancelable   right_add-cancelable   add-cancelable   left_complementable   right_complementable   complementable   almost_left_cancelable   almost_right_cancelable   almost_cancelable   almost_left_invertible   almost_right_invertible   almost_invertible   unital   associative   commutative   Abelian   add-associative   right_zeroed  V116()  right-distributive   left-distributive   right_unital   well-unital   distributive   left_unital   domRing-like  V189() V190() V191() V192()  Euclidian  V295( INT.Ring )  ordered   for    doubleLoopStr ;
</td><td><span data-href='realalg1.html#RC7'>realalg1</span></td></tr>
<tr><td>
cluster  INT.Ring  ->  ordered  ;
</td><td><span data-href='realalg1.html#FC26'>realalg1</span></td></tr>
<tr><td>
cluster  prepositive_cone   ->  spanning   for    Element of  bool  the carrier of INT.Ring;
</td><td><span data-href='realalg2.html#CC2'>realalg2</span></td></tr>
<tr><td>
cluster  non  empty   non  degenerated   non  trivial   left_complementable   right_complementable   complementable   almost_left_invertible   unital   associative   commutative   Abelian   add-associative   right_zeroed  V139()  right-distributive   left-distributive   right_unital   well-unital  V144()  left_unital   domRing-like   Euclidian  V277( INT.Ring )  formally_real   for    doubleLoopStr ;
</td><td><span data-href='realalg2.html#RC2'>realalg2</span></td></tr>
<tr><td>
cluster  left_add-cancelable   right_add-cancelable   add-cancelable   left_complementable   right_complementable   complementable  V106()  integer   complex   ext-real  V192()  prime   for    Element of  the carrier of INT.Ring;
</td><td><span data-href='ring_2.html#RC16'>ring_2</span></td></tr>
<tr><td>
cluster V31()  integer   left_add-cancelable   right_add-cancelable   add-cancelable   left_complementable   right_complementable   complementable   ext-real   positive   complex   rational   g_integer   g_rational   for    Element of  the carrier of INT.Ring;
</td><td><span data-href='ring_3.html#RC1'>ring_3</span></td></tr>
<tr><td>
cluster V31()  integer   left_add-cancelable   right_add-cancelable   add-cancelable   left_complementable   right_complementable   complementable   ext-real   negative   complex   rational   g_integer   g_rational   for    Element of  the carrier of INT.Ring;
</td><td><span data-href='ring_3.html#RC2'>ring_3</span></td></tr>
<tr><td>
cluster  INT.Ring  ->  0  -characteristic  ;
</td><td><span data-href='ring_3.html#FC8'>ring_3</span></td></tr>
<tr><td>
cluster  non  empty   right_complementable   associative   Abelian   add-associative   right_zeroed   well-unital   distributive   ->  INT.Ring  -homomorphic   for    doubleLoopStr ;
</td><td><span data-href='ring_3.html#CC8'>ring_3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of INT.Ring -defined   the carrier of R -valued   Function-like   non  empty  V14( the carrier of INT.Ring)  quasi_total   unity-preserving   additive   monomorphism   multiplicative   for    Element of  bool [: the carrier of INT.Ring, the carrier of R:];
</td><td><span data-href='ring_3.html#RC31'>ring_3</span></td></tr>
<tr><td>
cluster  non  empty   non  degenerated   non  trivial   left_add-cancelable   right_add-cancelable   add-cancelable   left_complementable   right_complementable   complementable   almost_left_invertible   unital   associative   commutative   Abelian   add-associative   right_zeroed  V110()  right-distributive   left-distributive   right_unital   well-unital   distributive   left_unital   domRing-like  V143() V192() V193() V194() V195()  PID   Euclidian   INT.Ring  -homomorphic   factorial   0  -characteristic   for    doubleLoopStr ;
</td><td><span data-href='ring_3.html#RC32'>ring_3</span></td></tr>
<tr><td>
cluster  non  empty   non  degenerated   non  trivial   left_add-cancelable   right_add-cancelable   add-cancelable   left_complementable   right_complementable   complementable   almost_left_invertible   unital   associative   commutative   Abelian   add-associative   right_zeroed  V110()  right-distributive   left-distributive   right_unital   well-unital   distributive   left_unital   domRing-like  V143() V192() V193() V194() V195()  PID   Euclidian   INT.Ring  -homomorphic   factorial  p -characteristic   for    doubleLoopStr ;
</td><td><span data-href='ring_3.html#RC33'>ring_3</span></td></tr>
<tr><td>
cluster  non  empty   non  degenerated   non  trivial   left_add-cancelable   right_add-cancelable   add-cancelable   left_complementable   right_complementable   complementable   almost_left_invertible   unital   associative   commutative   Abelian   add-associative   right_zeroed  V110()  right-distributive   left-distributive   right_unital   well-unital   distributive   left_unital   domRing-like  V143() V192() V193() V194() V195()  PID   Euclidian   INT.Ring  -homomorphic   F_Rat  -homomorphic   factorial   0  -characteristic   for    doubleLoopStr ;
</td><td><span data-href='ring_3.html#RC34'>ring_3</span></td></tr>
<tr><td>
cluster  non  empty   non  degenerated   non  trivial   left_add-cancelable   right_add-cancelable   add-cancelable   left_complementable   right_complementable   complementable   almost_left_invertible   unital   associative   commutative   Abelian   add-associative   right_zeroed  V110()  right-distributive   left-distributive   right_unital   well-unital   distributive   left_unital   domRing-like  V143() V192() V193() V194() V195()  PID   Euclidian   INT.Ring  -homomorphic   Z/ p -homomorphic   factorial  p -characteristic   for    doubleLoopStr ;
</td><td><span data-href='ring_3.html#RC35'>ring_3</span></td></tr>
<tr><td>
cluster  non  empty   infinite   left_add-cancelable   right_add-cancelable   add-cancelable   left_complementable   right_complementable   complementable   Abelian   add-associative   right_zeroed  V123()  right-distributive   left-distributive   right_unital   well-unital   distributive   left_unital   unital   associative  V251() V252() V253() V254()  INT.Ring  -homomorphic   INT.Ring  -homomorphic  n -characteristic   for    doubleLoopStr ;
</td><td><span data-href='ring_4.html#RC17'>ring_4</span></td></tr>
<tr><td>
cluster  non  empty   non  degenerated   non  trivial   left_add-cancelable   right_add-cancelable   add-cancelable   left_complementable   right_complementable   complementable   almost_left_cancelable   almost_right_cancelable   almost_cancelable   non  almost_left_invertible   Abelian   add-associative   right_zeroed  V123()  right-distributive   left-distributive   right_unital   well-unital   distributive   left_unital   unital   associative   commutative   domRing-like  V251() V252() V253() V254()  INT.Ring  -homomorphic   for    doubleLoopStr ;
</td><td><span data-href='ring_4.html#RC18'>ring_4</span></td></tr>
<tr><td>
cluster  INT.Ring  ->  non  almost_left_invertible  ;
</td><td><span data-href='ring_4.html#FC19'>ring_4</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   non  empty   total   quasi_total  V53() V54() V55()  additive   homogeneous   0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC3'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   non  empty   total   quasi_total  V53() V54() V55()  additive   0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC4'>zmatrlin</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#CC1'>zmatrlin</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#CC2'>zmatrlin</span></td></tr>
<tr><td>
cluster  0Functional V ->  constant  ;
</td><td><span data-href='zmatrlin.html#FC2'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   constant   non  empty   total   quasi_total  V53() V54() V55()  for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC5'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   constant   non  empty   total   quasi_total  V53() V54() V55()  additive   0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC6'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   non  constant   non  empty   non  trivial   total   quasi_total  V53() V54() V55()  additive   homogeneous   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC7'>zmatrlin</span></td></tr>
<tr><td>
cluster  NulForm (V,W) ->  additiveFAF  ;
</td><td><span data-href='zmatrlin.html#FC3'>zmatrlin</span></td></tr>
<tr><td>
cluster  NulForm (V,W) ->  additiveSAF  ;
</td><td><span data-href='zmatrlin.html#FC4'>zmatrlin</span></td></tr>
<tr><td>
cluster  NulForm (V,W) ->  homogeneousFAF  ;
</td><td><span data-href='zmatrlin.html#FC5'>zmatrlin</span></td></tr>
<tr><td>
cluster  NulForm (V,W) ->  homogeneousSAF  ;
</td><td><span data-href='zmatrlin.html#FC6'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of INT.Ring -valued   Function-like   non  empty   total   quasi_total  V53() V54() V55()  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC8'>zmatrlin</span></td></tr>
<tr><td>
cluster  FunctionalFAF (f,v) ->  additive  ;
</td><td><span data-href='zmatrlin.html#FC7'>zmatrlin</span></td></tr>
<tr><td>
cluster  FunctionalSAF (f,w) ->  additive  ;
</td><td><span data-href='zmatrlin.html#FC8'>zmatrlin</span></td></tr>
<tr><td>
cluster  FunctionalFAF (f,v) ->  homogeneous  ;
</td><td><span data-href='zmatrlin.html#FC9'>zmatrlin</span></td></tr>
<tr><td>
cluster  FunctionalSAF (f,w) ->  homogeneous  ;
</td><td><span data-href='zmatrlin.html#FC10'>zmatrlin</span></td></tr>
<tr><td>
cluster  FormFunctional (f,g) ->  additiveFAF  ;
</td><td><span data-href='zmatrlin.html#FC11'>zmatrlin</span></td></tr>
<tr><td>
cluster  FormFunctional (f,g) ->  additiveSAF  ;
</td><td><span data-href='zmatrlin.html#FC12'>zmatrlin</span></td></tr>
<tr><td>
cluster  FormFunctional (f,g) ->  homogeneousFAF  ;
</td><td><span data-href='zmatrlin.html#FC13'>zmatrlin</span></td></tr>
<tr><td>
cluster  FormFunctional (f,g) ->  homogeneousSAF  ;
</td><td><span data-href='zmatrlin.html#FC14'>zmatrlin</span></td></tr>
<tr><td>
cluster  FormFunctional (f,g) ->  non  trivial  ;
</td><td><span data-href='zmatrlin.html#FC15'>zmatrlin</span></td></tr>
<tr><td>
cluster  FormFunctional (f,g) ->  non  trivial  ;
</td><td><span data-href='zmatrlin.html#FC16'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of INT.Ring -valued   Function-like   non  constant   non  empty   non  trivial   total   quasi_total  V53() V54() V55()  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC9'>zmatrlin</span></td></tr>
<tr><td>
cluster f + g ->  additiveSAF  ;
</td><td><span data-href='zmatrlin.html#FC18'>zmatrlin</span></td></tr>
<tr><td>
cluster f + g ->  additiveFAF  ;
</td><td><span data-href='zmatrlin.html#FC19'>zmatrlin</span></td></tr>
<tr><td>
cluster a * f ->  additiveSAF  ;
</td><td><span data-href='zmatrlin.html#FC20'>zmatrlin</span></td></tr>
<tr><td>
cluster a * f ->  additiveFAF  ;
</td><td><span data-href='zmatrlin.html#FC21'>zmatrlin</span></td></tr>
<tr><td>
cluster  - f ->  additiveSAF  ;
</td><td><span data-href='zmatrlin.html#FC22'>zmatrlin</span></td></tr>
<tr><td>
cluster  - f ->  additiveFAF  ;
</td><td><span data-href='zmatrlin.html#FC23'>zmatrlin</span></td></tr>
<tr><td>
cluster f - g ->  additiveSAF  ;
</td><td><span data-href='zmatrlin.html#FC24'>zmatrlin</span></td></tr>
<tr><td>
cluster f - g ->  additiveFAF  ;
</td><td><span data-href='zmatrlin.html#FC25'>zmatrlin</span></td></tr>
<tr><td>
cluster f + g ->  homogeneousSAF  ;
</td><td><span data-href='zmatrlin.html#FC26'>zmatrlin</span></td></tr>
<tr><td>
cluster f + g ->  homogeneousFAF  ;
</td><td><span data-href='zmatrlin.html#FC27'>zmatrlin</span></td></tr>
<tr><td>
cluster a * f ->  homogeneousSAF  ;
</td><td><span data-href='zmatrlin.html#FC28'>zmatrlin</span></td></tr>
<tr><td>
cluster a * f ->  homogeneousFAF  ;
</td><td><span data-href='zmatrlin.html#FC29'>zmatrlin</span></td></tr>
<tr><td>
cluster  - f ->  homogeneousSAF  ;
</td><td><span data-href='zmatrlin.html#FC30'>zmatrlin</span></td></tr>
<tr><td>
cluster  - f ->  homogeneousFAF  ;
</td><td><span data-href='zmatrlin.html#FC31'>zmatrlin</span></td></tr>
<tr><td>
cluster f - g ->  homogeneousSAF  ;
</td><td><span data-href='zmatrlin.html#FC32'>zmatrlin</span></td></tr>
<tr><td>
cluster f - g ->  homogeneousFAF  ;
</td><td><span data-href='zmatrlin.html#FC33'>zmatrlin</span></td></tr>
<tr><td>
cluster  non  empty   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   strict   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat1.html#RC3'>zmodlat1</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  free   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat1.html#RC4'>zmodlat1</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  torsion-free   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat1.html#RC5'>zmodlat1</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  Mult-cancelable   torsion-free   free   finite-rank   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat1.html#RC6'>zmodlat1</span></td></tr>
<tr><td>
cluster  non  empty   Z_Lattice-like   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat1.html#RC7'>zmodlat1</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  Mult-cancelable   torsion-free   free   finite-rank  V273()  Z_Lattice-like   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat1.html#RC8'>zmodlat1</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  Mult-cancelable   torsion-free   free   finite-rank  V273()  strict   Z_Lattice-like   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat1.html#RC9'>zmodlat1</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   left_complementable   right_complementable   complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  Mult-cancelable   torsion-free   free   finite-rank  V273()  Z_Lattice-like   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat1.html#RC10'>zmodlat1</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  Mult-cancelable   torsion-free   free   finite-rank  V273()  Z_Lattice-like   INTegral   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat1.html#RC11'>zmodlat1</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   left_complementable   right_complementable   complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  Mult-cancelable   torsion-free   free   finite-rank  V273()  Z_Lattice-like   INTegral   positive-definite   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat1.html#RC12'>zmodlat1</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  Mult-cancelable   torsion-free   free   finite-rank  V273()  Z_Lattice-like   INTegral   even   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat1.html#RC13'>zmodlat1</span></td></tr>
<tr><td>
cluster  0FrFunctional V ->  additive  ;
</td><td><span data-href='zmodlat1.html#FC8'>zmodlat1</span></td></tr>
<tr><td>
cluster  0FrFunctional V ->  homogeneous  ;
</td><td><span data-href='zmodlat1.html#FC9'>zmodlat1</span></td></tr>
<tr><td>
cluster  0FrFunctional V ->  0-preserving  ;
</td><td><span data-href='zmodlat1.html#FC10'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of F_Real -valued   Function-like   non  empty   total  V18( the carrier of V, the carrier of F_Real) V71() V72() V73()  additive   homogeneous   0-preserving   for    Element of  bool [: the carrier of V, the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC14'>zmodlat1</span></td></tr>
<tr><td>
cluster f + g ->  additive  ;
</td><td><span data-href='zmodlat1.html#FC11'>zmodlat1</span></td></tr>
<tr><td>
cluster  - f ->  additive  ;
</td><td><span data-href='zmodlat1.html#FC12'>zmodlat1</span></td></tr>
<tr><td>
cluster v * f ->  additive  ;
</td><td><span data-href='zmodlat1.html#FC13'>zmodlat1</span></td></tr>
<tr><td>
cluster f + g ->  homogeneous  ;
</td><td><span data-href='zmodlat1.html#FC14'>zmodlat1</span></td></tr>
<tr><td>
cluster  - f ->  homogeneous  ;
</td><td><span data-href='zmodlat1.html#FC15'>zmodlat1</span></td></tr>
<tr><td>
cluster v * f ->  homogeneous  ;
</td><td><span data-href='zmodlat1.html#FC16'>zmodlat1</span></td></tr>
<tr><td>
cluster  NulFrForm (V,W) ->  additiveFAF  ;
</td><td><span data-href='zmodlat1.html#FC17'>zmodlat1</span></td></tr>
<tr><td>
cluster  NulFrForm (V,W) ->  additiveSAF  ;
</td><td><span data-href='zmodlat1.html#FC18'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of F_Real -valued   Function-like   non  empty   total  V18([: the carrier of V, the carrier of W:], the carrier of F_Real) V71() V72() V73()  additiveFAF   additiveSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC15'>zmodlat1</span></td></tr>
<tr><td>
cluster  NulFrForm (V,W) ->  homogeneousFAF  ;
</td><td><span data-href='zmodlat1.html#FC19'>zmodlat1</span></td></tr>
<tr><td>
cluster  NulFrForm (V,W) ->  homogeneousSAF  ;
</td><td><span data-href='zmodlat1.html#FC20'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of F_Real -valued   Function-like   non  empty   total  V18([: the carrier of V, the carrier of W:], the carrier of F_Real) V71() V72() V73()  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC16'>zmodlat1</span></td></tr>
<tr><td>
cluster  FrFunctionalFAF (f,v) ->  additive  ;
</td><td><span data-href='zmodlat1.html#FC21'>zmodlat1</span></td></tr>
<tr><td>
cluster  FrFunctionalSAF (f,w) ->  additive  ;
</td><td><span data-href='zmodlat1.html#FC22'>zmodlat1</span></td></tr>
<tr><td>
cluster  FrFunctionalFAF (f,v) ->  homogeneous  ;
</td><td><span data-href='zmodlat1.html#FC23'>zmodlat1</span></td></tr>
<tr><td>
cluster  FrFunctionalSAF (f,w) ->  homogeneous  ;
</td><td><span data-href='zmodlat1.html#FC24'>zmodlat1</span></td></tr>
<tr><td>
cluster  FrFormFunctional (f,g) ->  additiveFAF  ;
</td><td><span data-href='zmodlat1.html#FC25'>zmodlat1</span></td></tr>
<tr><td>
cluster  FrFormFunctional (f,g) ->  additiveSAF  ;
</td><td><span data-href='zmodlat1.html#FC26'>zmodlat1</span></td></tr>
<tr><td>
cluster  FrFormFunctional (f,g) ->  homogeneousFAF  ;
</td><td><span data-href='zmodlat1.html#FC27'>zmodlat1</span></td></tr>
<tr><td>
cluster  FrFormFunctional (f,g) ->  homogeneousSAF  ;
</td><td><span data-href='zmodlat1.html#FC28'>zmodlat1</span></td></tr>
<tr><td>
cluster  FrFormFunctional (f,g) ->  non  trivial  ;
</td><td><span data-href='zmodlat1.html#FC29'>zmodlat1</span></td></tr>
<tr><td>
cluster  FrFormFunctional (f,g) ->  non  trivial  ;
</td><td><span data-href='zmodlat1.html#FC30'>zmodlat1</span></td></tr>
<tr><td>
cluster  0FrFunctional V ->  0-preserving  ;
</td><td><span data-href='zmodlat1.html#FC31'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of F_Real -valued   Function-like   non  empty   total  V18( the carrier of V, the carrier of F_Real) V71() V72() V73()  additive   homogeneous   0-preserving   for    Element of  bool [: the carrier of V, the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC17'>zmodlat1</span></td></tr>
<tr><td>
cluster f + g ->  additiveSAF  ;
</td><td><span data-href='zmodlat1.html#FC33'>zmodlat1</span></td></tr>
<tr><td>
cluster f + g ->  additiveFAF  ;
</td><td><span data-href='zmodlat1.html#FC34'>zmodlat1</span></td></tr>
<tr><td>
cluster a * f ->  additiveSAF  ;
</td><td><span data-href='zmodlat1.html#FC35'>zmodlat1</span></td></tr>
<tr><td>
cluster a * f ->  additiveFAF  ;
</td><td><span data-href='zmodlat1.html#FC36'>zmodlat1</span></td></tr>
<tr><td>
cluster  - f ->  additiveSAF  ;
</td><td><span data-href='zmodlat1.html#FC37'>zmodlat1</span></td></tr>
<tr><td>
cluster  - f ->  additiveFAF  ;
</td><td><span data-href='zmodlat1.html#FC38'>zmodlat1</span></td></tr>
<tr><td>
cluster f - g ->  additiveSAF  ;
</td><td><span data-href='zmodlat1.html#FC39'>zmodlat1</span></td></tr>
<tr><td>
cluster f - g ->  additiveFAF  ;
</td><td><span data-href='zmodlat1.html#FC40'>zmodlat1</span></td></tr>
<tr><td>
cluster f + g ->  homogeneousSAF  ;
</td><td><span data-href='zmodlat1.html#FC41'>zmodlat1</span></td></tr>
<tr><td>
cluster f + g ->  homogeneousFAF  ;
</td><td><span data-href='zmodlat1.html#FC42'>zmodlat1</span></td></tr>
<tr><td>
cluster a * f ->  homogeneousSAF  ;
</td><td><span data-href='zmodlat1.html#FC43'>zmodlat1</span></td></tr>
<tr><td>
cluster a * f ->  homogeneousFAF  ;
</td><td><span data-href='zmodlat1.html#FC44'>zmodlat1</span></td></tr>
<tr><td>
cluster  - f ->  homogeneousSAF  ;
</td><td><span data-href='zmodlat1.html#FC45'>zmodlat1</span></td></tr>
<tr><td>
cluster  - f ->  homogeneousFAF  ;
</td><td><span data-href='zmodlat1.html#FC46'>zmodlat1</span></td></tr>
<tr><td>
cluster f - g ->  homogeneousSAF  ;
</td><td><span data-href='zmodlat1.html#FC47'>zmodlat1</span></td></tr>
<tr><td>
cluster f - g ->  homogeneousFAF  ;
</td><td><span data-href='zmodlat1.html#FC48'>zmodlat1</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  Mult-cancelable   free   finite-rank   finitely-generated   Z_Lattice-like   positive-definite  V259()  RATional   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat2.html#RC1'>zmodlat2</span></td></tr>
<tr><td>
cluster  non  empty   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   free   finite-rank   Z_Lattice-like   INTegral   ->  INTegral   RATional   for    LatticeStr over  INT.Ring ;
</td><td><span data-href='zmodlat2.html#CC2'>zmodlat2</span></td></tr>
<tr><td>
cluster  NulFrForm (V,V) ->  symmetric  ;
</td><td><span data-href='zmodlat2.html#FC9'>zmodlat2</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of F_Real -valued   Function-like   non  empty   total   quasi_total  V71() V72() V73()  symmetric   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Real:];
</td><td><span data-href='zmodlat2.html#RC2'>zmodlat2</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of F_Real -valued   Function-like   non  empty   total   quasi_total  V71() V72() V73() V252(V,V) V253(V,V) V254(V,V) V255(V,V)  symmetric   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Real:];
</td><td><span data-href='zmodlat2.html#RC3'>zmodlat2</span></td></tr>
<tr><td>
cluster   ->  integer   for    Element of  the carrier of INT.Ring;
</td><td><span data-href='zmodul01.html#CC1'>zmodul01</span></td></tr>
<tr><td>
cluster  TrivialLMod INT.Ring ->  trivial  ;
</td><td><span data-href='zmodul01.html#FC1'>zmodul01</span></td></tr>
<tr><td>
cluster  non  empty   left_add-cancelable   right_add-cancelable   add-cancelable   right_complementable   Abelian   add-associative   right_zeroed  V142() V143() V144() V145()  strict   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul01.html#RC1'>zmodul01</span></td></tr>
<tr><td>
cluster   ->  integer   for    Element of  the carrier of INT.Ring;
</td><td><span data-href='zmodul02.html#CC1'>zmodul02</span></td></tr>
<tr><td>
cluster  ext-real   complex   right_complementable  V102()  integer  V115()  prime   for    Element of  the carrier of INT.Ring;
</td><td><span data-href='zmodul02.html#RC1'>zmodul02</span></td></tr>
<tr><td>
cluster  Z_MQ_VectSp (V,p) ->  non  empty   right_complementable   Abelian   add-associative   right_zeroed   strict   vector-distributive   scalar-distributive   scalar-associative   scalar-unital  ;
</td><td><span data-href='zmodul02.html#FC1'>zmodul02</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   left_add-cancelable   right_add-cancelable   right_complementable  V156( INT.Ring ) V157( INT.Ring ) V158( INT.Ring ) V159( INT.Ring ) V163() V164() V165() V259() V260() V261() V262()  for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul03.html#RC1'>zmodul03</span></td></tr>
<tr><td>
cluster  non  empty   left_add-cancelable   right_add-cancelable   right_complementable   strict  V156( INT.Ring ) V157( INT.Ring ) V158( INT.Ring ) V159( INT.Ring ) V163() V164() V165()  free  V259() V260() V261() V262()  for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul03.html#RC3'>zmodul03</span></td></tr>
<tr><td>
cluster  non  empty   left_add-cancelable   right_add-cancelable   right_complementable   strict  V156( INT.Ring ) V157( INT.Ring ) V158( INT.Ring ) V159( INT.Ring ) V163() V164() V165()  free  V259() V260() V261() V262()  for    Subspace of V;
</td><td><span data-href='zmodul03.html#RC4'>zmodul03</span></td></tr>
<tr><td>
cluster  non  empty   right_complementable  V156( INT.Ring ) V157( INT.Ring ) V158( INT.Ring ) V159( INT.Ring ) V163() V164() V165()  free   ->  free   Mult-cancelable   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul03.html#CC1'>zmodul03</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   left_add-cancelable   right_add-cancelable   right_complementable  V156( INT.Ring ) V157( INT.Ring ) V158( INT.Ring ) V159( INT.Ring ) V163() V164() V165()  free  V259() V260() V261() V262()  for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul03.html#RC6'>zmodul03</span></td></tr>
<tr><td>
cluster  non  empty   left_add-cancelable   right_add-cancelable   right_complementable   strict  V156( INT.Ring ) V157( INT.Ring ) V158( INT.Ring ) V159( INT.Ring ) V163() V164() V165()  free  V259() V260() V261() V262()  Mult-cancelable   finite-rank   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul03.html#RC7'>zmodul03</span></td></tr>
<tr><td>
cluster  non  empty   left_add-cancelable   right_add-cancelable   right_complementable   strict  V156( INT.Ring ) V157( INT.Ring ) V158( INT.Ring ) V159( INT.Ring ) V163() V164() V165()  free  V259() V260() V261() V262()  Mult-cancelable   finite-rank   for    Subspace of V;
</td><td><span data-href='zmodul03.html#RC8'>zmodul03</span></td></tr>
<tr><td>
cluster  non  empty   left_add-cancelable   right_add-cancelable   right_complementable   strict  V156( INT.Ring ) V157( INT.Ring ) V158( INT.Ring ) V159( INT.Ring ) V163() V164() V165()  free  V259() V260() V261() V262()  finitely-generated   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul03.html#RC9'>zmodul03</span></td></tr>
<tr><td>
cluster  Z_MQ_VectSp (V,p) ->  finite-dimensional  ;
</td><td><span data-href='zmodul03.html#FC7'>zmodul03</span></td></tr>
<tr><td>
cluster  non  empty   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   free   finitely-generated   ->  free   finite-rank   finitely-generated   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul04.html#CC2'>zmodul04</span></td></tr>
<tr><td>
cluster  non  empty   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   free   finite-rank   ->  free   finite-rank   finitely-generated   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul04.html#CC3'>zmodul04</span></td></tr>
<tr><td>
cluster  Lin A ->  finitely-generated  ;
</td><td><span data-href='zmodul05.html#FC1'>zmodul05</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V170()  torsion   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul06.html#RC2'>zmodul06</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V170()  non  torsion   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul06.html#RC3'>zmodul06</span></td></tr>
<tr><td>
cluster  non  empty   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   Mult-cancelable   ->  Mult-cancelable   torsion-free   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul06.html#CC1'>zmodul06</span></td></tr>
<tr><td>
cluster  non  empty   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   torsion-free   ->  Mult-cancelable   torsion-free   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul06.html#CC2'>zmodul06</span></td></tr>
<tr><td>
cluster  non  empty   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   free   ->  free   torsion-free   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul06.html#CC3'>zmodul06</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V170()  free   torsion-free   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul06.html#RC5'>zmodul06</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   torsion-free   ->  non  trivial   non  torsion   torsion-free   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul06.html#CC5'>zmodul06</span></td></tr>
<tr><td>
cluster  non  empty   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   finitely-generated   torsion-free   ->  free   finitely-generated   torsion-free   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul06.html#CC6'>zmodul06</span></td></tr>
<tr><td>
cluster V31()  integer   non  zero   complex   ext-real   rational   prime   g_integer   g_rational   for    Element of  the carrier of INT.Ring;
</td><td><span data-href='zmodul07.html#RC1'>zmodul07</span></td></tr>
<tr><td>
cluster  prime   ->  non  zero   for    Element of  the carrier of INT.Ring;
</td><td><span data-href='zmodul07.html#CC1'>zmodul07</span></td></tr>
<tr><td>
cluster  VectQuot (V,(a (*) V)) ->  torsion  ;
</td><td><span data-href='zmodul07.html#FC12'>zmodul07</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V170()  torsion   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul07.html#RC2'>zmodul07</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V170()  non  torsion-free   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul07.html#RC3'>zmodul07</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V170()  finitely-generated   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul07.html#RC5'>zmodul07</span></td></tr>
<tr><td>
cluster  non  empty   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   non  torsion-free   ->  non  trivial   non  torsion-free   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul07.html#CC3'>zmodul07</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V170()  Mult-cancelable   free   finite-rank   finitely-generated   torsion-free   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul07.html#RC6'>zmodul07</span></td></tr>
<tr><td>
cluster  VectQuot (V,(p (*) V)) ->  non  trivial  ;
</td><td><span data-href='zmodul07.html#FC13'>zmodul07</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V170()  finitely-generated   torsion   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul07.html#RC7'>zmodul07</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V170()  finitely-generated   torsion   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul07.html#RC8'>zmodul07</span></td></tr>
<tr><td>
cluster  VectQuot (V,(p (*) V)) ->  finitely-generated   torsion  ;
</td><td><span data-href='zmodul07.html#FC14'>zmodul07</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  divisible   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul08.html#RC2'>zmodul08</span></td></tr>
<tr><td>
cluster  non  empty   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  non  finitely-generated   divisible   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul08.html#RC4'>zmodul08</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  divisible   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul08.html#RC5'>zmodul08</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   left_complementable   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  V164()  torsion   finitely-generated   non  divisible   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul08.html#RC7'>zmodul08</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   divisible   ->  non  trivial   non  finitely-generated   divisible   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul08.html#CC1'>zmodul08</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   free   ->  non  trivial   free   non  divisible   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul08.html#CC2'>zmodul08</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed   torsion-free   ->  non  trivial   infinite   torsion-free   for    ModuleStr over  INT.Ring ;
</td><td><span data-href='zmodul08.html#CC3'>zmodul08</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM12476'>
<h2>2.   <span data-link='4294.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='int_3.html#K9'>int_3</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c2">n</font> be   <span title="ORDINAL1:attr.7" data-link="6328.html#ELM19073">natural</span>   <span title="ORDINAL1:NM.1" data-link="6317.html#ELM19055">Number</span> ;<br><div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K9"><span class="kw">func</span> </a> <span title="INT_3:func.9" data-link="4294.html#ELM12476">INT.Ring</span> <font color="Maroon" title="c1">n</font><span class="kw"> -&gt; </span>   <span title="ALGSTR_0:struct.6" data-link="324.html#ELM743">doubleLoopStr</span> <span class="kw"> equals </span><a name="D12"><span class="comment"><font color="firebrick">:: INT_3:def 12</font></span><br></a> <span title="ALGSTR_0:aggr.6" data-href="algstr_0.html#G6">doubleLoopStr</span>(# <span class="p1">(<span class="default"><span title="CARD_1:func.5" data-link="1332.html#ELM3237">Segm</span> <font color="Maroon" title="c1">n</font></span>)</span>,<span class="p1">(<span class="default"><span title="GR_CY_1:func.3" data-link="1146.html#ELM10681">addint</span> <font color="Maroon" title="c1">n</font></span>)</span>,<span class="p1">(<span class="default"><span title="INT_3:func.7" data-link="1148.html#ELM12474">multint</span> <font color="Maroon" title="c1">n</font></span>)</span>,<span class="p1">(<span class="default"><span title="SUBSET_1:func.10" data-link="8054.html#ELM25879">In</span> (1,<span class="p2">(<span class="default"><span title="CARD_1:func.5" data-link="1332.html#ELM3237">Segm</span> <font color="Maroon" title="c1">n</font></span>)</span>)</span>)</span>,<span class="p1">(<span class="default"><span title="SUBSET_1:func.10" data-link="8054.html#ELM25879">In</span> (<span title="NUMBERS:func.5" data-link="6192.html#ELM18628">0</span>,<span class="p2">(<span class="default"><span title="CARD_1:func.5" data-link="1332.html#ELM3237">Segm</span> <font color="Maroon" title="c1">n</font></span>)</span>)</span>)</span> #);<br>
</div>
<span class="kw">coherence</span> <br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  INT.Ring n ->  non  empty   strict  ;
</td><td><span data-href='int_3.html#FC6'>int_3</span></td></tr>
<tr><td>
cluster  INT.Ring p ->  non  degenerated   right_complementable   almost_left_invertible   associative   commutative   Abelian   add-associative   right_zeroed   well-unital   distributive  ;
</td><td><span data-href='int_3.html#FC7'>int_3</span></td></tr>
<tr><td>
cluster  INT.Ring n ->  non  preordered  ;
</td><td><span data-href='realalg1.html#FC20'>realalg1</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
</body>
</html>
