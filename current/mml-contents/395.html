<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<title>[::]</title>
</head>
<body>
<div class='mml-summary'>
<h1>func [::]</h1>
<h2>List of Definitions (32)</h2>
<ol>
<li><span data-link='395.html#ELM944'>[::]</span> [<span data-href='algstr_4.html#K17'>algstr_4</span>]</li>
<li><span data-link='395.html#ELM2886'>[::]</span> [<span data-href='borsuk_1.html#K2'>borsuk_1</span>]</li>
<li><span data-link='395.html#ELM2887'>[::]</span> [<span data-href='borsuk_1.html#K3'>borsuk_1</span>]</li>
<li><span data-link='395.html#ELM2889'>[::]</span> [<span data-href='borsuk_1.html#K5'>borsuk_1</span>]</li>
<li><span data-link='395.html#ELM2890'>[::]</span> [<span data-href='borsuk_1.html#K6'>borsuk_1</span>]</li>
<li><span data-link='395.html#ELM2928'>[::]</span> [<span data-href='borsuk_2.html#K3'>borsuk_2</span>]</li>
<li><span data-link='395.html#ELM3475'>[::]</span> [<span data-href='cardfil4.html#K1'>cardfil4</span>]</li>
<li><span data-link='395.html#ELM3477'>[::]</span> [<span data-href='cardfil4.html#K3'>cardfil4</span>]</li>
<li><span data-link='395.html#ELM3548'>[::]</span> [<span data-href='cat_2.html#K6'>cat_2</span>]</li>
<li><span data-link='395.html#ELM3557'>[::]</span> [<span data-href='cat_2.html#K15'>cat_2</span>]</li>
<li><span data-link='395.html#ELM4421'>[::]</span> [<span data-href='classes2.html#K11'>classes2</span>]</li>
<li><span data-link='395.html#ELM6890'>[::]</span> [<span data-href='filter_1.html#K7'>filter_1</span>]</li>
<li><span data-link='395.html#ELM8929'>[::]</span> [<span data-href='funct_3.html#K15'>funct_3</span>]</li>
<li><span data-link='395.html#ELM8930'>[::]</span> [<span data-href='funct_3.html#K16'>funct_3</span>]</li>
<li><span data-link='395.html#ELM14641'>[::]</span> [<span data-href='matrix_3.html#K8'>matrix_3</span>]</li>
<li><span data-link='395.html#ELM14958'>[::]</span> [<span data-href='mcart_1.html#K8'>mcart_1</span>]</li>
<li><span data-link='395.html#ELM14959'>[::]</span> [<span data-href='mcart_1.html#K9'>mcart_1</span>]</li>
<li><span data-link='395.html#ELM14960'>[::]</span> [<span data-href='mcart_1.html#K10'>mcart_1</span>]</li>
<li><span data-link='395.html#ELM20948'>[::]</span> [<span data-href='pralg_1.html#K5'>pralg_1</span>]</li>
<li><span data-link='395.html#ELM20994'>[::]</span> [<span data-href='pralg_2.html#K8'>pralg_2</span>]</li>
<li><span data-link='395.html#ELM21385'>[::]</span> [<span data-href='prvect_1.html#K12'>prvect_1</span>]</li>
<li><span data-link='395.html#ELM21411'>[::]</span> [<span data-href='prvect_2.html#K2'>prvect_2</span>]</li>
<li><span data-link='395.html#ELM21435'>[::]</span> [<span data-href='prvect_3.html#K4'>prvect_3</span>]</li>
<li><span data-link='395.html#ELM21436'>[::]</span> [<span data-href='prvect_3.html#K5'>prvect_3</span>]</li>
<li><span data-link='395.html#ELM21438'>[::]</span> [<span data-href='prvect_3.html#K7'>prvect_3</span>]</li>
<li><span data-link='395.html#ELM28482'>[::]</span> [<span data-href='vectsp12.html#K9'>vectsp12</span>]</li>
<li><span data-link='395.html#ELM28845'>[::]</span> [<span data-href='waybel20.html#K1'>waybel20</span>]</li>
<li><span data-link='395.html#ELM30274'>[::]</span> [<span data-href='yellow_3.html#K3'>yellow_3</span>]</li>
<li><span data-link='395.html#ELM30277'>[::]</span> [<span data-href='yellow_3.html#K6'>yellow_3</span>]</li>
<li><span data-link='395.html#ELM30580'>[::]</span> [<span data-href='zfmisc_1.html#K2'>zfmisc_1</span>]</li>
<li><span data-link='395.html#ELM30581'>[::]</span> [<span data-href='zfmisc_1.html#K3'>zfmisc_1</span>]</li>
<li><span data-link='395.html#ELM30582'>[::]</span> [<span data-href='zfmisc_1.html#K4'>zfmisc_1</span>]</li>
</ol>
</div>
<div class='mml-element' id='ELM944'>
<h2>1.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='algstr_4.html#K17'>algstr_4</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X</font> be   non  <span title="XBOOLE_0:attr.1" data-link="1570.html#ELM29653">empty</span>   <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c2">M</font> be   non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="ALGSTR_0:struct.3" data-link="321.html#ELM740">multMagma</span> ;<br><span class="kw">let </span><font color="Maroon" title="c3">n</font>, <font color="Maroon" title="c4">m</font> be   non  <span title="ORDINAL1:attr.8" data-link="1643.html#ELM19074">zero</span>  <span title="NAT_1:NM.1" data-link="5402.html#ELM17446">Nat</span>;<br><span class="kw">let </span><font color="Maroon" title="c5">f</font> be   <span title="STRUCT_0:NM.5" data-link="3155.html#ELM25751">Function</span> of <span class="p1">(<span class="default"><span title="ALGSTR_4:func.11" data-link="390.html#ELM938">free_magma</span> (<font color="Maroon" title="c1">X</font>,<font color="Maroon" title="c3">n</font>)</span>)</span>,<font color="Maroon" title="c2">M</font>;<br><span class="kw">let </span><font color="Maroon" title="c6">g</font> be   <span title="STRUCT_0:NM.5" data-link="3155.html#ELM25751">Function</span> of <span class="p1">(<span class="default"><span title="ALGSTR_4:func.11" data-link="390.html#ELM938">free_magma</span> (<font color="Maroon" title="c1">X</font>,<font color="Maroon" title="c4">m</font>)</span>)</span>,<font color="Maroon" title="c2">M</font>;<br><div about="#D44" typeof="oo:Definition" class="main-sentence">
<a name="K17"><span class="kw">func</span> </a><span class="p1"><span title="ALGSTR_4:func.17" data-link="395.html#ELM944">[:</span><span class="default"><font color="Maroon" title="c5">f</font>,<font color="Maroon" title="c6">g</font></span><span title="ALGSTR_4:func.17" data-link="395.html#ELM944">:]</span></span><span class="kw"> -&gt; </span>  <span title="STRUCT_0:NM.5" data-link="3155.html#ELM25751">Function</span> of <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><span class="p2"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><span class="p3">(<span class="default"><span title="ALGSTR_4:func.11" data-link="390.html#ELM938">free_magma</span> (<font color="Maroon" title="c1">X</font>,<font color="Maroon" title="c3">n</font>)</span>)</span>,<span class="p3">(<span class="default"><span title="ALGSTR_4:func.11" data-link="390.html#ELM938">free_magma</span> (<font color="Maroon" title="c1">X</font>,<font color="Maroon" title="c4">m</font>)</span>)</span></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<span class="p2"><span title="TARSKI:func.1" data-link="857.html#ELM26065">{</span><span class="default"><font color="Maroon" title="c3">n</font></span><span title="TARSKI:func.1" data-link="857.html#ELM26065">}</span></span></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<font color="Maroon" title="c2">M</font><span class="kw"> means </span>:<span class="lab"><font color="Green" title="E44">Def20</font></span>: <a name="D20"><span class="comment"><font color="firebrick">:: ALGSTR_4:def 20</font></span><br></a> for <font color="Olive" title="b1">x</font> being    <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><span class="p2"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><span class="p3">(<span class="default"><span title="ALGSTR_4:func.11" data-link="390.html#ELM938">free_magma</span> (<font color="Maroon" title="c1">X</font>,<font color="Maroon" title="c3">n</font>)</span>)</span>,<span class="p3">(<span class="default"><span title="ALGSTR_4:func.11" data-link="390.html#ELM938">free_magma</span> (<font color="Maroon" title="c1">X</font>,<font color="Maroon" title="c4">m</font>)</span>)</span></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<span class="p2"><span title="TARSKI:func.1" data-link="857.html#ELM26065">{</span><span class="default"><font color="Maroon" title="c3">n</font></span><span title="TARSKI:func.1" data-link="857.html#ELM26065">}</span></span></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span><br>  for <font color="Olive" title="b2">y</font> being    <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of  <span title="ALGSTR_4:func.11" data-link="390.html#ELM938">free_magma</span> (<font color="Maroon" title="c1">X</font>,<font color="Maroon" title="c3">n</font>)<br>  for <font color="Olive" title="b3">z</font> being    <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of  <span title="ALGSTR_4:func.11" data-link="390.html#ELM938">free_magma</span> (<font color="Maroon" title="c1">X</font>,<font color="Maroon" title="c4">m</font>)  st <font color="Olive" title="b2">y</font> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1">(<span class="default"><font color="Olive" title="b1">x</font> <span title="XFAMILY:func.1" data-link="54.html#ELM29712">`1</span></span>)</span> <span title="XFAMILY:func.1" data-link="54.html#ELM29712">`1</span>  &amp; <font color="Olive" title="b3">z</font> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1">(<span class="default"><font color="Olive" title="b1">x</font> <span title="XFAMILY:func.1" data-link="54.html#ELM29712">`1</span></span>)</span> <span title="XFAMILY:func.2" data-link="55.html#ELM29713">`2</span>  holds <br><span class="kw">it</span> <span title="FUNCT_2:func.3" data-link="141.html#ELM8880">.</span> <font color="Olive" title="b1">x</font> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1">(<span class="default"><font color="Maroon" title="c5">f</font> <span title="FUNCT_2:func.3" data-link="141.html#ELM8880">.</span> <font color="Olive" title="b2">y</font></span>)</span> <span title="ALGSTR_0:func.6" data-link="47.html#ELM749">*</span> <span class="p1">(<span class="default"><font color="Maroon" title="c6">g</font> <span title="FUNCT_2:func.3" data-link="141.html#ELM8880">.</span> <font color="Olive" title="b3">z</font></span>)</span>;<br>
</div>
<span class="kw">existence</span> <span class="kw">uniqueness</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM2886'>
<h2>2.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='borsuk_1.html#K2'>borsuk_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X</font>, <font color="Maroon" title="c2">Y</font> be   <span title="PRE_TOPC:NM.1" data-link="6938.html#ELM21124">TopSpace</span>;<br><div about="#D5" typeof="oo:Definition" class="main-sentence">
<a name="K2"><span class="kw">func</span> </a><span class="p1"><span title="BORSUK_1:func.2" data-link="395.html#ELM2886">[:</span><span class="default"><font color="Maroon" title="c1">X</font>,<font color="Maroon" title="c2">Y</font></span><span title="BORSUK_1:func.2" data-link="395.html#ELM2886">:]</span></span><span class="kw"> -&gt; </span>  <span title="PRE_TOPC:attr.1" data-href="pre_topc.html#V1">strict</span>  <span title="PRE_TOPC:NM.1" data-link="6938.html#ELM21124">TopSpace</span><span class="kw"> means </span>:<span class="lab"><font color="Green" title="E5">Def2</font></span>: <a name="D2"><span class="comment"><font color="firebrick">:: BORSUK_1:def 2</font></span><br></a>(  the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <span class="kw">it</span> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"> the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c1">X</font>, the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c2">Y</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span> &amp;  the <span title="PRE_TOPC:sel.1" data-href="pre_topc.html#U1">topology</span> of <span class="kw">it</span> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1"> { <span class="default"> <span class="p2">(<span class="default"><span title="SETFAM_1:func.5" data-link="1741.html#ELM25007">union</span> <font color="Olive" title="b1">A</font></span>)</span> where <font color="Olive" title="b1">A</font> is   <span title="STRUCT_0:NM.3" data-link="7849.html#ELM25749">Subset-Family</span> of <span class="kw">it</span> : <font color="Olive" title="b1">A</font> <span title="TARSKI:pred.1" data-link="2755.html#ELM26062">c=</span> <span class="p1"> { <span class="default"> <span class="p2"><span title="MCART_1:func.8" data-link="395.html#ELM14958">[:</span><span class="default"><font color="Olive" title="b2">X1</font>,<font color="Olive" title="b3">Y1</font></span><span title="MCART_1:func.8" data-link="395.html#ELM14958">:]</span></span> where <font color="Olive" title="b2">X1</font> is   <span title="STRUCT_0:NM.2" data-link="26.html#ELM25748">Subset</span> of <font color="Maroon" title="c1">X</font>, <font color="Olive" title="b3">Y1</font> is   <span title="STRUCT_0:NM.2" data-link="26.html#ELM25748">Subset</span> of <font color="Maroon" title="c2">Y</font> : ( <font color="Olive" title="b2">X1</font> <span title="TARSKI:pred.2" data-link="4139.html#ELM26063">in</span>  the <span title="PRE_TOPC:sel.1" data-href="pre_topc.html#U1">topology</span> of <font color="Maroon" title="c1">X</font> &amp; <font color="Olive" title="b3">Y1</font> <span title="TARSKI:pred.2" data-link="4139.html#ELM26063">in</span>  the <span title="PRE_TOPC:sel.1" data-href="pre_topc.html#U1">topology</span> of <font color="Maroon" title="c2">Y</font> ) </span> } </span>  </span> } </span>  );<br>
</div>
<span class="kw">existence</span> <span class="kw">uniqueness</span> <br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster [:T1,T2:] ->  empty   strict  ;
</td><td><span data-href='borsuk_1.html#FC3'>borsuk_1</span></td></tr>
<tr><td>
cluster [:T2,T1:] ->  empty   strict  ;
</td><td><span data-href='borsuk_1.html#FC4'>borsuk_1</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  non  empty   strict  ;
</td><td><span data-href='borsuk_1.html#FC5'>borsuk_1</span></td></tr>
<tr><td>
cluster  Base-Appr A ->  open  ;
</td><td><span data-href='borsuk_1.html#FC6'>borsuk_1</span></td></tr>
<tr><td>
cluster [:f,g:] ->  continuous   for  Function of [:S1,S2:],[:T1,T2:];
</td><td><span data-href='borsuk_2.html#FC4'>borsuk_2</span></td></tr>
<tr><td>
cluster [:T1,T2:] ->  T_0  ;
</td><td><span data-href='borsuk_2.html#FC5'>borsuk_2</span></td></tr>
<tr><td>
cluster [:T1,T2:] ->  T_1  ;
</td><td><span data-href='borsuk_2.html#FC6'>borsuk_2</span></td></tr>
<tr><td>
cluster [:T1,T2:] ->  T_2  ;
</td><td><span data-href='borsuk_2.html#FC7'>borsuk_2</span></td></tr>
<tr><td>
cluster [:Y,(X | {x}):] ->  compact  ;
</td><td><span data-href='borsuk_3.html#FC3'>borsuk_3</span></td></tr>
<tr><td>
cluster [:T1,T2:] ->  compact  ;
</td><td><span data-href='borsuk_3.html#FC4'>borsuk_3</span></td></tr>
<tr><td>
cluster p `1  ->  real  ;
</td><td><span data-href='borsuk_6.html#FC1'>borsuk_6</span></td></tr>
<tr><td>
cluster p `2  ->  real  ;
</td><td><span data-href='borsuk_6.html#FC2'>borsuk_6</span></td></tr>
<tr><td>
cluster x `1  ->  real  ;
</td><td><span data-href='borsuk_6.html#FC3'>borsuk_6</span></td></tr>
<tr><td>
cluster x `2  ->  real  ;
</td><td><span data-href='borsuk_6.html#FC4'>borsuk_6</span></td></tr>
<tr><td>
cluster [:TM1,TM2:] ->  metrizable  ;
</td><td><span data-href='metrizts.html#FC3'>metrizts</span></td></tr>
<tr><td>
cluster [:T1,T2:] ->  second-countable  ;
</td><td><span data-href='metrizts.html#FC5'>metrizts</span></td></tr>
<tr><td>
cluster [:N,M:] ->  locally_euclidean  ;
</td><td><span data-href='mfold_0.html#FC13'>mfold_0</span></td></tr>
<tr><td>
cluster [:N,M:] ->  without_boundary  ;
</td><td><span data-href='mfold_0.html#FC14'>mfold_0</span></td></tr>
<tr><td>
cluster [:N,M:] ->  with_boundary  ;
</td><td><span data-href='mfold_0.html#FC15'>mfold_0</span></td></tr>
<tr><td>
cluster [:M,N:] ->  with_boundary  ;
</td><td><span data-href='mfold_0.html#FC16'>mfold_0</span></td></tr>
<tr><td>
cluster [:N,M:] -> n + m -locally_euclidean  ;
</td><td><span data-href='mfold_0.html#FC17'>mfold_0</span></td></tr>
<tr><td>
cluster [:M1,M2:] ->  Hausdorff   second-countable  ;
</td><td><span data-href='mfold_0.html#FC20'>mfold_0</span></td></tr>
<tr><td>
cluster [:A,B:] ->  connected  ;
</td><td><span data-href='topalg_3.html#FC2'>topalg_3</span></td></tr>
<tr><td>
cluster [:S,T:] ->  pathwise_connected  ;
</td><td><span data-href='topalg_4.html#FC2'>topalg_4</span></td></tr>
<tr><td>
cluster  Prj1 (t,H) ->  continuous  ;
</td><td><span data-href='topalg_5.html#FC6'>topalg_5</span></td></tr>
<tr><td>
cluster  Prj2 (s,H) ->  continuous  ;
</td><td><span data-href='topalg_5.html#FC7'>topalg_5</span></td></tr>
<tr><td>
cluster  HomotopyMlt (F,G) ->  continuous  ;
</td><td><span data-href='topalg_7.html#FC5'>topalg_7</span></td></tr>
<tr><td>
cluster [:TM1,TM2:] ->  finite-ind  ;
</td><td><span data-href='topdim_2.html#FC4'>topdim_2</span></td></tr>
<tr><td>
cluster   ->  Relation-like   for    Element of  bool  the carrier of [:X,Y:];
</td><td><span data-href='waybel26.html#CC1'>waybel26</span></td></tr>
<tr><td>
cluster   ->  Relation-like   for    Element of  the topology of [:X,Y:];
</td><td><span data-href='waybel26.html#CC2'>waybel26</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM2887'>
<h2>3.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='borsuk_1.html#K3'>borsuk_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X</font>, <font color="Maroon" title="c2">Y</font> be   <span title="PRE_TOPC:NM.1" data-link="6938.html#ELM21124">TopSpace</span>;<br><span class="kw">let </span><font color="Maroon" title="c3">A</font> be   <span title="STRUCT_0:NM.2" data-link="26.html#ELM25748">Subset</span> of <font color="Maroon" title="c1">X</font>;<br><span class="kw">let </span><font color="Maroon" title="c4">B</font> be   <span title="STRUCT_0:NM.2" data-link="26.html#ELM25748">Subset</span> of <font color="Maroon" title="c2">Y</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><br><span class="kw">redefine </span><a name="K3"><span class="kw">func</span> </a><span class="p1"><span title="BORSUK_1:func.3" data-link="395.html#ELM2887">[:</span><span class="default"><font color="Maroon" title="c3">A</font>,<font color="Maroon" title="c4">B</font></span><span title="BORSUK_1:func.3" data-link="395.html#ELM2887">:]</span></span><span class="kw"> -&gt; </span>  <span title="STRUCT_0:NM.2" data-link="26.html#ELM25748">Subset</span> of <span class="p1"><span title="BORSUK_1:func.2" data-link="395.html#ELM2886">[:</span><span class="default"><font color="Maroon" title="c1">X</font>,<font color="Maroon" title="c2">Y</font></span><span title="BORSUK_1:func.2" data-link="395.html#ELM2886">:]</span></span>;<br><span class="kw">correctness </span>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM2889'>
<h2>4.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='borsuk_1.html#K5'>borsuk_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X</font>, <font color="Maroon" title="c2">Y</font> be   non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>  <span title="PRE_TOPC:NM.1" data-link="6938.html#ELM21124">TopSpace</span>;<br><span class="kw">let </span><font color="Maroon" title="c3">x</font> be   <span title="PRE_TOPC:NM.2" data-link="6939.html#ELM21125">Point</span> of <font color="Maroon" title="c1">X</font>;<br><span class="kw">let </span><font color="Maroon" title="c4">y</font> be   <span title="PRE_TOPC:NM.2" data-link="6939.html#ELM21125">Point</span> of <font color="Maroon" title="c2">Y</font>;<br><span class="kw">let </span><font color="Maroon" title="c5">V</font> be    <span title="CONNSP_2:mode.1" data-link="2029.html#ELM5378">a_neighborhood</span> of <font color="Maroon" title="c3">x</font>;<br><span class="kw">let </span><font color="Maroon" title="c6">W</font> be    <span title="CONNSP_2:mode.1" data-link="2029.html#ELM5378">a_neighborhood</span> of <font color="Maroon" title="c4">y</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><br><span class="kw">redefine </span><a name="K5"><span class="kw">func</span> </a><span class="p1"><span title="BORSUK_1:func.5" data-link="395.html#ELM2889">[:</span><span class="default"><font color="Maroon" title="c5">V</font>,<font color="Maroon" title="c6">W</font></span><span title="BORSUK_1:func.5" data-link="395.html#ELM2889">:]</span></span><span class="kw"> -&gt; </span>   <span title="CONNSP_2:mode.1" data-link="2029.html#ELM5378">a_neighborhood</span> of <span class="p1"><span title="BORSUK_1:func.4" data-link="802.html#ELM2888">[</span><span class="default"><font color="Maroon" title="c3">x</font>,<font color="Maroon" title="c4">y</font></span><span title="BORSUK_1:func.4" data-link="802.html#ELM2888">]</span></span>;<br><span class="kw">correctness </span><span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('borsuk_1/T8')" onmouseout="rh()" data-href="borsuk_1.html#T8">Th8</span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM2890'>
<h2>5.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='borsuk_1.html#K6'>borsuk_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X</font>, <font color="Maroon" title="c2">Y</font> be   non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>  <span title="PRE_TOPC:NM.1" data-link="6938.html#ELM21124">TopSpace</span>;<br><span class="kw">let </span><font color="Maroon" title="c3">A</font> be   <span title="STRUCT_0:NM.2" data-link="26.html#ELM25748">Subset</span> of <font color="Maroon" title="c1">X</font>;<br><span class="kw">let </span><font color="Maroon" title="c4">t</font> be   <span title="PRE_TOPC:NM.2" data-link="6939.html#ELM21125">Point</span> of <font color="Maroon" title="c2">Y</font>;<br><span class="kw">let </span><font color="Maroon" title="c5">V</font> be    <span title="CONNSP_2:mode.2" data-link="2029.html#ELM5379">a_neighborhood</span> of <font color="Maroon" title="c3">A</font>;<br><span class="kw">let </span><font color="Maroon" title="c6">W</font> be    <span title="CONNSP_2:mode.1" data-link="2029.html#ELM5378">a_neighborhood</span> of <font color="Maroon" title="c4">t</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><br><span class="kw">redefine </span><a name="K6"><span class="kw">func</span> </a><span class="p1"><span title="BORSUK_1:func.6" data-link="395.html#ELM2890">[:</span><span class="default"><font color="Maroon" title="c5">V</font>,<font color="Maroon" title="c6">W</font></span><span title="BORSUK_1:func.6" data-link="395.html#ELM2890">:]</span></span><span class="kw"> -&gt; </span>   <span title="CONNSP_2:mode.2" data-link="2029.html#ELM5379">a_neighborhood</span> of <span class="p1"><span title="BORSUK_1:func.3" data-link="395.html#ELM2887">[:</span><span class="default"><font color="Maroon" title="c3">A</font>,<span class="p2"><span title="DOMAIN_1:func.6" data-link="857.html#ELM5997">{</span><span class="default"><font color="Maroon" title="c4">t</font></span><span title="DOMAIN_1:func.6" data-link="857.html#ELM5997">}</span></span></span><span title="BORSUK_1:func.3" data-link="395.html#ELM2887">:]</span></span>;<br><span class="kw">correctness </span>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM2928'>
<h2>6.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='borsuk_2.html#K3'>borsuk_2</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">S1</font>, <font color="Maroon" title="c2">S2</font>, <font color="Maroon" title="c3">T1</font>, <font color="Maroon" title="c4">T2</font> be   non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>  <span title="PRE_TOPC:NM.1" data-link="6938.html#ELM21124">TopSpace</span>;<br><span class="kw">let </span><font color="Maroon" title="c5">f</font> be   <span title="STRUCT_0:NM.6" data-link="3155.html#ELM25752">Function</span> of <font color="Maroon" title="c1">S1</font>,<font color="Maroon" title="c2">S2</font>;<br><span class="kw">let </span><font color="Maroon" title="c6">g</font> be   <span title="STRUCT_0:NM.6" data-link="3155.html#ELM25752">Function</span> of <font color="Maroon" title="c3">T1</font>,<font color="Maroon" title="c4">T2</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="FUNCT_3:func.15" data-link="395.html#ELM8929">[:</span><br><span class="kw">redefine </span><a name="K3"><span class="kw">func</span> </a><span class="p1"><span title="BORSUK_2:func.3" data-link="395.html#ELM2928">[:</span><span class="default"><font color="Maroon" title="c5">f</font>,<font color="Maroon" title="c6">g</font></span><span title="BORSUK_2:func.3" data-link="395.html#ELM2928">:]</span></span><span class="kw"> -&gt; </span>  <span title="STRUCT_0:NM.6" data-link="3155.html#ELM25752">Function</span> of <span class="p1"><span title="BORSUK_1:func.2" data-link="395.html#ELM2886">[:</span><span class="default"><font color="Maroon" title="c1">S1</font>,<font color="Maroon" title="c3">T1</font></span><span title="BORSUK_1:func.2" data-link="395.html#ELM2886">:]</span></span>,<span class="p1"><span title="BORSUK_1:func.2" data-link="395.html#ELM2886">[:</span><span class="default"><font color="Maroon" title="c2">S2</font>,<font color="Maroon" title="c4">T2</font></span><span title="BORSUK_1:func.2" data-link="395.html#ELM2886">:]</span></span>;<br><span class="kw">coherence</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM3475'>
<h2>7.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='cardfil4.html#K1'>cardfil4</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X1</font>, <font color="Maroon" title="c2">X2</font> be   non  <span title="XBOOLE_0:attr.1" data-link="1570.html#ELM29653">empty</span>   <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c3">cB1</font> be   <span title="CARDFIL2:NM.2" data-link="1397.html#ELM3427">filter_base</span> of <font color="Maroon" title="c1">X1</font>;<br><span class="kw">let </span><font color="Maroon" title="c4">cB2</font> be   <span title="CARDFIL2:NM.2" data-link="1397.html#ELM3427">filter_base</span> of <font color="Maroon" title="c2">X2</font>;<br><div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K1"><span class="kw">func</span> </a><span class="p1"><span title="CARDFIL4:func.1" data-link="395.html#ELM3475">[:</span><span class="default"><font color="Maroon" title="c3">cB1</font>,<font color="Maroon" title="c4">cB2</font></span><span title="CARDFIL4:func.1" data-link="395.html#ELM3475">:]</span></span><span class="kw"> -&gt; </span>  <span title="CARDFIL2:NM.2" data-link="1397.html#ELM3427">filter_base</span> of <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><font color="Maroon" title="c1">X1</font>,<font color="Maroon" title="c2">X2</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span><span class="kw"> equals </span><a name="D1"><span class="comment"><font color="firebrick">:: CARDFIL4:def 1</font></span><br></a><span class="p1"> { <span class="default"> <span class="p2"><span title="MCART_1:func.8" data-link="395.html#ELM14958">[:</span><span class="default"><font color="Olive" title="b1">B1</font>,<font color="Olive" title="b2">B2</font></span><span title="MCART_1:func.8" data-link="395.html#ELM14958">:]</span></span> where <font color="Olive" title="b1">B1</font> is    <span title="SUBSET_1:mode.2" data-link="667.html#ELM25869">Element</span> of <font color="Maroon" title="c3">cB1</font>, <font color="Olive" title="b2">B2</font> is    <span title="SUBSET_1:mode.2" data-link="667.html#ELM25869">Element</span> of <font color="Maroon" title="c4">cB2</font> : verum </span> } </span> ;<br>
</div>
<span class="kw">coherence</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM3477'>
<h2>8.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='cardfil4.html#K3'>cardfil4</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X1</font>, <font color="Maroon" title="c2">X2</font> be   non  <span title="XBOOLE_0:attr.1" data-link="1570.html#ELM29653">empty</span>   <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c3">cF1</font> be    <span title="CARD_FIL:mode.1" data-link="1365.html#ELM3369">Filter</span> of <font color="Maroon" title="c1">X1</font>;<br><span class="kw">let </span><font color="Maroon" title="c4">cF2</font> be    <span title="CARD_FIL:mode.1" data-link="1365.html#ELM3369">Filter</span> of <font color="Maroon" title="c2">X2</font>;<br><span class="kw">let </span><font color="Maroon" title="c5">cB1</font> be   <span title="CARDFIL2:NM.1" data-link="1396.html#ELM3426">basis</span> of <font color="Maroon" title="c3">cF1</font>;<br><span class="kw">let </span><font color="Maroon" title="c6">cB2</font> be   <span title="CARDFIL2:NM.1" data-link="1396.html#ELM3426">basis</span> of <font color="Maroon" title="c4">cF2</font>;<br><div about="#D26" typeof="oo:Definition" class="main-sentence">
<a name="K3"><span class="kw">func</span> </a><span class="p1"><span title="CARDFIL4:func.3" data-link="395.html#ELM3477">[:</span><span class="default"><font color="Maroon" title="c5">cB1</font>,<font color="Maroon" title="c6">cB2</font></span><span title="CARDFIL4:func.3" data-link="395.html#ELM3477">:]</span></span><span class="kw"> -&gt; </span>  <span title="CARDFIL2:NM.1" data-link="1396.html#ELM3426">basis</span> of <span class="p1"><span title="CARDFIL4:func.2" data-link="1401.html#ELM3476">&lt;.</span><span class="default"><font color="Maroon" title="c3">cF1</font>,<font color="Maroon" title="c4">cF2</font></span><span title="CARDFIL4:func.2" data-link="1401.html#ELM3476">.)</span></span><span class="kw"> means </span>:<span class="lab"><font color="Green" title="E26">Def2</font></span>: <a name="D3"><span class="comment"><font color="firebrick">:: CARDFIL4:def 3</font></span><br></a> ex <font color="Olive" title="b1">cB3</font> being   <span title="CARDFIL2:NM.2" data-link="1397.html#ELM3427">filter_base</span> of <font color="Maroon" title="c1">X1</font> ex <font color="Olive" title="b2">cB4</font> being   <span title="CARDFIL2:NM.2" data-link="1397.html#ELM3427">filter_base</span> of <font color="Maroon" title="c2">X2</font> st <br>( <font color="Maroon" title="c5">cB1</font> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <font color="Olive" title="b1">cB3</font> &amp; <font color="Maroon" title="c6">cB2</font> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <font color="Olive" title="b2">cB4</font> &amp; <span class="kw">it</span> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1"><span title="CARDFIL4:func.1" data-link="395.html#ELM3475">[:</span><span class="default"><font color="Olive" title="b1">cB3</font>,<font color="Olive" title="b2">cB4</font></span><span title="CARDFIL4:func.1" data-link="395.html#ELM3475">:]</span></span> );<br>
</div>
<span class="kw">existence</span> <span class="kw">uniqueness</span> <br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM3548'>
<h2>9.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='cat_2.html#K6'>cat_2</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">C</font>, <font color="Maroon" title="c2">D</font> be   <span title="CAT_1:NM.4" data-link="1431.html#ELM3503">Category</span>;<br><div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K6"><span class="kw">func</span> </a><span class="p1"><span title="CAT_2:func.6" data-link="395.html#ELM3548">[:</span><span class="default"><font color="Maroon" title="c1">C</font>,<font color="Maroon" title="c2">D</font></span><span title="CAT_2:func.6" data-link="395.html#ELM3548">:]</span></span><span class="kw"> -&gt; </span>  <span title="CAT_1:NM.4" data-link="1431.html#ELM3503">Category</span><span class="kw"> equals </span><a name="D7"><span class="comment"><font color="firebrick">:: CAT_2:def 7</font></span><br></a> <span title="CAT_1:aggr.1" data-href="cat_1.html#G1">CatStr</span>(# <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"> the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c1">C</font>, the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c2">D</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"> the <span title="STRUCT_0:sel.4" data-href="struct_0.html#U4">carrier'</span> of <font color="Maroon" title="c1">C</font>, the <span title="STRUCT_0:sel.4" data-href="struct_0.html#U4">carrier'</span> of <font color="Maroon" title="c2">D</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<span class="p1"><span title="FUNCT_3:func.16" data-link="395.html#ELM8930">[:</span><span class="default"> the <span title="GRAPH_1:sel.1" data-href="graph_1.html#U1">Source</span> of <font color="Maroon" title="c1">C</font>, the <span title="GRAPH_1:sel.1" data-href="graph_1.html#U1">Source</span> of <font color="Maroon" title="c2">D</font></span><span title="FUNCT_3:func.16" data-link="395.html#ELM8930">:]</span></span>,<span class="p1"><span title="FUNCT_3:func.16" data-link="395.html#ELM8930">[:</span><span class="default"> the <span title="GRAPH_1:sel.2" data-href="graph_1.html#U2">Target</span> of <font color="Maroon" title="c1">C</font>, the <span title="GRAPH_1:sel.2" data-href="graph_1.html#U2">Target</span> of <font color="Maroon" title="c2">D</font></span><span title="FUNCT_3:func.16" data-link="395.html#ELM8930">:]</span></span>,<span class="p1"><span title="FUNCT_4:func.10" data-link="1805.html#ELM8946">|:</span><span class="default"> the <span title="CAT_1:sel.1" data-href="cat_1.html#U1">Comp</span> of <font color="Maroon" title="c1">C</font>, the <span title="CAT_1:sel.1" data-href="cat_1.html#U1">Comp</span> of <font color="Maroon" title="c2">D</font></span><span title="FUNCT_4:func.10" data-link="1805.html#ELM8946">:|</span></span> #);<br>
</div>
<span class="kw">coherence</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster [:A,B:] ->  discrete  ;
</td><td><span data-href='nattra_1.html#FC3'>nattra_1</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM3557'>
<h2>10.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='cat_2.html#K15'>cat_2</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">C</font>, <font color="Maroon" title="c2">C9</font>, <font color="Maroon" title="c3">D</font>, <font color="Maroon" title="c4">D9</font> be   <span title="CAT_1:NM.4" data-link="1431.html#ELM3503">Category</span>;<br><span class="kw">let </span><font color="Maroon" title="c5">T</font> be    <span title="CAT_1:mode.2" data-link="1432.html#ELM3504">Functor</span> of <font color="Maroon" title="c1">C</font>,<font color="Maroon" title="c3">D</font>;<br><span class="kw">let </span><font color="Maroon" title="c6">T9</font> be    <span title="CAT_1:mode.2" data-link="1432.html#ELM3504">Functor</span> of <font color="Maroon" title="c2">C9</font>,<font color="Maroon" title="c4">D9</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="FUNCT_3:func.15" data-link="395.html#ELM8929">[:</span><br><span class="kw">redefine </span><a name="K15"><span class="kw">func</span> </a><span class="p1"><span title="CAT_2:func.15" data-link="395.html#ELM3557">[:</span><span class="default"><font color="Maroon" title="c5">T</font>,<font color="Maroon" title="c6">T9</font></span><span title="CAT_2:func.15" data-link="395.html#ELM3557">:]</span></span><span class="kw"> -&gt; </span>   <span title="CAT_1:mode.2" data-link="1432.html#ELM3504">Functor</span> of <span class="p1"><span title="CAT_2:func.6" data-link="395.html#ELM3548">[:</span><span class="default"><font color="Maroon" title="c1">C</font>,<font color="Maroon" title="c2">C9</font></span><span title="CAT_2:func.6" data-link="395.html#ELM3548">:]</span></span>,<span class="p1"><span title="CAT_2:func.6" data-link="395.html#ELM3548">[:</span><span class="default"><font color="Maroon" title="c3">D</font>,<font color="Maroon" title="c4">D9</font></span><span title="CAT_2:func.6" data-link="395.html#ELM3548">:]</span></span>;<br><span class="kw">coherence</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM4421'>
<h2>11.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='classes2.html#K11'>classes2</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">U</font> be   <span title="CLASSES2:NM.1" data-link="1738.html#ELM4408">Universe</span>;<br><span class="kw">let </span><font color="Maroon" title="c2">u</font> be    <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="TARSKI:func.1" data-link="857.html#ELM26065">{</span><br><span class="kw">redefine </span><a name="K1"><span class="kw">func</span> </a><span class="p1"><span title="CLASSES2:func.1" data-link="857.html#ELM4411">{</span><span class="default"><font color="Maroon" title="c2">u</font></span><span title="CLASSES2:func.1" data-link="857.html#ELM4411">}</span></span><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T2')" onmouseout="rh()" data-href="classes2.html#T2">Th2</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.1" data-link="1652.html#ELM30579">bool</span><br><span class="kw">redefine </span><a name="K2"><span class="kw">func</span> </a> <span title="CLASSES2:func.2" data-link="1652.html#ELM4412">bool</span> <font color="Maroon" title="c2">u</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T59')" onmouseout="rh()" data-href="classes2.html#T59">Th59</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="TARSKI:func.3" data-link="1741.html#ELM26067">union</span><br><span class="kw">redefine </span><a name="K3"><span class="kw">func</span> </a> <span title="CLASSES2:func.3" data-link="1741.html#ELM4413">union</span> <font color="Maroon" title="c2">u</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T59')" onmouseout="rh()" data-href="classes2.html#T59">Th59</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="SETFAM_1:func.1" data-link="1742.html#ELM25003">meet</span><br><span class="kw">redefine </span><a name="K4"><span class="kw">func</span> </a> <span title="CLASSES2:func.4" data-link="1742.html#ELM4414">meet</span> <font color="Maroon" title="c2">u</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T59')" onmouseout="rh()" data-href="classes2.html#T59">Th59</span></span>;<br><span class="kw">let </span><font color="Maroon" title="c3">v</font> be    <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="TARSKI:func.2" data-link="857.html#ELM26066">{</span><br><span class="kw">redefine </span><a name="K5"><span class="kw">func</span> </a><span class="p1"><span title="CLASSES2:func.5" data-link="857.html#ELM4415">{</span><span class="default"><font color="Maroon" title="c2">u</font>,<font color="Maroon" title="c3">v</font></span><span title="CLASSES2:func.5" data-link="857.html#ELM4415">}</span></span><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T2')" onmouseout="rh()" data-href="classes2.html#T2">Th2</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="TARSKI:func.4" data-link="802.html#ELM26068">[</span><br><span class="kw">redefine </span><a name="K6"><span class="kw">func</span> </a><span class="p1"><span title="CLASSES2:func.6" data-link="802.html#ELM4416">[</span><span class="default"><font color="Maroon" title="c2">u</font>,<font color="Maroon" title="c3">v</font></span><span title="CLASSES2:func.6" data-link="802.html#ELM4416">]</span></span><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T3')" onmouseout="rh()" data-href="classes2.html#T3">Th3</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="XBOOLE_0:func.2" data-link="1743.html#ELM29649">\/</span><br><span class="kw">redefine </span><a name="K7"><span class="kw">func</span> </a><font color="Maroon" title="c2">u</font> <span title="CLASSES2:func.7" data-link="1743.html#ELM4417">\/</span> <font color="Maroon" title="c3">v</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T60')" onmouseout="rh()" data-href="classes2.html#T60">Th60</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="XBOOLE_0:func.3" data-link="1487.html#ELM29650">/\</span><br><span class="kw">redefine </span><a name="K8"><span class="kw">func</span> </a><font color="Maroon" title="c2">u</font> <span title="CLASSES2:func.8" data-link="1487.html#ELM4418">/\</span> <font color="Maroon" title="c3">v</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T60')" onmouseout="rh()" data-href="classes2.html#T60">Th60</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="XBOOLE_0:func.4" data-link="724.html#ELM29651">\</span><br><span class="kw">redefine </span><a name="K9"><span class="kw">func</span> </a><font color="Maroon" title="c2">u</font> <span title="CLASSES2:func.9" data-link="724.html#ELM4419">\</span> <font color="Maroon" title="c3">v</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T60')" onmouseout="rh()" data-href="classes2.html#T60">Th60</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="XBOOLE_0:func.5" data-link="1174.html#ELM29652">\+\</span><br><span class="kw">redefine </span><a name="K10"><span class="kw">func</span> </a><font color="Maroon" title="c2">u</font> <span title="CLASSES2:func.10" data-link="1174.html#ELM4420">\+\</span> <font color="Maroon" title="c3">v</font><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T60')" onmouseout="rh()" data-href="classes2.html#T60">Th60</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><br><span class="kw">redefine </span><a name="K11"><span class="kw">func</span> </a><span class="p1"><span title="CLASSES2:func.11" data-link="395.html#ELM4421">[:</span><span class="default"><font color="Maroon" title="c2">u</font>,<font color="Maroon" title="c3">v</font></span><span title="CLASSES2:func.11" data-link="395.html#ELM4421">:]</span></span><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T61')" onmouseout="rh()" data-href="classes2.html#T61">Th61</span></span>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="FUNCT_2:func.1" data-link="52.html#ELM8878">Funcs</span><br><span class="kw">redefine </span><a name="K12"><span class="kw">func</span> </a> <span title="CLASSES2:func.12" data-link="52.html#ELM4422">Funcs</span> (<font color="Maroon" title="c2">u</font>,<font color="Maroon" title="c3">v</font>)<span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c1">U</font>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('classes2/T61')" onmouseout="rh()" data-href="classes2.html#T61">Th61</span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM6890'>
<h2>12.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='filter_1.html#K7'>filter_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">L1</font>, <font color="Maroon" title="c2">L2</font> be   non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="LATTICES:struct.3" data-link="4730.html#ELM13589">LattStr</span> ;<br><div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K7"><span class="kw">func</span> </a><span class="p1"><span title="FILTER_1:func.7" data-link="395.html#ELM6890">[:</span><span class="default"><font color="Maroon" title="c1">L1</font>,<font color="Maroon" title="c2">L2</font></span><span title="FILTER_1:func.7" data-link="395.html#ELM6890">:]</span></span><span class="kw"> -&gt; </span>  <span title="LATTICES:attr.3" data-href="lattices.html#V3">strict</span>   <span title="LATTICES:struct.3" data-link="4730.html#ELM13589">LattStr</span> <span class="kw"> equals </span><a name="D7"><span class="comment"><font color="firebrick">:: FILTER_1:def 7</font></span><br></a> <span title="LATTICES:aggr.3" data-href="lattices.html#G3">LattStr</span>(# <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"> the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c1">L1</font>, the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c2">L2</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<span class="p1"><span title="FILTER_1:func.6" data-link="1805.html#ELM6889">|:</span><span class="default"> the <span title="LATTICES:sel.2" data-href="lattices.html#U2">L_join</span> of <font color="Maroon" title="c1">L1</font>, the <span title="LATTICES:sel.2" data-href="lattices.html#U2">L_join</span> of <font color="Maroon" title="c2">L2</font></span><span title="FILTER_1:func.6" data-link="1805.html#ELM6889">:|</span></span>,<span class="p1"><span title="FILTER_1:func.6" data-link="1805.html#ELM6889">|:</span><span class="default"> the <span title="LATTICES:sel.1" data-href="lattices.html#U1">L_meet</span> of <font color="Maroon" title="c1">L1</font>, the <span title="LATTICES:sel.1" data-href="lattices.html#U1">L_meet</span> of <font color="Maroon" title="c2">L2</font></span><span title="FILTER_1:func.6" data-link="1805.html#ELM6889">:|</span></span> #);<br>
</div>
<span class="kw">correctness </span><br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster [:L1,L2:] ->  non  empty   strict  ;
</td><td><span data-href='filter_1.html#FC2'>filter_1</span></td></tr>
<tr><td>
cluster [:L1,L2:] ->  strict   Lattice-like  ;
</td><td><span data-href='filter_1.html#FC3'>filter_1</span></td></tr>
<tr><td>
cluster [:L1,L2:] ->  bounded  ;
</td><td><span data-href='latstone.html#FC1'>latstone</span></td></tr>
<tr><td>
cluster [:L1,L2:] ->  pseudocomplemented  ;
</td><td><span data-href='latstone.html#FC17'>latstone</span></td></tr>
<tr><td>
cluster [:L1,L2:] ->  Stone  ;
</td><td><span data-href='latstone.html#FC18'>latstone</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM8929'>
<h2>13.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='funct_3.html#K15'>funct_3</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">f</font>, <font color="Maroon" title="c2">g</font> be   <span title="FUNCT_1:NM.1" data-link="3155.html#ELM8817">Function</span>;<br><div about="#D43" typeof="oo:Definition" class="main-sentence">
<a name="K15"><span class="kw">func</span> </a><span class="p1"><span title="FUNCT_3:func.15" data-link="395.html#ELM8929">[:</span><span class="default"><font color="Maroon" title="c1">f</font>,<font color="Maroon" title="c2">g</font></span><span title="FUNCT_3:func.15" data-link="395.html#ELM8929">:]</span></span><span class="kw"> -&gt; </span>  <span title="FUNCT_1:NM.1" data-link="3155.html#ELM8817">Function</span><span class="kw"> means </span>:<span class="lab"><font color="Green" title="E43">Def8</font></span>: <a name="D8"><span class="comment"><font color="firebrick">:: FUNCT_3:def 8</font></span><br></a>(  <span title="RELAT_1:NK.1" data-link="41.html#ELM22384">dom</span> <span class="kw">it</span> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><span class="p2">(<span class="default"><span title="RELAT_1:NK.1" data-link="41.html#ELM22384">dom</span> <font color="Maroon" title="c1">f</font></span>)</span>,<span class="p2">(<span class="default"><span title="RELAT_1:NK.1" data-link="41.html#ELM22384">dom</span> <font color="Maroon" title="c2">g</font></span>)</span></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span> &amp; (  for <font color="Olive" title="b1">x</font>, <font color="Olive" title="b2">y</font> being    <span title="HIDDEN:mode.1" data-link="4140.html#ELM11935">object</span>   st <font color="Olive" title="b1">x</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span>  <span title="RELAT_1:NK.1" data-link="41.html#ELM22384">dom</span> <font color="Maroon" title="c1">f</font> &amp; <font color="Olive" title="b2">y</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span>  <span title="RELAT_1:NK.1" data-link="41.html#ELM22384">dom</span> <font color="Maroon" title="c2">g</font> holds <br><span class="kw">it</span> <span title="BINOP_1:func.1" data-link="141.html#ELM2753">.</span> (<font color="Olive" title="b1">x</font>,<font color="Olive" title="b2">y</font>) <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1"><span title="TARSKI:func.4" data-link="802.html#ELM26068">[</span><span class="default"><span class="p2">(<span class="default"><font color="Maroon" title="c1">f</font> <span title="FUNCT_1:func.1" data-link="141.html#ELM8818">.</span> <font color="Olive" title="b1">x</font></span>)</span>,<span class="p2">(<span class="default"><font color="Maroon" title="c2">g</font> <span title="FUNCT_1:func.1" data-link="141.html#ELM8818">.</span> <font color="Olive" title="b2">y</font></span>)</span></span><span title="TARSKI:func.4" data-link="802.html#ELM26068">]</span></span> ) );<br>
</div>
<span class="kw">existence</span> <span class="kw">uniqueness</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster [:f,g:] ->  continuous   for  Function of [:S1,S2:],[:T1,T2:];
</td><td><span data-href='borsuk_2.html#FC4'>borsuk_2</span></td></tr>
<tr><td>
cluster x `1  ->  pair  ;
</td><td><span data-href='fomodel0.html#FC128'>fomodel0</span></td></tr>
<tr><td>
cluster x `2  ->  pair  ;
</td><td><span data-href='fomodel0.html#FC129'>fomodel0</span></td></tr>
<tr><td>
cluster [:F,G:] ->  one-to-one  ;
</td><td><span data-href='funct_3.html#FC3'>funct_3</span></td></tr>
<tr><td>
cluster [:f,g:] ->  empty  ;
</td><td><span data-href='functor0.html#FC2'>functor0</span></td></tr>
<tr><td>
cluster [:g,f:] ->  empty  ;
</td><td><span data-href='functor0.html#FC3'>functor0</span></td></tr>
<tr><td>
cluster [:f,g:] ->  one-to-one  ;
</td><td><span data-href='hilbert3.html#FC3'>hilbert3</span></td></tr>
<tr><td>
cluster [:P,Q:] ->  bijective   for  Function of [:A,B:],[:A,B:];
</td><td><span data-href='hilbert3.html#FC4'>hilbert3</span></td></tr>
<tr><td>
cluster [:f,g:] ->  involutive  ;
</td><td><span data-href='hilbert4.html#FC4'>hilbert4</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM8930'>
<h2>14.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='funct_3.html#K16'>funct_3</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X1</font>, <font color="Maroon" title="c2">X2</font>, <font color="Maroon" title="c3">Y1</font>, <font color="Maroon" title="c4">Y2</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c5">f1</font> be   <span title="FUNCT_2:NM.1" data-link="3155.html#ELM8873">Function</span> of <font color="Maroon" title="c1">X1</font>,<font color="Maroon" title="c3">Y1</font>;<br><span class="kw">let </span><font color="Maroon" title="c6">f2</font> be   <span title="FUNCT_2:NM.1" data-link="3155.html#ELM8873">Function</span> of <font color="Maroon" title="c2">X2</font>,<font color="Maroon" title="c4">Y2</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="FUNCT_3:func.15" data-link="395.html#ELM8929">[:</span><br><span class="kw">redefine </span><a name="K16"><span class="kw">func</span> </a><span class="p1"><span title="FUNCT_3:func.16" data-link="395.html#ELM8930">[:</span><span class="default"><font color="Maroon" title="c5">f1</font>,<font color="Maroon" title="c6">f2</font></span><span title="FUNCT_3:func.16" data-link="395.html#ELM8930">:]</span></span><span class="kw"> -&gt; </span>  <span title="FUNCT_2:NM.1" data-link="3155.html#ELM8873">Function</span> of <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><font color="Maroon" title="c1">X1</font>,<font color="Maroon" title="c2">X2</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><font color="Maroon" title="c3">Y1</font>,<font color="Maroon" title="c4">Y2</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('funct_3/T74')" onmouseout="rh()" data-href="funct_3.html#T74">Th74</span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM14641'>
<h2>15.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='matrix_3.html#K8'>matrix_3</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">I</font>, <font color="Maroon" title="c2">J</font> be   non  <span title="XBOOLE_0:attr.1" data-link="1570.html#ELM29653">empty</span>   <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c3">X</font> be    <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of  <span title="FINSUB_1:func.5" data-link="918.html#ELM7492">Fin</span> <font color="Maroon" title="c1">I</font>;<br><span class="kw">let </span><font color="Maroon" title="c4">Y</font> be    <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of  <span title="FINSUB_1:func.5" data-link="918.html#ELM7492">Fin</span> <font color="Maroon" title="c2">J</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><br><span class="kw">redefine </span><a name="K8"><span class="kw">func</span> </a><span class="p1"><span title="MATRIX_3:func.8" data-link="395.html#ELM14641">[:</span><span class="default"><font color="Maroon" title="c3">X</font>,<font color="Maroon" title="c4">Y</font></span><span title="MATRIX_3:func.8" data-link="395.html#ELM14641">:]</span></span><span class="kw"> -&gt; </span>   <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of  <span title="FINSUB_1:func.5" data-link="918.html#ELM7492">Fin</span> <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><font color="Maroon" title="c1">I</font>,<font color="Maroon" title="c2">J</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>;<br><span class="kw">coherence</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM14958'>
<h2>16.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='mcart_1.html#K8'>mcart_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X1</font>, <font color="Maroon" title="c2">X2</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c3">A1</font> be   <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <font color="Maroon" title="c1">X1</font>;<br><span class="kw">let </span><font color="Maroon" title="c4">A2</font> be   <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <font color="Maroon" title="c2">X2</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><br><span class="kw">redefine </span><a name="K8"><span class="kw">func</span> </a><span class="p1"><span title="MCART_1:func.8" data-link="395.html#ELM14958">[:</span><span class="default"><font color="Maroon" title="c3">A1</font>,<font color="Maroon" title="c4">A2</font></span><span title="MCART_1:func.8" data-link="395.html#ELM14958">:]</span></span><span class="kw"> -&gt; </span>  <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><font color="Maroon" title="c1">X1</font>,<font color="Maroon" title="c2">X2</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" onmouseover="rs('zfmisc_1/T96')" onmouseout="rh()" data-href="zfmisc_1.html#T96">ZFMISC_1:96</span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM14959'>
<h2>17.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='mcart_1.html#K9'>mcart_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X1</font>, <font color="Maroon" title="c2">X2</font>, <font color="Maroon" title="c3">X3</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c4">A1</font> be   <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <font color="Maroon" title="c1">X1</font>;<br><span class="kw">let </span><font color="Maroon" title="c5">A2</font> be   <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <font color="Maroon" title="c2">X2</font>;<br><span class="kw">let </span><font color="Maroon" title="c6">A3</font> be   <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <font color="Maroon" title="c3">X3</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.3" data-link="395.html#ELM30581">[:</span><br><span class="kw">redefine </span><a name="K9"><span class="kw">func</span> </a><span class="p1"><span title="MCART_1:func.9" data-link="395.html#ELM14959">[:</span><span class="default"><font color="Maroon" title="c4">A1</font>,<font color="Maroon" title="c5">A2</font>,<font color="Maroon" title="c6">A3</font></span><span title="MCART_1:func.9" data-link="395.html#ELM14959">:]</span></span><span class="kw"> -&gt; </span>  <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <span class="p1"><span title="ZFMISC_1:func.3" data-link="395.html#ELM30581">[:</span><span class="default"><font color="Maroon" title="c1">X1</font>,<font color="Maroon" title="c2">X2</font>,<font color="Maroon" title="c3">X3</font></span><span title="ZFMISC_1:func.3" data-link="395.html#ELM30581">:]</span></span>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('mcart_1/T73')" onmouseout="rh()" data-href="mcart_1.html#T73">Th58</span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM14960'>
<h2>18.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='mcart_1.html#K10'>mcart_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X1</font>, <font color="Maroon" title="c2">X2</font>, <font color="Maroon" title="c3">X3</font>, <font color="Maroon" title="c4">X4</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c5">A1</font> be   <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <font color="Maroon" title="c1">X1</font>;<br><span class="kw">let </span><font color="Maroon" title="c6">A2</font> be   <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <font color="Maroon" title="c2">X2</font>;<br><span class="kw">let </span><font color="Maroon" title="c7">A3</font> be   <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <font color="Maroon" title="c3">X3</font>;<br><span class="kw">let </span><font color="Maroon" title="c8">A4</font> be   <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <font color="Maroon" title="c4">X4</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.4" data-link="395.html#ELM30582">[:</span><br><span class="kw">redefine </span><a name="K10"><span class="kw">func</span> </a><span class="p1"><span title="MCART_1:func.10" data-link="395.html#ELM14960">[:</span><span class="default"><font color="Maroon" title="c5">A1</font>,<font color="Maroon" title="c6">A2</font>,<font color="Maroon" title="c7">A3</font>,<font color="Maroon" title="c8">A4</font></span><span title="MCART_1:func.10" data-link="395.html#ELM14960">:]</span></span><span class="kw"> -&gt; </span>  <span title="SUBSET_1:NM.2" data-link="26.html#ELM25868">Subset</span> of <span class="p1"><span title="ZFMISC_1:func.4" data-link="395.html#ELM30582">[:</span><span class="default"><font color="Maroon" title="c1">X1</font>,<font color="Maroon" title="c2">X2</font>,<font color="Maroon" title="c3">X3</font>,<font color="Maroon" title="c4">X4</font></span><span title="ZFMISC_1:func.4" data-link="395.html#ELM30582">:]</span></span>;<br><span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="ref" target="_self" onmouseover="rs('mcart_1/T84')" onmouseout="rh()" data-href="mcart_1.html#T84">Th68</span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM20948'>
<h2>19.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='pralg_1.html#K5'>pralg_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">U1</font>, <font color="Maroon" title="c2">U2</font> be   <span title="UNIALG_1:NM.1" data-link="8471.html#ELM27598">Universal_Algebra</span>;<br><span class="kw">assume </span><a name="E1:5"></a><span class="lab"><font color="Green" title="E6">A1</font></span>: 
<font color="Maroon" title="c1">U1</font>,<font color="Maroon" title="c2">U2</font> <span title="UNIALG_2:pred.1" data-link="1701.html#ELM27610">are_similar</span> 
 ;<br><div about="#D6" typeof="oo:Definition" class="main-sentence">
<a name="K5"><span class="kw">func</span> </a><span class="p1"><span title="PRALG_1:func.5" data-link="395.html#ELM20948">[:</span><span class="default"><font color="Maroon" title="c1">U1</font>,<font color="Maroon" title="c2">U2</font></span><span title="PRALG_1:func.5" data-link="395.html#ELM20948">:]</span></span><span class="kw"> -&gt; </span>  <span title="UNIALG_1:attr.1" data-href="unialg_1.html#V1">strict</span>  <span title="UNIALG_1:NM.1" data-link="8471.html#ELM27598">Universal_Algebra</span><span class="kw"> equals </span>:<span class="lab"><font color="Green" title="E6">Def5</font></span>: <a name="D5"><span class="comment"><font color="firebrick">:: PRALG_1:def 5</font></span><br></a> <span title="UNIALG_1:aggr.1" data-href="unialg_1.html#G1">UAStr</span>(# <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"> the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c1">U1</font>, the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c2">U2</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<span class="p1">(<span class="default"><span title="PRALG_1:func.4" data-link="5774.html#ELM20947">Opers</span> (<font color="Maroon" title="c1">U1</font>,<font color="Maroon" title="c2">U2</font>)</span>)</span> #);<br>
</div>
<span class="kw">coherence</span> <span class="kw">by</span> <span class="lab"><span class="lab"><font color="Green" title="E6">A1</font></span><span class="ref" target="_self" onmouseover="rs('pralg_1/T1')" onmouseout="rh()" data-href="pralg_1.html#T1">Th1</span></span>;<br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM20994'>
<h2>20.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='pralg_2.html#K8'>pralg_2</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">S</font> be   non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="MSUALG_1:struct.1" data-link="5758.html#ELM17052">ManySortedSign</span> ;<br><span class="kw">let </span><font color="Maroon" title="c2">U1</font>, <font color="Maroon" title="c3">U2</font> be   <span title="MSUALG_1:attr.4" data-link="3057.html#ELM17069">non-empty</span>   <span title="MSUALG_1:struct.3" data-link="5760.html#ELM17054">MSAlgebra</span> over <font color="Maroon" title="c1">S</font>;<br><div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K8"><span class="kw">func</span> </a><span class="p1"><span title="PRALG_2:func.8" data-link="395.html#ELM20994">[:</span><span class="default"><font color="Maroon" title="c2">U1</font>,<font color="Maroon" title="c3">U2</font></span><span title="PRALG_2:func.8" data-link="395.html#ELM20994">:]</span></span><span class="kw"> -&gt; </span>   <span title="MSUALG_1:struct.3" data-link="5760.html#ELM17054">MSAlgebra</span> over <font color="Maroon" title="c1">S</font><span class="kw"> equals </span><a name="D8"><span class="comment"><font color="firebrick">:: PRALG_2:def 8</font></span><br></a> <span title="MSUALG_1:aggr.3" data-href="msualg_1.html#G3">MSAlgebra</span>(# <span class="p1"><span title="PBOOLE:func.6" data-link="1528.html#ELM19823">[|</span><span class="default"> the <span title="MSUALG_1:sel.3" data-href="msualg_1.html#U3">Sorts</span> of <font color="Maroon" title="c2">U1</font>, the <span title="MSUALG_1:sel.3" data-href="msualg_1.html#U3">Sorts</span> of <font color="Maroon" title="c3">U2</font></span><span title="PBOOLE:func.6" data-link="1528.html#ELM19823">|]</span></span>,<span class="p1"><span title="PRALG_2:func.4" data-link="6907.html#ELM20990">[[:</span><span class="default"> the <span title="MSUALG_1:sel.4" data-href="msualg_1.html#U4">Charact</span> of <font color="Maroon" title="c2">U1</font>, the <span title="MSUALG_1:sel.4" data-href="msualg_1.html#U4">Charact</span> of <font color="Maroon" title="c3">U2</font></span><span title="PRALG_2:func.4" data-link="6907.html#ELM20990">:]]</span></span> #);<br>
</div>
<span class="kw">coherence</span> <br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster [:A,B:] ->  non-empty  ;
</td><td><span data-href='msualg_9.html#FC3'>msualg_9</span></td></tr>
<tr><td>
cluster [:U1,U2:] ->  strict  ;
</td><td><span data-href='pralg_2.html#FC4'>pralg_2</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM21385'>
<h2>21.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='prvect_1.html#K12'>prvect_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">a</font> be   <span title="PRVECT_1:NM.1" data-link="7023.html#ELM21370">Domain-Sequence</span>;<br><span class="kw">let </span><font color="Maroon" title="c2">b</font> be    <span title="PRVECT_1:mode.1" data-link="7024.html#ELM21371">BinOps</span> of <font color="Maroon" title="c1">a</font>;<br><div about="#D26" typeof="oo:Definition" class="main-sentence">
<a name="K12"><span class="kw">func</span> </a><span class="p1"><span title="PRVECT_1:func.12" data-link="395.html#ELM21385">[:</span><span class="default"><font color="Maroon" title="c2">b</font></span><span title="PRVECT_1:func.12" data-link="395.html#ELM21385">:]</span></span><span class="kw"> -&gt; </span>  <span title="BINOP_1:NM.2" data-link="1124.html#ELM2752">BinOp</span> of <span class="p1">(<span class="default"><span title="CARD_3:func.4" data-link="1342.html#ELM3294">product</span> <font color="Maroon" title="c1">a</font></span>)</span><span class="kw"> means </span>:<span class="lab"><font color="Green" title="E26">Def8</font></span>: <a name="D8"><span class="comment"><font color="firebrick">:: PRVECT_1:def 8</font></span><br></a> for <font color="Olive" title="b1">f</font>, <font color="Olive" title="b2">g</font> being    <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of  <span title="CARD_3:func.4" data-link="1342.html#ELM3294">product</span> <font color="Maroon" title="c1">a</font><br>  for <font color="Olive" title="b3">i</font> being    <span title="SUBSET_1:mode.2" data-link="667.html#ELM25869">Element</span> of  <span title="FINSEQ_1:func.4" data-link="41.html#ELM7097">dom</span> <font color="Maroon" title="c1">a</font> holds  <span class="p1">(<span class="default"><span class="kw">it</span> <span title="BINOP_1:func.4" data-link="141.html#ELM2756">.</span> (<font color="Olive" title="b1">f</font>,<font color="Olive" title="b2">g</font>)</span>)</span> <span title="PRVECT_1:func.8" data-link="141.html#ELM21381">.</span> <font color="Olive" title="b3">i</font> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1">(<span class="default"><font color="Maroon" title="c2">b</font> <span title="PRVECT_1:func.9" data-link="141.html#ELM21382">.</span> <font color="Olive" title="b3">i</font></span>)</span> <span title="BINOP_1:func.4" data-link="141.html#ELM2756">.</span> (<span class="p1">(<span class="default"><font color="Olive" title="b1">f</font> <span title="PRVECT_1:func.8" data-link="141.html#ELM21381">.</span> <font color="Olive" title="b3">i</font></span>)</span>,<span class="p1">(<span class="default"><font color="Olive" title="b2">g</font> <span title="PRVECT_1:func.8" data-link="141.html#ELM21381">.</span> <font color="Olive" title="b3">i</font></span>)</span>);<br>
</div>
<span class="kw">existence</span> <span class="kw">uniqueness</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM21411'>
<h2>22.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='prvect_2.html#K2'>prvect_2</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">F</font> be   <span title="PRVECT_1:NM.1" data-link="7023.html#ELM21370">Domain-Sequence</span>;<br><span class="kw">let </span><font color="Maroon" title="c2">X</font> be   non  <span title="XBOOLE_0:attr.1" data-link="1570.html#ELM29653">empty</span>   <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c3">p</font> be    <span title="PRVECT_2:mode.1" data-link="7035.html#ELM21407">MultOps</span> of <font color="Maroon" title="c2">X</font>,<font color="Maroon" title="c1">F</font>;<br><div about="#D6" typeof="oo:Definition" class="main-sentence">
<a name="K2"><span class="kw">func</span> </a><span class="p1"><span title="PRVECT_2:func.2" data-link="395.html#ELM21411">[:</span><span class="default"><font color="Maroon" title="c3">p</font></span><span title="PRVECT_2:func.2" data-link="395.html#ELM21411">:]</span></span><span class="kw"> -&gt; </span>  <span title="FUNCT_2:NM.1" data-link="3155.html#ELM8873">Function</span> of <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><font color="Maroon" title="c2">X</font>,<span class="p2">(<span class="default"><span title="CARD_3:func.4" data-link="1342.html#ELM3294">product</span> <font color="Maroon" title="c1">F</font></span>)</span></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<span class="p1">(<span class="default"><span title="CARD_3:func.4" data-link="1342.html#ELM3294">product</span> <font color="Maroon" title="c1">F</font></span>)</span><span class="kw"> means </span>:<span class="lab"><font color="Green" title="E6">Def2</font></span>: <a name="D2"><span class="comment"><font color="firebrick">:: PRVECT_2:def 2</font></span><br></a> for <font color="Olive" title="b1">x</font> being    <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of <font color="Maroon" title="c2">X</font><br>  for <font color="Olive" title="b2">d</font> being    <span title="SUBSET_1:mode.1" data-link="667.html#ELM25867">Element</span> of  <span title="CARD_3:func.4" data-link="1342.html#ELM3294">product</span> <font color="Maroon" title="c1">F</font><br>  for <font color="Olive" title="b3">i</font> being    <span title="SUBSET_1:mode.2" data-link="667.html#ELM25869">Element</span> of  <span title="FINSEQ_1:func.4" data-link="41.html#ELM7097">dom</span> <font color="Maroon" title="c1">F</font> holds  <span class="p1">(<span class="default"><span class="kw">it</span> <span title="BINOP_1:func.2" data-link="141.html#ELM2754">.</span> (<font color="Olive" title="b1">x</font>,<font color="Olive" title="b2">d</font>)</span>)</span> <span title="PRVECT_1:func.8" data-link="141.html#ELM21381">.</span> <font color="Olive" title="b3">i</font> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1">(<span class="default"><font color="Maroon" title="c3">p</font> <span title="PRVECT_2:func.1" data-link="141.html#ELM21410">.</span> <font color="Olive" title="b3">i</font></span>)</span> <span title="BINOP_1:func.2" data-link="141.html#ELM2754">.</span> (<font color="Olive" title="b1">x</font>,<span class="p1">(<span class="default"><font color="Olive" title="b2">d</font> <span title="PRVECT_1:func.8" data-link="141.html#ELM21381">.</span> <font color="Olive" title="b3">i</font></span>)</span>);<br>
</div>
<span class="kw">existence</span> <span class="kw">uniqueness</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM21435'>
<h2>23.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='prvect_3.html#K4'>prvect_3</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">G</font>, <font color="Maroon" title="c2">F</font> be   non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="ALGSTR_0:struct.2" data-link="320.html#ELM739">addLoopStr</span> ;<br><div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K4"><span class="kw">func</span> </a><span class="p1"><span title="PRVECT_3:func.4" data-link="395.html#ELM21435">[:</span><span class="default"><font color="Maroon" title="c1">G</font>,<font color="Maroon" title="c2">F</font></span><span title="PRVECT_3:func.4" data-link="395.html#ELM21435">:]</span></span><span class="kw"> -&gt; </span>  non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="ALGSTR_0:attr.8" data-href="algstr_0.html#V8">strict</span>   <span title="ALGSTR_0:struct.2" data-link="320.html#ELM739">addLoopStr</span> <span class="kw"> equals </span><a name="D4"><span class="comment"><font color="firebrick">:: PRVECT_3:def 4</font></span><br></a> <span title="ALGSTR_0:aggr.2" data-href="algstr_0.html#G2">addLoopStr</span>(# <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"> the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c1">G</font>, the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c2">F</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<span class="p1">(<span class="default"><span title="PRVECT_3:func.1" data-link="7043.html#ELM21432">prod_ADD</span> (<font color="Maroon" title="c1">G</font>,<font color="Maroon" title="c2">F</font>)</span>)</span>,<span class="p1">(<span class="default"><span title="PRVECT_3:func.3" data-link="7045.html#ELM21434">prod_ZERO</span> (<font color="Maroon" title="c1">G</font>,<font color="Maroon" title="c2">F</font>)</span>)</span> #);<br>
</div>
<span class="kw">correctness </span><br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   Abelian  ;
</td><td><span data-href='prvect_3.html#FC2'>prvect_3</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   add-associative  ;
</td><td><span data-href='prvect_3.html#FC3'>prvect_3</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   right_zeroed  ;
</td><td><span data-href='prvect_3.html#FC4'>prvect_3</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   right_complementable  ;
</td><td><span data-href='prvect_3.html#FC5'>prvect_3</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   right_complementable   Abelian   add-associative   right_zeroed  ;
</td><td><span data-href='prvect_3.html#FC6'>prvect_3</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM21436'>
<h2>24.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='prvect_3.html#K5'>prvect_3</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">G</font>, <font color="Maroon" title="c2">F</font> be   non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="RLVECT_1:struct.1" data-link="7510.html#ELM23286">RLSStruct</span> ;<br><div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K5"><span class="kw">func</span> </a><span class="p1"><span title="PRVECT_3:func.5" data-link="395.html#ELM21436">[:</span><span class="default"><font color="Maroon" title="c1">G</font>,<font color="Maroon" title="c2">F</font></span><span title="PRVECT_3:func.5" data-link="395.html#ELM21436">:]</span></span><span class="kw"> -&gt; </span>  non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="RLVECT_1:attr.1" data-href="rlvect_1.html#V1">strict</span>   <span title="RLVECT_1:struct.1" data-link="7510.html#ELM23286">RLSStruct</span> <span class="kw"> equals </span><a name="D5"><span class="comment"><font color="firebrick">:: PRVECT_3:def 5</font></span><br></a> <span title="RLVECT_1:aggr.1" data-href="rlvect_1.html#G1">RLSStruct</span>(# <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"> the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c1">G</font>, the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c2">F</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<span class="p1">(<span class="default"><span title="PRVECT_3:func.3" data-link="7045.html#ELM21434">prod_ZERO</span> (<font color="Maroon" title="c1">G</font>,<font color="Maroon" title="c2">F</font>)</span>)</span>,<span class="p1">(<span class="default"><span title="PRVECT_3:func.1" data-link="7043.html#ELM21432">prod_ADD</span> (<font color="Maroon" title="c1">G</font>,<font color="Maroon" title="c2">F</font>)</span>)</span>,<span class="p1">(<span class="default"><span title="PRVECT_3:func.2" data-link="7044.html#ELM21433">prod_MLT</span> (<font color="Maroon" title="c1">G</font>,<font color="Maroon" title="c2">F</font>)</span>)</span> #);<br>
</div>
<span class="kw">correctness </span><br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  Relation-like   the carrier of [:X,Y:] -defined   the carrier of (product <*X,Y*>) -valued   Function-like  V11() V14( the carrier of [:X,Y:])  quasi_total   bijective  V166([:X,Y:], product <*X,Y*>) V167([:X,Y:], product <*X,Y*>)  for    Element of K19(K20( the carrier of [:X,Y:], the carrier of (product <*X,Y*>)));
</td><td><span data-href='lopban12.html#RC1'>lopban12</span></td></tr>
<tr><td>
cluster f "  ->  bijective   for  LinearOperator of (product <*X,Y*>),[:X,Y:];
</td><td><span data-href='lopban12.html#FC3'>lopban12</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (product <*X,Y*>) -defined   the carrier of [:X,Y:] -valued   Function-like  V11() V14( the carrier of (product <*X,Y*>))  quasi_total   bijective  V166( product <*X,Y*>,[:X,Y:]) V167( product <*X,Y*>,[:X,Y:])  for    Element of K19(K20( the carrier of (product <*X,Y*>), the carrier of [:X,Y:]));
</td><td><span data-href='lopban12.html#RC2'>lopban12</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:E,F:] -defined   the carrier of G -valued   non  empty   Function-like   total   quasi_total   Bilinear   for    Element of  bool [: the carrier of [:E,F:], the carrier of G:];
</td><td><span data-href='lopban_8.html#RC2'>lopban_8</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   Abelian  ;
</td><td><span data-href='prvect_3.html#FC7'>prvect_3</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   add-associative  ;
</td><td><span data-href='prvect_3.html#FC8'>prvect_3</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   right_zeroed  ;
</td><td><span data-href='prvect_3.html#FC9'>prvect_3</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   right_complementable   strict  ;
</td><td><span data-href='prvect_3.html#FC10'>prvect_3</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   vector-distributive  ;
</td><td><span data-href='prvect_3.html#FC11'>prvect_3</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   scalar-distributive  ;
</td><td><span data-href='prvect_3.html#FC12'>prvect_3</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   scalar-associative  ;
</td><td><span data-href='prvect_3.html#FC13'>prvect_3</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   scalar-unital  ;
</td><td><span data-href='prvect_3.html#FC14'>prvect_3</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM21438'>
<h2>25.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='prvect_3.html#K7'>prvect_3</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">G</font>, <font color="Maroon" title="c2">F</font> be   non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="NORMSP_1:struct.1" data-link="6166.html#ELM18543">NORMSTR</span> ;<br><div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K7"><span class="kw">func</span> </a><span class="p1"><span title="PRVECT_3:func.7" data-link="395.html#ELM21438">[:</span><span class="default"><font color="Maroon" title="c1">G</font>,<font color="Maroon" title="c2">F</font></span><span title="PRVECT_3:func.7" data-link="395.html#ELM21438">:]</span></span><span class="kw"> -&gt; </span>  non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="NORMSP_1:attr.1" data-href="normsp_1.html#V1">strict</span>   <span title="NORMSP_1:struct.1" data-link="6166.html#ELM18543">NORMSTR</span> <span class="kw"> equals </span><a name="D7"><span class="comment"><font color="firebrick">:: PRVECT_3:def 7</font></span><br></a> <span title="NORMSP_1:aggr.1" data-href="normsp_1.html#G1">NORMSTR</span>(# <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"> the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c1">G</font>, the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c2">F</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<span class="p1">(<span class="default"><span title="PRVECT_3:func.3" data-link="7045.html#ELM21434">prod_ZERO</span> (<font color="Maroon" title="c1">G</font>,<font color="Maroon" title="c2">F</font>)</span>)</span>,<span class="p1">(<span class="default"><span title="PRVECT_3:func.1" data-link="7043.html#ELM21432">prod_ADD</span> (<font color="Maroon" title="c1">G</font>,<font color="Maroon" title="c2">F</font>)</span>)</span>,<span class="p1">(<span class="default"><span title="PRVECT_3:func.2" data-link="7044.html#ELM21433">prod_MLT</span> (<font color="Maroon" title="c1">G</font>,<font color="Maroon" title="c2">F</font>)</span>)</span>,<span class="p1">(<span class="default"><span title="PRVECT_3:func.6" data-link="7046.html#ELM21437">prod_NORM</span> (<font color="Maroon" title="c1">G</font>,<font color="Maroon" title="c2">F</font>)</span>)</span> #);<br>
</div>
<span class="kw">correctness </span><br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  Relation-like   the carrier of [:E,F:] -defined   the carrier of G -valued   non  empty   Function-like   total   quasi_total   Bilinear   for    Element of  bool [: the carrier of [:E,F:], the carrier of G:];
</td><td><span data-href='lopban_8.html#RC3'>lopban_8</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:X,Y:] -defined   the carrier of Z -valued   non  empty   Function-like  V28( the carrier of [:X,Y:])  quasi_total   Bilinear   Lipschitzian   for    Element of  bool [: the carrier of [:X,Y:], the carrier of Z:];
</td><td><span data-href='lopban_9.html#RC1'>lopban_9</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:X,Y:] -defined   the carrier of (product <*X,Y*>) -valued   non  empty   Function-like   one-to-one   total   quasi_total   onto  V152([:X,Y:], product <*X,Y*>) V153([:X,Y:], product <*X,Y*>)  isometric   for    Element of  bool [: the carrier of [:X,Y:], the carrier of (product <*X,Y*>):];
</td><td><span data-href='ndiff_7.html#RC1'>ndiff_7</span></td></tr>
<tr><td>
cluster f "  ->  one-to-one   onto   isometric   for  LinearOperator of (product <*X,Y*>),[:X,Y:];
</td><td><span data-href='ndiff_7.html#FC2'>ndiff_7</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (product <*X,Y*>) -defined   the carrier of [:X,Y:] -valued   non  empty   Function-like   one-to-one   total   quasi_total   onto  V152( product <*X,Y*>,[:X,Y:]) V153( product <*X,Y*>,[:X,Y:])  isometric   for    Element of  bool [: the carrier of (product <*X,Y*>), the carrier of [:X,Y:]:];
</td><td><span data-href='ndiff_7.html#RC2'>ndiff_7</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   discerning   reflexive   strict   RealNormSpace-like  ;
</td><td><span data-href='prvect_3.html#FC18'>prvect_3</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   right_complementable   Abelian   add-associative   right_zeroed   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   discerning   reflexive   strict   RealNormSpace-like  ;
</td><td><span data-href='prvect_3.html#FC19'>prvect_3</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  non  empty   strict   complete  ;
</td><td><span data-href='prvect_3.html#FC23'>prvect_3</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM28482'>
<h2>26.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='vectsp12.html#K9'>vectsp12</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">K</font> be   <span title="VECTSP_1:NM.3" data-link="8605.html#ELM28500">Ring</span>;<br><span class="kw">let </span><font color="Maroon" title="c2">G</font>, <font color="Maroon" title="c3">F</font> be   non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="VECTSP_1:struct.1" data-link="8602.html#ELM28497">ModuleStr</span> over <font color="Maroon" title="c1">K</font>;<br><div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K9"><span class="kw">func</span> </a><span class="p1"><span title="VECTSP12:func.9" data-link="395.html#ELM28482">[:</span><span class="default"><font color="Maroon" title="c2">G</font>,<font color="Maroon" title="c3">F</font></span><span title="VECTSP12:func.9" data-link="395.html#ELM28482">:]</span></span><span class="kw"> -&gt; </span>  non  <span title="STRUCT_0:attr.2" data-link="1570.html#ELM25771">empty</span>   <span title="VECTSP_1:attr.7" data-href="vectsp_1.html#V7">strict</span>   <span title="VECTSP_1:struct.1" data-link="8602.html#ELM28497">ModuleStr</span> over <font color="Maroon" title="c1">K</font><span class="kw"> equals </span><a name="D7"><span class="comment"><font color="firebrick">:: VECTSP12:def 7</font></span><br></a> <span title="VECTSP_1:aggr.1" data-href="vectsp_1.html#G1">ModuleStr</span>(# <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"> the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c2">G</font>, the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c3">F</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<span class="p1">(<span class="default"><span title="PRVECT_3:func.1" data-link="7043.html#ELM21432">prod_ADD</span> (<font color="Maroon" title="c2">G</font>,<font color="Maroon" title="c3">F</font>)</span>)</span>,<span class="p1">(<span class="default"><span title="PRVECT_3:func.3" data-link="7045.html#ELM21434">prod_ZERO</span> (<font color="Maroon" title="c2">G</font>,<font color="Maroon" title="c3">F</font>)</span>)</span>,<span class="p1">(<span class="default"><span title="VECTSP12:func.8" data-link="7044.html#ELM28481">prod_MLT</span> (<font color="Maroon" title="c2">G</font>,<font color="Maroon" title="c3">F</font>)</span>)</span> #);<br>
</div>
<span class="kw">correctness </span>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster [:G,F:] ->  non  empty   Abelian   strict  ;
</td><td><span data-href='vectsp12.html#FC3'>vectsp12</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   add-associative   strict  ;
</td><td><span data-href='vectsp12.html#FC4'>vectsp12</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   right_zeroed   strict  ;
</td><td><span data-href='vectsp12.html#FC5'>vectsp12</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   right_complementable   strict  ;
</td><td><span data-href='vectsp12.html#FC6'>vectsp12</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   vector-distributive  ;
</td><td><span data-href='vectsp12.html#FC7'>vectsp12</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   scalar-distributive  ;
</td><td><span data-href='vectsp12.html#FC8'>vectsp12</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   scalar-associative  ;
</td><td><span data-href='vectsp12.html#FC9'>vectsp12</span></td></tr>
<tr><td>
cluster [:G,F:] ->  non  empty   strict   scalar-unital  ;
</td><td><span data-href='vectsp12.html#FC10'>vectsp12</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM28845'>
<h2>27.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='waybel20.html#K1'>waybel20</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">L1</font>, <font color="Maroon" title="c2">L2</font>, <font color="Maroon" title="c3">T1</font>, <font color="Maroon" title="c4">T2</font> be    <span title="ORDERS_2:struct.1" data-link="6284.html#ELM18887">RelStr</span> ;<br><span class="kw">let </span><font color="Maroon" title="c5">f</font> be   <span title="STRUCT_0:NM.6" data-link="3155.html#ELM25752">Function</span> of <font color="Maroon" title="c1">L1</font>,<font color="Maroon" title="c3">T1</font>;<br><span class="kw">let </span><font color="Maroon" title="c6">g</font> be   <span title="STRUCT_0:NM.6" data-link="3155.html#ELM25752">Function</span> of <font color="Maroon" title="c2">L2</font>,<font color="Maroon" title="c4">T2</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="FUNCT_3:func.15" data-link="395.html#ELM8929">[:</span><br><span class="kw">redefine </span><a name="K1"><span class="kw">func</span> </a><span class="p1"><span title="WAYBEL20:func.1" data-link="395.html#ELM28845">[:</span><span class="default"><font color="Maroon" title="c5">f</font>,<font color="Maroon" title="c6">g</font></span><span title="WAYBEL20:func.1" data-link="395.html#ELM28845">:]</span></span><span class="kw"> -&gt; </span>  <span title="STRUCT_0:NM.6" data-link="3155.html#ELM25752">Function</span> of <span class="p1"><span title="YELLOW_3:func.3" data-link="395.html#ELM30274">[:</span><span class="default"><font color="Maroon" title="c1">L1</font>,<font color="Maroon" title="c2">L2</font></span><span title="YELLOW_3:func.3" data-link="395.html#ELM30274">:]</span></span>,<span class="p1"><span title="YELLOW_3:func.3" data-link="395.html#ELM30274">[:</span><span class="default"><font color="Maroon" title="c3">T1</font>,<font color="Maroon" title="c4">T2</font></span><span title="YELLOW_3:func.3" data-link="395.html#ELM30274">:]</span></span>;<br><span class="kw">coherence</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM30274'>
<h2>28.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='yellow_3.html#K3'>yellow_3</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X</font>, <font color="Maroon" title="c2">Y</font> be    <span title="ORDERS_2:struct.1" data-link="6284.html#ELM18887">RelStr</span> ;<br><div about="#D4" typeof="oo:Definition" class="main-sentence">
<a name="K3"><span class="kw">func</span> </a><span class="p1"><span title="YELLOW_3:func.3" data-link="395.html#ELM30274">[:</span><span class="default"><font color="Maroon" title="c1">X</font>,<font color="Maroon" title="c2">Y</font></span><span title="YELLOW_3:func.3" data-link="395.html#ELM30274">:]</span></span><span class="kw"> -&gt; </span>  <span title="ORDERS_2:attr.1" data-href="orders_2.html#V1">strict</span>   <span title="ORDERS_2:struct.1" data-link="6284.html#ELM18887">RelStr</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E4">Def2</font></span>: <a name="D2"><span class="comment"><font color="firebrick">:: YELLOW_3:def 2</font></span><br></a>(  the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <span class="kw">it</span> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"> the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c1">X</font>, the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c2">Y</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span> &amp;  the <span title="ORDERS_2:sel.1" data-href="orders_2.html#U1">InternalRel</span> of <span class="kw">it</span> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1"><span title="YELLOW_3:func.2" data-link="8919.html#ELM30273">["</span><span class="default"> the <span title="ORDERS_2:sel.1" data-href="orders_2.html#U1">InternalRel</span> of <font color="Maroon" title="c1">X</font>, the <span title="ORDERS_2:sel.1" data-href="orders_2.html#U1">InternalRel</span> of <font color="Maroon" title="c2">Y</font></span><span title="YELLOW_3:func.2" data-link="8919.html#ELM30273">"]</span></span> );<br>
</div>
<span class="kw">existence</span> <span class="kw">uniqueness</span> <br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster <:f1,f2:> ->  monotone   for  Function of P,[:Q1,Q2:];
</td><td><span data-href='poset_2.html#FC1'>poset_2</span></td></tr>
<tr><td>
cluster [:P,Q:] ->  chain-complete  ;
</td><td><span data-href='poset_2.html#FC2'>poset_2</span></td></tr>
<tr><td>
cluster <:f1,f2:> ->  continuous   for  Function of P,[:Q1,Q2:];
</td><td><span data-href='poset_2.html#FC3'>poset_2</span></td></tr>
<tr><td>
cluster  Proj (f,a) ->  monotone  ;
</td><td><span data-href='waybel24.html#FC2'>waybel24</span></td></tr>
<tr><td>
cluster  Proj (f,b) ->  monotone  ;
</td><td><span data-href='waybel24.html#FC3'>waybel24</span></td></tr>
<tr><td>
cluster  Proj (f,a) ->  antitone  ;
</td><td><span data-href='waybel24.html#FC4'>waybel24</span></td></tr>
<tr><td>
cluster  Proj (f,b) ->  antitone  ;
</td><td><span data-href='waybel24.html#FC5'>waybel24</span></td></tr>
<tr><td>
cluster [:S,T:] ->  up-complete  ;
</td><td><span data-href='waybel_2.html#FC3'>waybel_2</span></td></tr>
<tr><td>
cluster [:S,T:] ->  upper-bounded  ;
</td><td><span data-href='yellow10.html#FC1'>yellow10</span></td></tr>
<tr><td>
cluster [:S,T:] ->  lower-bounded  ;
</td><td><span data-href='yellow10.html#FC2'>yellow10</span></td></tr>
<tr><td>
cluster [:S,T:] ->  /\-complete  ;
</td><td><span data-href='yellow10.html#FC4'>yellow10</span></td></tr>
<tr><td>
cluster [:S,T:] ->  complemented  ;
</td><td><span data-href='yellow10.html#FC5'>yellow10</span></td></tr>
<tr><td>
cluster [:S,T:] ->  distributive  ;
</td><td><span data-href='yellow10.html#FC6'>yellow10</span></td></tr>
<tr><td>
cluster [:S,T:] ->  satisfying_MC  ;
</td><td><span data-href='yellow10.html#FC7'>yellow10</span></td></tr>
<tr><td>
cluster [:S,T:] ->  satisfying_axiom_of_approximation  ;
</td><td><span data-href='yellow10.html#FC8'>yellow10</span></td></tr>
<tr><td>
cluster [:S,T:] ->  continuous  ;
</td><td><span data-href='yellow10.html#FC9'>yellow10</span></td></tr>
<tr><td>
cluster [:S,T:] ->  satisfying_axiom_K  ;
</td><td><span data-href='yellow10.html#FC10'>yellow10</span></td></tr>
<tr><td>
cluster [:S,T:] ->  algebraic  ;
</td><td><span data-href='yellow10.html#FC11'>yellow10</span></td></tr>
<tr><td>
cluster [:S,T:] ->  arithmetic  ;
</td><td><span data-href='yellow10.html#FC12'>yellow10</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  non  empty   strict  ;
</td><td><span data-href='yellow_3.html#FC3'>yellow_3</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  strict   reflexive  ;
</td><td><span data-href='yellow_3.html#FC4'>yellow_3</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  strict   antisymmetric  ;
</td><td><span data-href='yellow_3.html#FC5'>yellow_3</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  strict   transitive  ;
</td><td><span data-href='yellow_3.html#FC6'>yellow_3</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  strict   with_suprema  ;
</td><td><span data-href='yellow_3.html#FC7'>yellow_3</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  strict   with_infima  ;
</td><td><span data-href='yellow_3.html#FC8'>yellow_3</span></td></tr>
<tr><td>
cluster [:D1,D2:] ->  directed   for  Subset of [:S1,S2:];
</td><td><span data-href='yellow_3.html#FC9'>yellow_3</span></td></tr>
<tr><td>
cluster [:D1,D2:] ->  filtered   for  Subset of [:S1,S2:];
</td><td><span data-href='yellow_3.html#FC10'>yellow_3</span></td></tr>
<tr><td>
cluster [:D1,D2:] ->  upper   for  Subset of [:S1,S2:];
</td><td><span data-href='yellow_3.html#FC11'>yellow_3</span></td></tr>
<tr><td>
cluster [:D1,D2:] ->  lower   for  Subset of [:S1,S2:];
</td><td><span data-href='yellow_3.html#FC12'>yellow_3</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  strict   complete  ;
</td><td><span data-href='yellow_3.html#FC14'>yellow_3</span></td></tr>
<tr><td>
cluster [:Y1,Y2:] ->  directed  ;
</td><td><span data-href='yellow_6.html#FC10'>yellow_6</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM30277'>
<h2>29.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='yellow_3.html#K6'>yellow_3</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">S1</font>, <font color="Maroon" title="c2">S2</font> be    <span title="ORDERS_2:struct.1" data-link="6284.html#ELM18887">RelStr</span> ;<br><span class="kw">let </span><font color="Maroon" title="c3">D1</font> be   <span title="STRUCT_0:NM.2" data-link="26.html#ELM25748">Subset</span> of <font color="Maroon" title="c1">S1</font>;<br><span class="kw">let </span><font color="Maroon" title="c4">D2</font> be   <span title="STRUCT_0:NM.2" data-link="26.html#ELM25748">Subset</span> of <font color="Maroon" title="c2">S2</font>;<br><span class="comment"><font color="firebrick">:: original: </font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><br><span class="kw">redefine </span><a name="K6"><span class="kw">func</span> </a><span class="p1"><span title="YELLOW_3:func.6" data-link="395.html#ELM30277">[:</span><span class="default"><font color="Maroon" title="c3">D1</font>,<font color="Maroon" title="c4">D2</font></span><span title="YELLOW_3:func.6" data-link="395.html#ELM30277">:]</span></span><span class="kw"> -&gt; </span>  <span title="STRUCT_0:NM.2" data-link="26.html#ELM25748">Subset</span> of <span class="p1"><span title="YELLOW_3:func.3" data-link="395.html#ELM30274">[:</span><span class="default"><font color="Maroon" title="c1">S1</font>,<font color="Maroon" title="c2">S2</font></span><span title="YELLOW_3:func.3" data-link="395.html#ELM30274">:]</span></span>;<br><span class="kw">coherence</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM30580'>
<h2>30.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='zfmisc_1.html#K2'>zfmisc_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X1</font>, <font color="Maroon" title="c2">X2</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">defpred </span><font color="Maroon">S<sub>1</sub></font>[   <span title="HIDDEN:mode.1" data-link="4140.html#ELM11935">object</span> ] <span class="kw">means </span> ex <font color="Olive" title="b1">x</font>, <font color="Olive" title="b2">y</font> being    <span title="HIDDEN:mode.1" data-link="4140.html#ELM11935">object</span>  st <br>( <font color="Olive" title="b1">x</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span> <font color="Maroon" title="c1">X1</font> &amp; <font color="Olive" title="b2">y</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span> <font color="Maroon" title="c2">X2</font> &amp; $1 <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1"><span title="TARSKI:func.4" data-link="802.html#ELM26068">[</span><span class="default"><font color="Olive" title="b1">x</font>,<font color="Olive" title="b2">y</font></span><span title="TARSKI:func.4" data-link="802.html#ELM26068">]</span></span> );<br><div about="#D5" typeof="oo:Definition" class="main-sentence">
<a name="K2"><span class="kw">func</span> </a><span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><font color="Maroon" title="c1">X1</font>,<font color="Maroon" title="c2">X2</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span><span class="kw"> -&gt; </span>   <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E5">Def2</font></span>: <a name="D2"><span class="comment"><font color="firebrick">:: ZFMISC_1:def 2</font></span><br></a> for <font color="Olive" title="b1">z</font> being    <span title="HIDDEN:mode.1" data-link="4140.html#ELM11935">object</span>  holds <br> ( <font color="Olive" title="b1">z</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span> <span class="kw">it</span> iff  ex <font color="Olive" title="b2">x</font>, <font color="Olive" title="b3">y</font> being    <span title="HIDDEN:mode.1" data-link="4140.html#ELM11935">object</span>  st <br>( <font color="Olive" title="b2">x</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span> <font color="Maroon" title="c1">X1</font> &amp; <font color="Olive" title="b3">y</font> <span title="HIDDEN:pred.2" data-link="4139.html#ELM11934">in</span> <font color="Maroon" title="c2">X2</font> &amp; <font color="Olive" title="b1">z</font> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <span class="p1"><span title="TARSKI:func.4" data-link="802.html#ELM26068">[</span><span class="default"><font color="Olive" title="b2">x</font>,<font color="Olive" title="b3">y</font></span><span title="TARSKI:func.4" data-link="802.html#ELM26068">]</span></span> ) );<br>
</div>
<span class="kw">existence</span> <span class="kw">uniqueness</span> </div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster  empty   Function-like   ->  irrelevant   for    Element of  bool [:Vars,(QuasiTerms C):];
</td><td><span data-href='abcmiz_1.html#CC12'>abcmiz_1</span></td></tr>
<tr><td>
cluster  empty   Relation-like   Vars  -defined   QuasiTerms C -valued   Function-like   Function-yielding  V119()  for    Element of  bool [:Vars,(QuasiTerms C):];
</td><td><span data-href='abcmiz_1.html#RC16'>abcmiz_1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty  A -defined  B -valued   Function-like  V35(A,B)  for    Element of  bool [:A,B:];
</td><td><span data-href='abian.html#RC8'>abian</span></td></tr>
<tr><td>
cluster  AffinStruct(# A,C #) ->  non  empty  ;
</td><td><span data-href='afvect01.html#FC1'>afvect01</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of R -valued   Function-like  V18( NAT , the carrier of R)  finite-Support   for    Element of K19(K20(NAT, the carrier of R));
</td><td><span data-href='algseq_1.html#RC1'>algseq_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of M -defined   the carrier of M -valued   total   quasi_total  V65() V70()  compatible   for    Element of  bool [: the carrier of M, the carrier of M:];
</td><td><span data-href='algstr_4.html#RC2'>algstr_4</span></td></tr>
<tr><td>
cluster  Function-like   constant  V21( the carrier of M, the carrier of M)  ->  contraction   for    Element of K10(K11( the carrier of M, the carrier of M));
</td><td><span data-href='ali2.html#CC1'>ali2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of M -defined   the carrier of M -valued   Function-like   constant  V17( the carrier of M) V21( the carrier of M, the carrier of M)  for    Element of K10(K11( the carrier of M, the carrier of M));
</td><td><span data-href='ali2.html#RC1'>ali2</span></td></tr>
<tr><td>
cluster  Relation-like  [:A,B:] -defined   Function-like  V14([:A,B:])  Function-yielding  V25()  compositional   for    set ;
</td><td><span data-href='altcat_1.html#RC4'>altcat_1</span></td></tr>
<tr><td>
cluster  AltCatStr(# X,A,C #) ->  non  empty  ;
</td><td><span data-href='altcat_1.html#FC1'>altcat_1</span></td></tr>
<tr><td>
cluster  ~ A -> [:I,I:] -defined  ;
</td><td><span data-href='altcat_2.html#FC3'>altcat_2</span></td></tr>
<tr><td>
cluster  ~ A -> [:I,I:] -defined   total   for [:I,I:] -defined  Function;
</td><td><span data-href='altcat_2.html#FC4'>altcat_2</span></td></tr>
<tr><td>
cluster  Relation-like  X *  -defined  X -valued   non  empty   Function-like   homogeneous   quasi_total  2 -ary   associative   unital   for    Element of  bool [:(X *),X:];
</td><td><span data-href='aofa_000.html#RC1'>aofa_000</span></td></tr>
<tr><td>
cluster  Relation-like  X *  -defined  X -valued   non  empty   Function-like   homogeneous   quasi_total   0  -ary   for    Element of  bool [:(X *),X:];
</td><td><span data-href='aofa_000.html#RC2'>aofa_000</span></td></tr>
<tr><td>
cluster  Relation-like  X *  -defined  X -valued   non  empty   Function-like   homogeneous   quasi_total  3 -ary   for    Element of  bool [:(X *),X:];
</td><td><span data-href='aofa_000.html#RC3'>aofa_000</span></td></tr>
<tr><td>
cluster [:A,B:] ->  disjoint_with_NAT  ;
</td><td><span data-href='aofa_000.html#FC6'>aofa_000</span></td></tr>
<tr><td>
cluster  Relation-like  A *  -defined  A -valued   Function-like   non  empty   homogeneous   quasi_total  n -ary   for    Element of  bool [:(A *),A:];
</td><td><span data-href='aofa_a00.html#RC20'>aofa_a00</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   card X -valued   Function-like   one-to-one   quasi_total   onto   for    Element of  bool [:X,(card X):];
</td><td><span data-href='aofa_i00.html#RC1'>aofa_i00</span></td></tr>
<tr><td>
cluster  Relation-like   card X -defined  X -valued   Function-like   one-to-one   quasi_total   onto   for    Element of  bool [:(card X),X:];
</td><td><span data-href='aofa_i00.html#RC2'>aofa_i00</span></td></tr>
<tr><td>
cluster  Relation-like  [:(Funcs (X,INT)), the carrier of A:] -defined   Funcs (X,INT) -valued   non  empty   Function-like  V31([:(Funcs (X,INT)), the carrier of A:])  quasi_total   Function-yielding  V93()  complying_with_empty-instruction   complying_with_catenation   Euclidean   for    ExecutionFunction of A, Funcs (X,INT),T;
</td><td><span data-href='aofa_i00.html#RC4'>aofa_i00</span></td></tr>
<tr><td>
cluster  Relation-like  [:(Union Q),Y:] -defined   Union Q -valued   Function-like   quasi_total   sort-preserving   for    Element of  bool [:[:(Union Q),Y:],(Union Q):];
</td><td><span data-href='aofa_l00.html#RC12'>aofa_l00</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool X -defined   bool X -valued   finite   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC4'>armstrng</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool X -defined   bool X -valued   (F2)   (F1)   (F3)   (F4)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC5'>armstrng</span></td></tr>
<tr><td>
cluster  Relation-like   bool X -defined   bool X -valued   full_family   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC6'>armstrng</span></td></tr>
<tr><td>
cluster  Relation-like   bool X -defined   bool X -valued   finite   countable   full_family   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC7'>armstrng</span></td></tr>
<tr><td>
cluster   ->  finite   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC1'>armstrng</span></td></tr>
<tr><td>
cluster  full_family   ->  (F2)   (F1)   (F3)   (F4)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC2'>armstrng</span></td></tr>
<tr><td>
cluster  (F2)   (F1)   (F3)   (F4)   ->  full_family   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC3'>armstrng</span></td></tr>
<tr><td>
cluster  (F1)   (F3)   ->  (DC3)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC4'>armstrng</span></td></tr>
<tr><td>
cluster  (F2)   (DC3)   ->  (F1)   (F3)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC5'>armstrng</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool X -defined   bool X -valued   (F2)   (F4)   (DC3)   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#RC8'>armstrng</span></td></tr>
<tr><td>
cluster  (F1)   ->  non  empty   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='armstrng.html#CC6'>armstrng</span></td></tr>
<tr><td>
cluster  Relation-like  A -defined  A -valued  V17(A)  reflexive   antisymmetric   connected   transitive   for    Element of  bool [:A,A:];
</td><td><span data-href='arrow.html#RC1'>arrow</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( REAL )  non  empty   Function-like  V28( NAT )  quasi_total  V39() V40() V41()  eventually-nonnegative   positive   eventually-positive   eventually-nonzero   eventually-nondecreasing   for    Element of K16(K17(NAT,REAL));
</td><td><span data-href='asympt_0.html#RC7'>asympt_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   positive   ->  eventually-positive   for    Element of K16(K17(NAT,REAL));
</td><td><span data-href='asympt_0.html#CC1'>asympt_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   eventually-positive   ->  eventually-nonnegative   eventually-nonzero   for    Element of K16(K17(NAT,REAL));
</td><td><span data-href='asympt_0.html#CC2'>asympt_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   eventually-nonnegative   eventually-nonzero   ->  eventually-positive   for    Element of K16(K17(NAT,REAL));
</td><td><span data-href='asympt_0.html#CC3'>asympt_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   polynomially-bounded   ->  polynomially-abs-bounded   for    Element of  bool [:omega,REAL:];
</td><td><span data-href='asympt_3.html#CC1'>asympt_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   non  empty   Function-like  V28( NAT )  quasi_total  V39() V40() V41()  polynomially-abs-bounded   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='asympt_3.html#RC3'>asympt_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   non  empty   Function-like  V28( NAT )  quasi_total  V39() V40() V41()  negligible   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='asympt_3.html#RC4'>asympt_3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   negligible   ->  polynomially-abs-bounded   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='asympt_3.html#CC2'>asympt_3</span></td></tr>
<tr><td>
cluster  Function-like  V28(I,J)  ->  total   for    Element of  bool [:I,J:];
</td><td><span data-href='bagord_2.html#CC1'>bagord_2</span></td></tr>
<tr><td>
cluster  Relation-like  I -defined  I -valued   asymmetric   transitive   for    Element of  bool [:I,I:];
</td><td><span data-href='bagord_2.html#RC2'>bagord_2</span></td></tr>
<tr><td>
cluster  Relation-like   Bags n -defined   Bags n -valued   total  V18( Bags n, Bags n)  reflexive   antisymmetric   transitive   admissible   for    Element of  bool [:(Bags n),(Bags n):];
</td><td><span data-href='bagorder.html#RC1'>bagorder</span></td></tr>
<tr><td>
cluster V4() V7( NAT ) V8( the carrier of F_Complex)  Function-like  V32( NAT , the carrier of F_Complex)  complex-valued   finite-Support   imaginary   for    Element of K21(K22(NAT, the carrier of F_Complex));
</td><td><span data-href='basel_2.html#RC2'>basel_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of X -defined   the carrier of X9 -valued   Function-like   non  empty  V14( the carrier of X)  quasi_total   multiplicative   for    Element of  bool [: the carrier of X, the carrier of X9:];
</td><td><span data-href='bcialg_6.html#RC1'>bcialg_6</span></td></tr>
<tr><td>
cluster  UNITSTR(# D,Z,a,m,s #) ->  non  empty  ;
</td><td><span data-href='bhsp_1.html#FC1'>bhsp_1</span></td></tr>
<tr><td>
cluster V12()  constant  V32( NAT , the carrier of X)  ->  convergent   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='bhsp_2.html#CC1'>bhsp_2</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the U1 of X) V6()  constant  V11() V14( NAT ) V18( NAT , the U1 of X)  for    Element of K19(K20(NAT, the U1 of X));
</td><td><span data-href='bhsp_3.html#RC1'>bhsp_3</span></td></tr>
<tr><td>
cluster V6()  constant  V18( NAT , the U1 of X)  ->  Cauchy   for    Element of K19(K20(NAT, the U1 of X));
</td><td><span data-href='bhsp_3.html#CC1'>bhsp_3</span></td></tr>
<tr><td>
cluster V6() V18( NAT , the U1 of X)  convergent   ->  Cauchy   for    Element of K19(K20(NAT, the U1 of X));
</td><td><span data-href='bhsp_3.html#CC2'>bhsp_3</span></td></tr>
<tr><td>
cluster V6()  constant  V18( NAT , the U1 of X)  ->  bounded   for    Element of K19(K20(NAT, the U1 of X));
</td><td><span data-href='bhsp_3.html#CC3'>bhsp_3</span></td></tr>
<tr><td>
cluster V6() V18( NAT , the U1 of X)  convergent   ->  bounded   for    Element of K19(K20(NAT, the U1 of X));
</td><td><span data-href='bhsp_3.html#CC4'>bhsp_3</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of W:]) V21([: the carrier of V, the carrier of W:], the carrier of K)  additiveFAF   additiveSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC1'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of W:]) V21([: the carrier of V, the carrier of W:], the carrier of K)  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC2'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of K -valued   Function-like   non  constant  V20([: the carrier of V, the carrier of W:]) V21([: the carrier of V, the carrier of W:], the carrier of K)  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC3'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of V:]) V21([: the carrier of V, the carrier of V:], the carrier of K)  symmetric   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC4'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of V:]) V21([: the carrier of V, the carrier of V:], the carrier of K)  alternating   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC5'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of V:]) V21([: the carrier of V, the carrier of V:], the carrier of K)  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   symmetric   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC6'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of V:]) V21([: the carrier of V, the carrier of V:], the carrier of K)  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   alternating   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC7'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   non  trivial   Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of K -valued   Function-like   non  constant  V20([: the carrier of V, the carrier of V:]) V21([: the carrier of V, the carrier of V:], the carrier of K)  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   symmetric   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC8'>bilinear</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of K -valued   Function-like  V20([: the carrier of V, the carrier of V:]) V21([: the carrier of V, the carrier of V:], the carrier of K)  additiveFAF   additiveSAF   alternating   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of K:];
</td><td><span data-href='bilinear.html#RC9'>bilinear</span></td></tr>
<tr><td>
cluster  Function-like  V18([:{},{}:], {} )  ->  empty   commutative   associative   for    Element of  bool [:[:{},{}:],{}:];
</td><td><span data-href='binop_1.html#CC1'>binop_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of T -defined   the carrier of T -valued   Function-like   one-to-one  V17( the carrier of T) V21( the carrier of T, the carrier of T)  continuous   for    Element of  bool [: the carrier of T, the carrier of T:];
</td><td><span data-href='borsuk_2.html#RC1'>borsuk_2</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  without_antipodals   for    Element of  bool [: the carrier of (Tcircle (p,r)), the carrier of (TOP-REAL n):];
</td><td><span data-href='borsuk_7.html#CC2'>borsuk_7</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   continuous   ->  with_antipodals   for    Element of  bool [: the carrier of (Tcircle (p,r)), the carrier of (TOP-REAL 2):];
</td><td><span data-href='borsuk_7.html#CC3'>borsuk_7</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  FinSequence-yielding   for    Element of K10(K11(X, the carrier of (TOP-REAL n)));
</td><td><span data-href='brouwer3.html#CC1'>brouwer3</span></td></tr>
<tr><td>
cluster [:A,B:] ->  infinite  ;
</td><td><span data-href='card_1.html#FC13'>card_1</span></td></tr>
<tr><td>
cluster [:B,A:] ->  infinite  ;
</td><td><span data-href='card_1.html#FC14'>card_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  non-empty   for    Element of  bool [:A,B:];
</td><td><span data-href='card_3.html#CC2'>card_3</span></td></tr>
<tr><td>
cluster [:NAT,NAT:] ->  countable  ;
</td><td><span data-href='cardfil4.html#FC1'>cardfil4</span></td></tr>
<tr><td>
cluster [:NAT,NAT:] ->  denumerable  ;
</td><td><span data-href='cardfil4.html#FC2'>cardfil4</span></td></tr>
<tr><td>
cluster  CatStr(# O,M,d,c,p #) ->  non  empty   non  void  ;
</td><td><span data-href='cat_2.html#FC2'>cat_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of C -defined   the carrier of D -valued   Function-like  V28( the carrier of C, the carrier of D)  identity-preserving   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC14'>cat_6</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   empty-yielding   the carrier of C -defined   the carrier of D -valued   empty   trivial   non  proper  V9() V10() V11() V13() V14() V15() V16() V17() V18()  Function-like   one-to-one   constant   functional   total  V28( the carrier of C, the carrier of D) V31() V35() V36() V39()  cardinal   0  -element  V43() V44() V45() V98() V99() V100() V101() V102() V105() V106() V107() V108() V109() V110() V111() V112()  identity-preserving   multiplicative   antimultiplicative   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC15'>cat_6</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of C -defined   the carrier of D -valued   Function-like   total  V28( the carrier of C, the carrier of D)  identity-preserving   multiplicative   antimultiplicative   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC16'>cat_6</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   empty-yielding   the carrier of C -defined   the carrier of D -valued   empty   trivial   non  proper  V9() V10() V11() V13() V14() V15() V16() V17() V18()  Function-like   one-to-one   constant   functional   total  V28( the carrier of C, the carrier of D) V31() V35() V36() V39()  cardinal   0  -element  V43() V44() V45() V98() V99() V100() V101() V102() V105() V106() V107() V108() V109() V110() V111() V112()  covariant   contravariant   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC17'>cat_6</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of C -defined   the carrier of D -valued   Function-like   total  V28( the carrier of C, the carrier of D)  covariant   contravariant   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC18'>cat_6</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  covariant   for    Element of  bool [: the carrier of C1, the carrier of C2:];
</td><td><span data-href='cat_8.html#CC1'>cat_8</span></td></tr>
<tr><td>
cluster  Relation-like  [:D,D:] -defined  D -valued   Function-like  V14([:D,D:]) V18([:D,D:],D)  commutative   associative   for    Element of  bool [:[:D,D:],D:];
</td><td><span data-href='cayldick.html#RC2'>cayldick</span></td></tr>
<tr><td>
cluster  ConjNormAlgStr(# D,m,a,M,O,Z,n,c #) ->  real-membered  ;
</td><td><span data-href='cayldick.html#FC7'>cayldick</span></td></tr>
<tr><td>
cluster  ConjNormAlgStr(# D,m,a,M,O,Z,n,c #) ->  add-associative  ;
</td><td><span data-href='cayldick.html#FC8'>cayldick</span></td></tr>
<tr><td>
cluster  ConjNormAlgStr(# D,m,a,M,O,Z,n,c #) ->  Abelian  ;
</td><td><span data-href='cayldick.html#FC9'>cayldick</span></td></tr>
<tr><td>
cluster  ConjNormAlgStr(# D,m,a,M,O,Z,n,c #) ->  associative  ;
</td><td><span data-href='cayldick.html#FC10'>cayldick</span></td></tr>
<tr><td>
cluster  ConjNormAlgStr(# D,m,a,M,O,Z,n,c #) ->  commutative  ;
</td><td><span data-href='cayldick.html#FC11'>cayldick</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of X -defined   COMPLEX  -valued   non  empty   Function-like   total   quasi_total  V172()  continuous   for    Element of  bool [: the carrier of X,COMPLEX:];
</td><td><span data-href='cc0sp2.html#RC1'>cc0sp2</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( COMPLEX )  Function-like  V11()  total   non-zero   quasi_total   complex-valued   0  -convergent   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='cfdiff_1.html#RC1'>cfdiff_1</span></td></tr>
<tr><td>
cluster  Function-like   non-zero   quasi_total   0  -convergent   ->  convergent   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='cfdiff_1.html#CC1'>cfdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( COMPLEX )  Function-like   constant  V11()  total   quasi_total   complex-valued   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='cfdiff_1.html#RC2'>cfdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( COMPLEX ) V5( COMPLEX )  Function-like   total   complex-valued   RestFunc-like   for    Element of K19(K20(COMPLEX,COMPLEX));
</td><td><span data-href='cfdiff_1.html#RC3'>cfdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( COMPLEX ) V5( COMPLEX )  Function-like   total   complex-valued   linear   for    Element of K19(K20(COMPLEX,COMPLEX));
</td><td><span data-href='cfdiff_1.html#RC4'>cfdiff_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of X -defined   the carrier of Y -valued   Function-like   total   quasi_total   additive   homogeneous   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='clopban1.html#RC1'>clopban1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of X -defined   the carrier of Y -valued   Function-like   total   quasi_total   additive   homogeneous   Lipschitzian   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='clopban1.html#RC2'>clopban1</span></td></tr>
<tr><td>
cluster V4()  Relation-like   NAT  -defined   the carrier of X -valued   Function-like  V32( NAT ) V33( NAT , the carrier of X)  summable   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='clopban3.html#RC1'>clopban3</span></td></tr>
<tr><td>
cluster V4()  Relation-like   NAT  -defined   the carrier of X -valued   Function-like  V32( NAT ) V33( NAT , the carrier of X)  norm_summable   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='clopban3.html#RC2'>clopban3</span></td></tr>
<tr><td>
cluster  Function-like  V33( NAT , the carrier of X)  summable   ->  convergent   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='clopban3.html#CC1'>clopban3</span></td></tr>
<tr><td>
cluster  Function-like  V33( NAT , the carrier of X)  norm_summable   ->  summable   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='clopban3.html#CC2'>clopban3</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   Function-like  V17( Bool M)  quasi_total   reflexive   monotonic   idempotent   topological   for    Element of  bool [:(Bool M),(Bool M):];
</td><td><span data-href='closure2.html#RC4'>closure2</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   topological   ->  monotonic   for    Element of  bool [:(Bool M),(Bool M):];
</td><td><span data-href='closure2.html#CC7'>closure2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   Bool M -defined   Bool M -valued   Function-like  V17( Bool M)  quasi_total   reflexive   monotonic   idempotent   algebraic   for    Element of  bool [:(Bool M),(Bool M):];
</td><td><span data-href='closure3.html#RC1'>closure3</span></td></tr>
<tr><td>
cluster  CLSStruct(# ZS,O,F,G #) ->  non  empty  ;
</td><td><span data-href='clvect_1.html#FC1'>clvect_1</span></td></tr>
<tr><td>
cluster  Relation-like  C1 -defined  C2 -valued   Function-like  V36(C1,C2)  union-distributive   cap-distributive   for    Element of  bool [:C1,C2:];
</td><td><span data-href='cohsp_1.html#RC7'>cohsp_1</span></td></tr>
<tr><td>
cluster  Relation-like  B -defined  C -valued   Function-like  V36(B,C)  U-linear   for    Element of  bool [:B,C:];
</td><td><span data-href='cohsp_1.html#RC11'>cohsp_1</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of X, the carrier of Y)  compactification   ->  embedding   for    Element of K19(K20( the carrier of X, the carrier of Y));
</td><td><span data-href='compact1.html#CC10'>compact1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of M -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of M)  pointwise_bounded   for    Element of  bool [:omega,(bool  the carrier of M):];
</td><td><span data-href='compl_sp.html#RC1'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  open   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC4'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  closed   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC5'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  open   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC6'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of T -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of T)  closed   for    Element of  bool [:omega,(bool  the carrier of T):];
</td><td><span data-href='compl_sp.html#RC7'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of M -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of M)  pointwise_bounded   open   for    Element of  bool [:omega,(bool  the carrier of M):];
</td><td><span data-href='compl_sp.html#RC8'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined   bool  the carrier of M -valued   non  empty   Function-like   total  V29( omega , bool  the carrier of M)  pointwise_bounded   closed   for    Element of  bool [:omega,(bool  the carrier of M):];
</td><td><span data-href='compl_sp.html#RC9'>compl_sp</span></td></tr>
<tr><td>
cluster  Relation-like  X *  -defined  Y -valued   Function-like   homogeneous   for    Element of K32(K33((X *),Y));
</td><td><span data-href='comput_1.html#RC5'>comput_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  X *  -defined  Y -valued   Function-like   homogeneous   for    Element of K32(K33((X *),Y));
</td><td><span data-href='comput_1.html#RC6'>comput_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  X *  -defined  X -valued   Function-like   homogeneous   quasi_total   for    Element of K32(K33((X *),X));
</td><td><span data-href='comput_1.html#RC7'>comput_1</span></td></tr>
<tr><td>
cluster  Function-like   -> NAT *  -defined   to-naturals   for    Element of K32(K33((NAT *),NAT));
</td><td><span data-href='comput_1.html#CC3'>comput_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  len-total   for    Element of K32(K33((NAT *),NAT));
</td><td><span data-href='comput_1.html#CC4'>comput_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   COMPLEX  -valued   Function-like   non  empty  V14( NAT ) V18( NAT , COMPLEX )  non-zero  V44()  for    Element of  bool [:NAT,COMPLEX:];
</td><td><span data-href='comseq_1.html#RC1'>comseq_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   COMPLEX  -valued   Function-like   non  empty   total  V18( NAT , COMPLEX )  complex-valued   bounded   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='comseq_2.html#RC1'>comseq_2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   COMPLEX  -valued   Function-like   non  empty   total  V18( NAT , COMPLEX )  complex-valued   convergent   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='comseq_2.html#RC2'>comseq_2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , COMPLEX )  convergent   ->  bounded   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='comseq_2.html#CC1'>comseq_2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , COMPLEX )  non  bounded   ->  non  convergent   for    Element of K19(K20(NAT,COMPLEX));
</td><td><span data-href='comseq_2.html#CC2'>comseq_2</span></td></tr>
<tr><td>
cluster  Function-like  V19( NAT , REAL )  summable   ->  convergent   for    Element of K20(K21(NAT,REAL));
</td><td><span data-href='comseq_3.html#CC1'>comseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V19( NAT , REAL )  absolutely_summable   ->  summable   for    Element of K20(K21(NAT,REAL));
</td><td><span data-href='comseq_3.html#CC2'>comseq_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like  V12()  total  V19( NAT , REAL )  complex-valued   ext-real-valued   real-valued   absolutely_summable   for    Element of K20(K21(NAT,REAL));
</td><td><span data-href='comseq_3.html#RC1'>comseq_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   COMPLEX  -valued   Function-like  V12()  total  V19( NAT , COMPLEX )  complex-valued   summable   for    Element of K20(K21(NAT,COMPLEX));
</td><td><span data-href='comseq_3.html#RC2'>comseq_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   COMPLEX  -valued   Function-like  V12()  total  V19( NAT , COMPLEX )  complex-valued   absolutely_summable   for    Element of K20(K21(NAT,COMPLEX));
</td><td><span data-href='comseq_3.html#RC3'>comseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V19( NAT , COMPLEX )  summable   ->  convergent   for    Element of K20(K21(NAT,COMPLEX));
</td><td><span data-href='comseq_3.html#CC3'>comseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V19( NAT , COMPLEX )  absolutely_summable   ->  summable   for    Element of K20(K21(NAT,COMPLEX));
</td><td><span data-href='comseq_3.html#CC4'>comseq_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   COMPLEX  -valued   Function-like  V12()  total  V19( NAT , COMPLEX )  complex-valued   absolutely_summable   for    Element of K20(K21(NAT,COMPLEX));
</td><td><span data-href='comseq_3.html#RC4'>comseq_3</span></td></tr>
<tr><td>
cluster V1() V4(I) V5( REAL )  Function-like   non  empty   total  V55(I, REAL )  complex-valued   ext-real-valued   real-valued   HK-integrable   for    Element of  bool [:I,REAL:];
</td><td><span data-href='cousin2.html#RC1'>cousin2</span></td></tr>
<tr><td>
cluster V1() V4(I) V5( REAL )  Function-like   non  empty   total  V55(I, REAL )  complex-valued   ext-real-valued   real-valued   integrable   for    Element of  bool [:I,REAL:];
</td><td><span data-href='cousin2.html#RC2'>cousin2</span></td></tr>
<tr><td>
cluster V1() V4(X) V5( REAL )  Function-like   non  empty   total  V55(X, REAL )  complex-valued   ext-real-valued   real-valued   bounded   for    Element of  bool [:X,REAL:];
</td><td><span data-href='cousin2.html#RC3'>cousin2</span></td></tr>
<tr><td>
cluster V1() V4(I) V5( REAL )  Function-like   non  empty   total  V55(I, REAL )  complex-valued   ext-real-valued   real-valued   bounded   integrable   for    Element of  bool [:I,REAL:];
</td><td><span data-href='cousin2.html#RC4'>cousin2</span></td></tr>
<tr><td>
cluster  Function-like  V55(I, REAL )  bounded   integrable   ->  HK-integrable   for    Element of  bool [:I,REAL:];
</td><td><span data-href='cousin2.html#CC1'>cousin2</span></td></tr>
<tr><td>
cluster  CUNITSTR(# D,Z,a,m,s #) ->  non  empty  ;
</td><td><span data-href='csspace.html#FC4'>csspace</span></td></tr>
<tr><td>
cluster  CNORMSTR(# X,Z,A,M,N #) ->  non  empty  ;
</td><td><span data-href='csspace3.html#FC4'>csspace3</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   the carrier of Y -valued   non  empty   Function-like  V26(X)  quasi_total   bounded   for    Element of  bool [:X, the carrier of Y:];
</td><td><span data-href='csspace4.html#RC1'>csspace4</span></td></tr>
<tr><td>
cluster  Function-like  V32([:NAT,NAT:], REAL )  P-convergent   non-decreasing   ->  bounded_above   bounded_below   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#CC1'>dblseq_1</span></td></tr>
<tr><td>
cluster  Function-like  V32([:NAT,NAT:], REAL )  P-convergent   non-increasing   ->  bounded_above   bounded_below   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#CC2'>dblseq_1</span></td></tr>
<tr><td>
cluster [:NAT,NAT:] --> r ->  P-convergent   convergent_in_cod1   convergent_in_cod2   for  Function of [:NAT,NAT:],REAL;
</td><td><span data-href='dblseq_1.html#FC1'>dblseq_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [:NAT,NAT:] -defined   REAL  -valued   Function-like  V28([:NAT,NAT:]) V32([:NAT,NAT:], REAL ) V109() V110() V111()  P-convergent   convergent_in_cod1   convergent_in_cod2   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#RC1'>dblseq_1</span></td></tr>
<tr><td>
cluster  lim_in_cod2 Pseq2 ->  convergent  ;
</td><td><span data-href='dblseq_1.html#FC2'>dblseq_1</span></td></tr>
<tr><td>
cluster  lim_in_cod1 Pseq1 ->  convergent  ;
</td><td><span data-href='dblseq_1.html#FC3'>dblseq_1</span></td></tr>
<tr><td>
cluster  Function-like  V32([:NAT,NAT:], REAL )  bounded_above   non-decreasing   ->  P-convergent   convergent_in_cod1   convergent_in_cod2   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#CC3'>dblseq_1</span></td></tr>
<tr><td>
cluster  Function-like  V32([:NAT,NAT:], REAL )  bounded_below   non-increasing   ->  P-convergent   convergent_in_cod1   convergent_in_cod2   for    Element of  bool [:[:NAT,NAT:],REAL:];
</td><td><span data-href='dblseq_1.html#CC4'>dblseq_1</span></td></tr>
<tr><td>
cluster   ->  P-convergent   for    subsequence of Pseq;
</td><td><span data-href='dblseq_1.html#CC5'>dblseq_1</span></td></tr>
<tr><td>
cluster   ->  convergent_in_cod1   for    subsequence of Rseq;
</td><td><span data-href='dblseq_1.html#CC6'>dblseq_1</span></td></tr>
<tr><td>
cluster   ->  convergent_in_cod2   for    subsequence of Rseq;
</td><td><span data-href='dblseq_1.html#CC7'>dblseq_1</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10(X) V11( REAL )  Function-like   total  V32(X, REAL )  complex-valued   ext-real-valued   real-valued   nonnegative   nonpositive   for    Element of  bool [:X,REAL:];
</td><td><span data-href='dblseq_3.html#RC1'>dblseq_3</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10(X) V11( ExtREAL )  Function-like   total  V32(X, ExtREAL )  ext-real-valued   nonnegative   nonpositive  V183() V184()  for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='dblseq_3.html#RC2'>dblseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V32(X, ExtREAL )  nonnegative   -> V183()  for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='dblseq_3.html#CC1'>dblseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V32(X, ExtREAL )  nonpositive   -> V184()  for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='dblseq_3.html#CC2'>dblseq_3</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10(X) V11( ExtREAL )  Function-like   total  V32(X, ExtREAL )  ext-real-valued  V183() V184()  for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='dblseq_3.html#RC3'>dblseq_3</span></td></tr>
<tr><td>
cluster  ~ f ->  without-infty  ;
</td><td><span data-href='dblseq_3.html#FC5'>dblseq_3</span></td></tr>
<tr><td>
cluster  ~ f ->  without+infty  ;
</td><td><span data-href='dblseq_3.html#FC6'>dblseq_3</span></td></tr>
<tr><td>
cluster  ~ f ->  nonnegative  ;
</td><td><span data-href='dblseq_3.html#FC7'>dblseq_3</span></td></tr>
<tr><td>
cluster  ~ f ->  nonpositive  ;
</td><td><span data-href='dblseq_3.html#FC8'>dblseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V32( omega , ExtREAL )  convergent_to_+infty   ->  convergent   for    Element of  bool [:omega,ExtREAL:];
</td><td><span data-href='dblseq_3.html#CC3'>dblseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V32( omega , ExtREAL )  convergent_to_-infty   ->  convergent   for    Element of  bool [:omega,ExtREAL:];
</td><td><span data-href='dblseq_3.html#CC4'>dblseq_3</span></td></tr>
<tr><td>
cluster  Function-like  V32( omega , ExtREAL )  convergent_to_finite_number   ->  convergent   for    Element of  bool [:omega,ExtREAL:];
</td><td><span data-href='dblseq_3.html#CC5'>dblseq_3</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( omega ) V11( ExtREAL )  Function-like   total  V32( omega , ExtREAL )  ext-real-valued   convergent   for    Element of  bool [:omega,ExtREAL:];
</td><td><span data-href='dblseq_3.html#RC4'>dblseq_3</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( omega ) V11( ExtREAL )  Function-like   total  V32( omega , ExtREAL )  ext-real-valued  V183()  convergent   for    Element of  bool [:omega,ExtREAL:];
</td><td><span data-href='dblseq_3.html#RC5'>dblseq_3</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( omega ) V11( ExtREAL )  Function-like   total  V32( omega , ExtREAL )  ext-real-valued  V184()  convergent   for    Element of  bool [:omega,ExtREAL:];
</td><td><span data-href='dblseq_3.html#RC6'>dblseq_3</span></td></tr>
<tr><td>
cluster  ProjMap1 (F,x) -> V184() ;
</td><td><span data-href='dblseq_3.html#FC11'>dblseq_3</span></td></tr>
<tr><td>
cluster  ProjMap2 (F,y) -> V184() ;
</td><td><span data-href='dblseq_3.html#FC12'>dblseq_3</span></td></tr>
<tr><td>
cluster  ProjMap1 (F,x) -> V183() ;
</td><td><span data-href='dblseq_3.html#FC13'>dblseq_3</span></td></tr>
<tr><td>
cluster  ProjMap2 (F,y) -> V183() ;
</td><td><span data-href='dblseq_3.html#FC14'>dblseq_3</span></td></tr>
<tr><td>
cluster  Partial_Sums_in_cod2 f -> V183() ;
</td><td><span data-href='dblseq_3.html#FC15'>dblseq_3</span></td></tr>
<tr><td>
cluster  Partial_Sums_in_cod2 f -> V184() ;
</td><td><span data-href='dblseq_3.html#FC16'>dblseq_3</span></td></tr>
<tr><td>
cluster  Partial_Sums_in_cod2 f ->  nonnegative   for  Function of [:NAT,NAT:],ExtREAL;
</td><td><span data-href='dblseq_3.html#FC17'>dblseq_3</span></td></tr>
<tr><td>
cluster  Partial_Sums_in_cod2 f ->  nonpositive   for  Function of [:NAT,NAT:],ExtREAL;
</td><td><span data-href='dblseq_3.html#FC18'>dblseq_3</span></td></tr>
<tr><td>
cluster  Partial_Sums_in_cod1 f -> V183() ;
</td><td><span data-href='dblseq_3.html#FC19'>dblseq_3</span></td></tr>
<tr><td>
cluster  Partial_Sums_in_cod1 f -> V184() ;
</td><td><span data-href='dblseq_3.html#FC20'>dblseq_3</span></td></tr>
<tr><td>
cluster  Partial_Sums_in_cod1 f ->  nonnegative   for  Function of [:NAT,NAT:],ExtREAL;
</td><td><span data-href='dblseq_3.html#FC21'>dblseq_3</span></td></tr>
<tr><td>
cluster  Partial_Sums_in_cod1 f ->  nonpositive   for  Function of [:NAT,NAT:],ExtREAL;
</td><td><span data-href='dblseq_3.html#FC22'>dblseq_3</span></td></tr>
<tr><td>
cluster  ProjMap1 (f,n) ->  nonnegative  ;
</td><td><span data-href='dblseq_3.html#FC23'>dblseq_3</span></td></tr>
<tr><td>
cluster  ProjMap2 (f,n) ->  nonnegative  ;
</td><td><span data-href='dblseq_3.html#FC24'>dblseq_3</span></td></tr>
<tr><td>
cluster  ProjMap1 ((Partial_Sums_in_cod2 f),m) ->  non-decreasing  ;
</td><td><span data-href='dblseq_3.html#FC25'>dblseq_3</span></td></tr>
<tr><td>
cluster  ProjMap2 ((Partial_Sums_in_cod1 f),m) ->  non-decreasing  ;
</td><td><span data-href='dblseq_3.html#FC26'>dblseq_3</span></td></tr>
<tr><td>
cluster V1() V4( Segm n) V5( Seg n)  Function-like   non  empty   total   quasi_total  V49() V50() V51() V52()  NtoSEG   for    Element of  bool [:(Segm n),(Seg n):];
</td><td><span data-href='descip_1.html#RC1'>descip_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   NtoSEG   ->  bijective   NtoSEG   for    Element of  bool [:(Segm n),(Seg n):];
</td><td><span data-href='descip_1.html#CC2'>descip_1</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( PFuncs (REAL,REAL))  non  empty   Function-like   total   quasi_total   Sequence-yielding   for    Element of  bool [:NAT,(PFuncs (REAL,REAL)):];
</td><td><span data-href='diff_1.html#RC1'>diff_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of X -defined   REAL  -valued   non  empty   Function-like  V25( the carrier of X)  quasi_total  V156() V157() V158()  subadditive   additive   homogeneous   positively_homogeneous   Lipschitzian   for    Element of  bool [: the carrier of X,REAL:];
</td><td><span data-href='dualsp01.html#RC1'>dualsp01</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of X) V5( REAL )  non  empty   Function-like   total   quasi_total   additive   homogeneous  V166() V167() V168()  Lipschitzian   for    Element of  bool [: the carrier of X,REAL:];
</td><td><span data-href='dualsp04.html#RC1'>dualsp04</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of G -defined   the carrier of H -valued   Function-like   non  empty  V14( the carrier of G)  quasi_total   unity-preserving   multiplicative   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='endalg.html#RC2'>endalg</span></td></tr>
<tr><td>
cluster  Function-like  V8()  ->  continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC1'>fcont_1</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL  -valued   Function-like   complex-valued   ext-real-valued   real-valued   continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#RC1'>fcont_1</span></td></tr>
<tr><td>
cluster  Function-like   empty   ->  continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC2'>fcont_1</span></td></tr>
<tr><td>
cluster  Function-like   empty   ->  Lipschitzian   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC3'>fcont_1</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL  -valued   Function-like   empty   complex-valued   ext-real-valued   real-valued   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#RC2'>fcont_1</span></td></tr>
<tr><td>
cluster  Function-like  V8()  ->  Lipschitzian   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC4'>fcont_1</span></td></tr>
<tr><td>
cluster  Function-like   Lipschitzian   ->  continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#CC5'>fcont_1</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL  -valued   Function-like   non  empty   total   quasi_total   complex-valued   ext-real-valued   real-valued   continuous   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='fcont_1.html#RC3'>fcont_1</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( REAL )  Function-like   non  empty   total   non-zero   quasi_total   complex-valued   ext-real-valued   real-valued   0  -convergent   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='fdiff_1.html#RC1'>fdiff_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   0  -convergent   ->  convergent   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='fdiff_1.html#CC1'>fdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL )  Function-like   complex-valued   ext-real-valued   real-valued   RestFunc-like   for    Element of K19(K20(REAL,REAL));
</td><td><span data-href='fdiff_1.html#RC2'>fdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL )  Function-like   complex-valued   ext-real-valued   real-valued   linear   for    Element of K19(K20(REAL,REAL));
</td><td><span data-href='fdiff_1.html#RC3'>fdiff_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL )  Function-like   non  empty   total   quasi_total   complex-valued   ext-real-valued   real-valued   differentiable   for    Element of K19(K20(REAL,REAL));
</td><td><span data-href='fdiff_1.html#RC4'>fdiff_1</span></td></tr>
<tr><td>
cluster V1() V4(Omega1) V5(Omega2)  non  empty   Function-like  V28(Omega1) V32(Omega1,Omega2) S1,S2 -random_variable-like   for    Element of  Trivial-SigmaField K17(Omega1,Omega2);
</td><td><span data-href='finance1.html#RC1'>finance1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  Omega -defined   StoppingSetExt T -valued   Function-like   total  V34(Omega, StoppingSetExt T)  ext-real-valued  MyFunc -StoppingTime-like   for    Element of K10(K11(Omega,(StoppingSetExt T)));
</td><td><span data-href='finance5.html#RC1'>finance5</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  Omega -defined  I -valued   Function-like   total  V34(Omega,I)  complex-valued   ext-real-valued   real-valued  Sigma, BorelSubsets I -random_variable-like  MyFunc -StoppingTime-like   for    Element of K10(K11(Omega,I));
</td><td><span data-href='finance5.html#RC2'>finance5</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  Omega -defined  [.0,+infty.] -valued   Function-like   total  V34(Omega,[.0,+infty.])  ext-real-valued  Sigma, ExtBorelsubsets  -random_variable-like  MyFunc -StoppingTime-like   for    Element of K10(K11(Omega,[.0,+infty.]));
</td><td><span data-href='finance5.html#RC3'>finance5</span></td></tr>
<tr><td>
cluster  Relation-like  Omega -defined   REAL  -valued   Function-like   non  empty  V14(Omega) V18(Omega, REAL ) V39() V40() V41() F, Borel_Sets  -random_variable-like   for    Element of  Trivial-SigmaField K20(Omega,REAL);
</td><td><span data-href='finance6.html#RC1'>finance6</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like   FinSequence-like   for    Element of  bool [:NAT,D:];
</td><td><span data-href='finseq_1.html#RC1'>finseq_1</span></td></tr>
<tr><td>
cluster [:A,B:] ->  finite  ;
</td><td><span data-href='finset_1.html#FC14'>finset_1</span></td></tr>
<tr><td>
cluster  Function-like  V18(A,B)  ->  finite   for    Element of  bool [:A,B:];
</td><td><span data-href='finset_1.html#CC3'>finset_1</span></td></tr>
<tr><td>
cluster  Relation-like  [:D,D:] -defined  D -valued   Function-like   total   quasi_total   associative   for    Element of  bool [:[:D,D:],D:];
</td><td><span data-href='fomodel0.html#RC1'>fomodel0</span></td></tr>
<tr><td>
cluster <:f,g:> -> [:X,Y:] -valued   for  Function;
</td><td><span data-href='fomodel0.html#FC18'>fomodel0</span></td></tr>
<tr><td>
cluster  quasi_total   ->  total   for    Element of  bool [:A,U:];
</td><td><span data-href='fomodel0.html#CC5'>fomodel0</span></td></tr>
<tr><td>
cluster P \ [:(dom P),(rng P):] ->  empty  ;
</td><td><span data-href='fomodel0.html#FC30'>fomodel0</span></td></tr>
<tr><td>
cluster  Relation-like  U -defined  U -valued   total   reflexive   for    Element of  bool [:U,U:];
</td><td><span data-href='fomodel0.html#RC9'>fomodel0</span></td></tr>
<tr><td>
cluster (proj1 [:X,Y:]) \ X ->  empty  ;
</td><td><span data-href='fomodel0.html#FC106'>fomodel0</span></td></tr>
<tr><td>
cluster ((proj1 [:X,Y:]) /\ X) \+\ (proj1 [:X,Y:]) ->  empty  ;
</td><td><span data-href='fomodel0.html#FC107'>fomodel0</span></td></tr>
<tr><td>
cluster (proj2 [:X,Y:]) \ Y ->  empty  ;
</td><td><span data-href='fomodel0.html#FC108'>fomodel0</span></td></tr>
<tr><td>
cluster ((proj2 [:X,Y:]) /\ Y) \+\ (proj2 [:X,Y:]) ->  empty  ;
</td><td><span data-href='fomodel0.html#FC109'>fomodel0</span></td></tr>
<tr><td>
cluster (proj1 [:X,U:]) \+\ X ->  empty  ;
</td><td><span data-href='fomodel0.html#FC113'>fomodel0</span></td></tr>
<tr><td>
cluster (proj2 [:U,X:]) \+\ X ->  empty  ;
</td><td><span data-href='fomodel0.html#FC114'>fomodel0</span></td></tr>
<tr><td>
cluster [:A,B:] \ [:(A \/ X),(B \/ Y):] ->  empty  ;
</td><td><span data-href='fomodel0.html#FC116'>fomodel0</span></td></tr>
<tr><td>
cluster [:X,Y:] -> Y -valued  ;
</td><td><span data-href='fomodel0.html#FC120'>fomodel0</span></td></tr>
<tr><td>
cluster [:{x},{y}:] +* [:{y},{x}:] ->  symmetric  ;
</td><td><span data-href='fomodel0.html#FC121'>fomodel0</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   Function-like   one-to-one   non  empty   total   quasi_total   onto   bijective   symmetric   with_fixpoint   oneone   for    Element of  bool [:X,X:];
</td><td><span data-href='fomodel0.html#RC18'>fomodel0</span></td></tr>
<tr><td>
cluster [:X,Y:] >*> [:Y,x:] ->  Function-like  ;
</td><td><span data-href='fomodel0.html#FC139'>fomodel0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  Function-yielding   for    Element of  bool [:X,(Funcs (Y,Z)):];
</td><td><span data-href='fomodel2.html#CC5'>fomodel2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  X -defined   Funcs (Y,Z) -valued   Function-like   total   quasi_total   Function-yielding  V171()  for    Element of  bool [:X,(Funcs (Y,Z)):];
</td><td><span data-href='fomodel2.html#RC2'>fomodel2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  X -defined  Y -valued   Function-like   total   quasi_total  E,F -respecting   for    Element of  bool [:X,Y:];
</td><td><span data-href='fomodel3.html#RC1'>fomodel3</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  Y -valued   onto   for    Element of  bool [:X,Y:];
</td><td><span data-href='fomodel3.html#RC4'>fomodel3</span></td></tr>
<tr><td>
cluster  FSM(# X,T,I #) ->  non  empty   finite  ;
</td><td><span data-href='fsm_1.html#FC1'>fsm_1</span></td></tr>
<tr><td>
cluster  Mealy-FSM(# X,T,O,I #) ->  non  empty   finite  ;
</td><td><span data-href='fsm_1.html#FC2'>fsm_1</span></td></tr>
<tr><td>
cluster  Moore-FSM(# X,T,O,I #) ->  non  empty   finite  ;
</td><td><span data-href='fsm_1.html#FC3'>fsm_1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  Y -valued   Function-like   constant   total   quasi_total   for    Element of  bool [:X,Y:];
</td><td><span data-href='funcop_1.html#RC3'>funcop_1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  Y -valued   Function-like   total   for    Element of  bool [:X,Y:];
</td><td><span data-href='funcop_1.html#RC4'>funcop_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  Function-yielding   for    Element of  bool [:X,(Funcs (Y,Z)):];
</td><td><span data-href='funcop_1.html#CC4'>funcop_1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  Y -valued   Function-like   quasi_total   for    Element of  bool [:X,Y:];
</td><td><span data-href='funct_2.html#RC1'>funct_2</span></td></tr>
<tr><td>
cluster  total   ->  quasi_total   for    Element of  bool [:X,Y:];
</td><td><span data-href='funct_2.html#CC1'>funct_2</span></td></tr>
<tr><td>
cluster  quasi_total   ->  total   for    Element of  bool [:X,Y:];
</td><td><span data-href='funct_2.html#CC2'>funct_2</span></td></tr>
<tr><td>
cluster  quasi_total   ->  total   for    Element of  bool [:X,Y:];
</td><td><span data-href='funct_2.html#CC3'>funct_2</span></td></tr>
<tr><td>
cluster  quasi_total   ->  total   for    Element of  bool [:X,X:];
</td><td><span data-href='funct_2.html#CC4'>funct_2</span></td></tr>
<tr><td>
cluster  quasi_total   ->  total   for    Element of  bool [:[:X,X:],X:];
</td><td><span data-href='funct_2.html#CC5'>funct_2</span></td></tr>
<tr><td>
cluster  Function-like   bijective   ->  one-to-one   onto   for    Element of  bool [:X,Y:];
</td><td><span data-href='funct_2.html#CC6'>funct_2</span></td></tr>
<tr><td>
cluster  Function-like   one-to-one   onto   ->  bijective   for    Element of  bool [:X,Y:];
</td><td><span data-href='funct_2.html#CC7'>funct_2</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   Function-like   total   quasi_total   bijective   for    Element of  bool [:X,X:];
</td><td><span data-href='funct_2.html#RC2'>funct_2</span></td></tr>
<tr><td>
cluster  reflexive   Function-like   total   quasi_total   ->  bijective   for    Element of  bool [:X,X:];
</td><td><span data-href='funct_2.html#CC8'>funct_2</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  non  empty   for    Element of  bool [:A,B:];
</td><td><span data-href='funct_2.html#CC9'>funct_2</span></td></tr>
<tr><td>
cluster  Relation-like  [:A,A:] -defined  A -valued   Function-like   quasi_total   idempotent   for    Element of  bool [:[:A,A:],A:];
</td><td><span data-href='funct_3.html#RC1'>funct_3</span></td></tr>
<tr><td>
cluster f . n ->  Relation-like  ;
</td><td><span data-href='funct_7.html#FC9'>funct_7</span></td></tr>
<tr><td>
cluster  Function-like   with_symmetrical_domain   quasi_even   ->  even   for    Element of K16(K17(X,Y));
</td><td><span data-href='funct_8.html#CC2'>funct_8</span></td></tr>
<tr><td>
cluster  Function-like   even   ->  with_symmetrical_domain   quasi_even   for    Element of K16(K17(X,Y));
</td><td><span data-href='funct_8.html#CC3'>funct_8</span></td></tr>
<tr><td>
cluster  Function-like   with_symmetrical_domain   quasi_odd   ->  odd   for    Element of K16(K17(X,Y));
</td><td><span data-href='funct_8.html#CC4'>funct_8</span></td></tr>
<tr><td>
cluster  Function-like   odd   ->  with_symmetrical_domain   quasi_odd   for    Element of K16(K17(X,Y));
</td><td><span data-href='funct_8.html#CC5'>funct_8</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like   complex-valued   ext-real-valued   real-valued   periodic   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='funct_9.html#RC2'>funct_9</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like  V30( REAL , REAL )  complex-valued   ext-real-valued   real-valued  t -periodic   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='funct_9.html#RC4'>funct_9</span></td></tr>
<tr><td>
cluster  Relation-like  [:A,A:] -defined  [:B,B:] -valued   Function-like   quasi_total   Covariant   Contravariant   for    Element of  bool [:[:A,A:],[:B,B:]:];
</td><td><span data-href='functor0.html#RC1'>functor0</span></td></tr>
<tr><td>
cluster V1() V4([:[.0,1.],[.0,1.]:]) V5([.0,1.])  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  with_properties_of_fuzzy_implication   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#RC1'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  with_properties_of_fuzzy_implication   ->  decreasing_on_1st   increasing_on_2nd   00-dominant   11-dominant   10-weak   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#CC1'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  decreasing_on_1st   increasing_on_2nd   00-dominant   11-dominant   10-weak   01-dominant   ->  with_properties_of_fuzzy_implication   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#CC2'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  with_properties_of_classical_implication   ->  00-dominant   11-dominant   10-weak   01-dominant   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#CC3'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  00-dominant   11-dominant   10-weak   01-dominant   ->  with_properties_of_classical_implication   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#CC4'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  with_properties_of_fuzzy_implication   ->  with_properties_of_classical_implication   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#CC5'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29([:[.0,1.],[.0,1.]:],[.0,1.])  decreasing_on_1st   increasing_on_2nd   00-dominant   11-dominant   10-weak   ->  satisfying_(LB)   satisfying_(RB)   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuzimpl1.html#CC6'>fuzimpl1</span></td></tr>
<tr><td>
cluster  Function-like  V29(K17([.0,1.],[.0,1.]),[.0,1.])  satisfying_(LB)   ->  satisfying_(I3)   satisfying_(NC)   for    Element of K16(K17(K17([.0,1.],[.0,1.]),[.0,1.]));
</td><td><span data-href='fuzimpl2.html#CC1'>fuzimpl2</span></td></tr>
<tr><td>
cluster  Function-like  V29(K17([.0,1.],[.0,1.]),[.0,1.])  satisfying_(RB)   ->  satisfying_(I4)   satisfying_(NC)   for    Element of K16(K17(K17([.0,1.],[.0,1.]),[.0,1.]));
</td><td><span data-href='fuzimpl2.html#CC2'>fuzimpl2</span></td></tr>
<tr><td>
cluster  Function-like  V29(K17([.0,1.],[.0,1.]),[.0,1.])  satisfying_(NP)   ->  satisfying_(I4)   satisfying_(I5)   for    Element of K16(K17(K17([.0,1.],[.0,1.]),[.0,1.]));
</td><td><span data-href='fuzimpl2.html#CC3'>fuzimpl2</span></td></tr>
<tr><td>
cluster  Function-like  V29(K17([.0,1.],[.0,1.]),[.0,1.])  satisfying_(IP)   ->  satisfying_(I3)   satisfying_(I4)   for    Element of K16(K17(K17([.0,1.],[.0,1.]),[.0,1.]));
</td><td><span data-href='fuzimpl2.html#CC4'>fuzimpl2</span></td></tr>
<tr><td>
cluster  Function-like  V29(K17([.0,1.],[.0,1.]),[.0,1.])  satisfying_(OP)   ->  satisfying_(I3)   satisfying_(I4)   satisfying_(NC)   satisfying_(LB)   satisfying_(RB)   satisfying_(IP)   for    Element of K16(K17(K17([.0,1.],[.0,1.]),[.0,1.]));
</td><td><span data-href='fuzimpl2.html#CC5'>fuzimpl2</span></td></tr>
<tr><td>
cluster  Function-like  V29(K17([.0,1.],[.0,1.]),[.0,1.])  satisfying_(EP)   satisfying_(OP)   ->  satisfying_(I1)   satisfying_(I5)   satisfying_(NP)   for    Element of K16(K17(K17([.0,1.],[.0,1.]),[.0,1.]));
</td><td><span data-href='fuzimpl2.html#CC6'>fuzimpl2</span></td></tr>
<tr><td>
cluster  Relation-like  [:[.0,1.],[.0,1.]:] -defined  [.0,1.] -valued   Function-like  V26([:[.0,1.],[.0,1.]:]) V30([:[.0,1.],[.0,1.]:],[.0,1.])  commutative   associative   monotonic   with-1-identity   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuznorm1.html#RC1'>fuznorm1</span></td></tr>
<tr><td>
cluster  Relation-like  [:[.0,1.],[.0,1.]:] -defined  [.0,1.] -valued   Function-like  V26([:[.0,1.],[.0,1.]:]) V30([:[.0,1.],[.0,1.]:],[.0,1.])  commutative   associative   monotonic   with-0-identity   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuznorm1.html#RC2'>fuznorm1</span></td></tr>
<tr><td>
cluster  Function-like  V30([:[.0,1.],[.0,1.]:],[.0,1.])  commutative   monotonic   with-1-identity   ->  commutative   monotonic   with-1-identity   with-0-annihilating   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuznorm1.html#CC1'>fuznorm1</span></td></tr>
<tr><td>
cluster  Function-like  V30([:[.0,1.],[.0,1.]:],[.0,1.])  commutative   monotonic   with-0-identity   ->  commutative   monotonic   with-1-annihilating   with-0-identity   for    Element of  bool [:[:[.0,1.],[.0,1.]:],[.0,1.]:];
</td><td><span data-href='fuznorm1.html#CC2'>fuznorm1</span></td></tr>
<tr><td>
cluster V5([.0,1.])  Function-like  V30(C, REAL )  strictly-normalized   ->  normalized   for    Element of K16(K17(C,REAL));
</td><td><span data-href='fuznum_1.html#CC1'>fuznum_1</span></td></tr>
<tr><td>
cluster V1() V4(C) V5( REAL ) V5([.0,1.])  non  empty   Function-like   total  V30(C, REAL ) V39() V40() V41()  normalized   for    Element of K16(K17(C,REAL));
</td><td><span data-href='fuznum_1.html#RC1'>fuznum_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL ) V5([.0,1.])  non  empty   Function-like   total  V30( REAL , REAL ) V39() V40() V41()  triangular   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='fuznum_1.html#RC3'>fuznum_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( REAL ) V5([.0,1.])  non  empty   Function-like   total  V30( REAL , REAL ) V39() V40() V41()  trapezoidal   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='fuznum_1.html#RC4'>fuznum_1</span></td></tr>
<tr><td>
cluster  Relation-like  C -defined   REAL  -valued  [.0,1.] -valued   non  empty   Function-like   total  V30(C, REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K16(K17(C,REAL));
</td><td><span data-href='fuzzy_1.html#RC1'>fuzzy_1</span></td></tr>
<tr><td>
cluster [.0,1.] -valued   Function-like  V30(X, REAL )  ->  real-valued   for    Element of K16(K17(X,REAL));
</td><td><span data-href='fuzzy_1.html#CC1'>fuzzy_1</span></td></tr>
<tr><td>
cluster V5([.0,1.])  Function-like   quasi_total   ->   for    Element of  bool [:C,REAL:];
</td><td><span data-href='fuzzy_2.html#CC1'>fuzzy_2</span></td></tr>
<tr><td>
cluster  Relation-like  A -defined   ExtREAL  -valued   Function-like  V40(A, ExtREAL )  e.i.-valued   for    Element of  bool [:A,ExtREAL:];
</td><td><span data-href='fvaluat1.html#RC4'>fvaluat1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of G -defined   the carrier of H -valued   Function-like   non  empty   total   quasi_total   additive   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='grcat_1.html#RC1'>grcat_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of G -defined   the carrier of H -valued   Function-like   non  empty  V22( the carrier of G)  quasi_total   multiplicative   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='group_6.html#RC2'>group_6</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   multiplicative   ->  unity-preserving   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='group_6.html#CC1'>group_6</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of G -defined   the carrier of H -valued   Function-like   non  empty   total   quasi_total   multiplicative   homomorphic   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='group_9.html#RC9'>group_9</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   Funcs (E,E) -valued   non  empty   Function-like   total   quasi_total   being_left_operation   for    Element of  bool [: the carrier of S,(Funcs (E,E)):];
</td><td><span data-href='group_10.html#RC1'>group_10</span></td></tr>
<tr><td>
cluster  Relation-like  I -defined   the carrier of G -valued   Function-like   total   quasi_total   finite-support   for    Element of  bool [:I, the carrier of G:];
</td><td><span data-href='group_19.html#RC2'>group_19</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  additive   ->  subadditive   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC1'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  homogeneous   ->  positively_homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC2'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  semi-homogeneous   ->  positively_homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC3'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  semi-homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC4'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  absolutely_homogeneous   ->  semi-homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC5'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, REAL )  positively_homogeneous   0-preserving   ->  semi-homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#CC6'>hahnban</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   REAL  -valued   Function-like   non  empty   total  V18( the carrier of V, REAL )  additive   homogeneous   absolutely_homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban.html#RC1'>hahnban</span></td></tr>
<tr><td>
cluster  Function-like  V33( the carrier of V, the carrier of K)  homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='hahnban1.html#CC1'>hahnban1</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of K)  Function-like  V33( the carrier of V, the carrier of K)  additive   homogeneous   0-preserving   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='hahnban1.html#RC1'>hahnban1</span></td></tr>
<tr><td>
cluster  Function-like  V33( the carrier of V, REAL )  additive   ->  subadditive   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban1.html#CC2'>hahnban1</span></td></tr>
<tr><td>
cluster  Function-like  V33( the carrier of V, REAL )  Real_homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban1.html#CC3'>hahnban1</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( REAL )  Function-like  V33( the carrier of V, REAL )  additive   0-preserving   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban1.html#RC2'>hahnban1</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( REAL )  Function-like  V33( the carrier of V, REAL )  additive   Real_homogeneous   homogeneous   for    Element of  bool [: the carrier of V,REAL:];
</td><td><span data-href='hahnban1.html#RC3'>hahnban1</span></td></tr>
<tr><td>
cluster  Function-like  V30( the carrier of V, the carrier of F_Complex)  cmplxhomogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC1'>hermitan</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of F_Complex)  Function-like  V30( the carrier of V, the carrier of F_Complex)  additive   0-preserving  V190()  cmplxhomogeneous   for    Element of  bool [: the carrier of V, the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#RC1'>hermitan</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of F_Complex)  non  trivial   Function-like   non  constant  V30( the carrier of V, the carrier of F_Complex)  additive  V190()  cmplxhomogeneous   for    Element of  bool [: the carrier of V, the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#RC2'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  hermitan   ->  diagRvalued   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC2'>hermitan</span></td></tr>
<tr><td>
cluster V1() V4([: the carrier of V, the carrier of V:]) V5( the carrier of F_Complex)  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  additiveFAF   additiveSAF   homogeneousSAF  V190()  cmplxhomogeneousFAF   hermitan   diagRvalued   diagReR+0valued   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#RC3'>hermitan</span></td></tr>
<tr><td>
cluster V1() V4([: the carrier of V, the carrier of W:]) V5( the carrier of F_Complex)  Function-like  V30([: the carrier of V, the carrier of W:], the carrier of F_Complex)  additiveFAF   additiveSAF   homogeneousSAF  V190()  cmplxhomogeneousFAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#RC4'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  additiveFAF   hermitan   ->  additiveSAF   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC3'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  additiveSAF   hermitan   ->  additiveFAF   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC4'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  homogeneousSAF   hermitan   ->  cmplxhomogeneousFAF   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC5'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  cmplxhomogeneousFAF   hermitan   ->  homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC6'>hermitan</span></td></tr>
<tr><td>
cluster V1() V4([: the carrier of V, the carrier of W:]) V5( the carrier of F_Complex)  non  trivial   Function-like   non  constant  V30([: the carrier of V, the carrier of W:], the carrier of F_Complex)  additiveFAF   additiveSAF   homogeneousSAF  V190()  cmplxhomogeneousFAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#RC5'>hermitan</span></td></tr>
<tr><td>
cluster V1() V4([: the carrier of V, the carrier of V:]) V5( the carrier of F_Complex)  non  trivial   Function-like   non  constant  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  additiveFAF   additiveSAF   homogeneousSAF  V190()  cmplxhomogeneousFAF   hermitan   diagRvalued   diagReR+0valued   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#RC6'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  additiveSAF   positivediagvalued   ->  diagReR+0valued   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC7'>hermitan</span></td></tr>
<tr><td>
cluster  Function-like  V30([: the carrier of V, the carrier of V:], the carrier of F_Complex)  additiveFAF   positivediagvalued   ->  diagReR+0valued   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Complex:];
</td><td><span data-href='hermitan.html#CC8'>hermitan</span></td></tr>
<tr><td>
cluster [:A,{x}:] ->  Function-like  ;
</td><td><span data-href='heyting3.html#FC1'>heyting3</span></td></tr>
<tr><td>
cluster  Relation-like   Bags X -defined   INT  -valued   the carrier of F_Real -valued   Function-like   non  empty   total   quasi_total   complex-valued   ext-real-valued   real-valued   for    Element of K27(K28((Bags X), the carrier of F_Real));
</td><td><span data-href='hilb10_2.html#RC3'>hilb10_2</span></td></tr>
<tr><td>
cluster  Relation-like   Bags O -defined   INT  -valued   the carrier of F_Real -valued   Function-like   non  empty   total   quasi_total   complex-valued   ext-real-valued   real-valued   finite-Support   for    Element of K27(K28((Bags O), the carrier of F_Real));
</td><td><span data-href='hilb10_2.html#RC4'>hilb10_2</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   the carrier of F_Real -valued   Function-like   total   quasi_total   complex-valued   ext-real-valued   real-valued   natural-valued   for    Element of K27(K28(X, the carrier of F_Real));
</td><td><span data-href='hilb10_2.html#RC5'>hilb10_2</span></td></tr>
<tr><td>
cluster  Relation-like  O -defined   INT  -valued   the carrier of F_Real -valued   Function-like   total   quasi_total   complex-valued   ext-real-valued   real-valued   for    Element of K27(K28(O, the carrier of F_Real));
</td><td><span data-href='hilb10_2.html#RC6'>hilb10_2</span></td></tr>
<tr><td>
cluster  Relation-like   Bags n -defined   the carrier of F_Real -valued   non  empty   Function-like   total   quasi_total   complex-valued   ext-real-valued   real-valued   natural-valued   finite-Support   for    Element of K16(K17((Bags n), the carrier of F_Real));
</td><td><span data-href='hilb10_5.html#RC1'>hilb10_5</span></td></tr>
<tr><td>
cluster [:P,Q:] ->  bijective   for  Function of [:A,B:],[:A,B:];
</td><td><span data-href='hilbert3.html#FC4'>hilbert3</span></td></tr>
<tr><td>
cluster  Relation-like   SetVal (V,(p => q)) -defined   SetVal (V,(p => r)) -valued   non  empty   Function-like   total   quasi_total   Function-yielding  V59()  for    Element of  bool [:(SetVal (V,(p => q))),(SetVal (V,(p => r))):];
</td><td><span data-href='hilbert3.html#RC1'>hilbert3</span></td></tr>
<tr><td>
cluster  Relation-like  A -defined  A -valued   Function-like   one-to-one   total   quasi_total   onto   bijective   involutive   oneone   for    Element of  bool [:A,A:];
</td><td><span data-href='hilbert4.html#RC2'>hilbert4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  X -defined  X -valued   Function-like   one-to-one   total   quasi_total   onto   bijective  V67()  oneone   for    Element of  bool [:X,X:];
</td><td><span data-href='hilbert4.html#RC3'>hilbert4</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of F_Complex -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of F_Complex)  complex-valued   finite-Support   Hurwitz   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='hurwitz2.html#RC1'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of L -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of L)  finite-Support   even   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='hurwitz2.html#RC2'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of L -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of L)  finite-Support   odd   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='hurwitz2.html#RC3'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of L -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of L)  finite-Support   non  zero   even   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='hurwitz2.html#RC4'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of L -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of L)  finite-Support   non  zero   odd   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='hurwitz2.html#RC5'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of F_Complex -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of F_Complex)  complex-valued   finite-Support   non  zero   real   positive   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='hurwitz2.html#RC6'>hurwitz2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , the carrier of F_Complex)  finite-Support   real   ->  real-valued   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='hurwitz2.html#CC1'>hurwitz2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , the carrier of F_Complex)  finite-Support   real   with_positive_coefficients   ->  real   with_all_coefficients   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='hurwitz2.html#CC2'>hurwitz2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , the carrier of F_Complex)  finite-Support   real   with_negative_coefficients   ->  real   with_all_coefficients   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='hurwitz2.html#CC3'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of F_Complex -valued   Function-like  V11() V14( NAT ) V18( NAT , the carrier of F_Complex)  complex-valued   ext-real-valued   real-valued   finite-Support   non  constant   real   with_positive_coefficients   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='hurwitz2.html#RC7'>hurwitz2</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   COMPLEX  -valued   Function-like   complex-valued   C1-curve-like   for    Element of  bool [:REAL,COMPLEX:];
</td><td><span data-href='integr1c.html#RC1'>integr1c</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of (TopSpaceMetr M)) V5( the carrier of (TopSpaceMetr M))  non  empty   Function-like  V26( the carrier of (TopSpaceMetr M))  quasi_total   onto   isometric   for    Element of K16(K17( the carrier of (TopSpaceMetr M), the carrier of (TopSpaceMetr M)));
</td><td><span data-href='jordan24.html#RC1'>jordan24</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   isometric   ->  continuous   for    Element of K16(K17( the carrier of (TopSpaceMetr M), the carrier of (TopSpaceMetr M)));
</td><td><span data-href='jordan24.html#CC1'>jordan24</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   onto   isometric   ->  being_homeomorphism   for    Element of K16(K17( the carrier of (TopSpaceMetr M), the carrier of (TopSpaceMetr M)));
</td><td><span data-href='jordan24.html#CC2'>jordan24</span></td></tr>
<tr><td>
cluster  Relation-like  A -defined  B -valued   Function-like   quasi_total   c=-monotone   for    Element of  bool [:A,B:];
</td><td><span data-href='knaster.html#RC1'>knaster</span></td></tr>
<tr><td>
cluster  Function-like  V35( NAT , bool X)  ->  non  empty   for    Element of  bool [:NAT,(bool X):];
</td><td><span data-href='kurato_0.html#CC1'>kurato_0</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   non-empty   NAT  -defined   bool T -valued   Function-like  V31( NAT ) V35( NAT , bool T)  for    Element of  bool [:NAT,(bool T):];
</td><td><span data-href='kurato_0.html#RC1'>kurato_0</span></td></tr>
<tr><td>
cluster  Function-like   constant  V35( NAT , bool T)  -> V52() V53()  convergent   for    Element of  bool [:NAT,(bool T):];
</td><td><span data-href='kurato_0.html#CC2'>kurato_0</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   NAT  -defined   bool T -valued   Function-like   constant  V31( NAT ) V35( NAT , bool T)  for    Element of  bool [:NAT,(bool T):];
</td><td><span data-href='kurato_0.html#RC2'>kurato_0</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L1 -defined   the carrier of L2 -valued   Function-like   non  empty  V19( the carrier of L1)  quasi_total   "\/"-preserving   "/\"-preserving   for    Element of  bool [: the carrier of L1, the carrier of L2:];
</td><td><span data-href='lattice4.html#RC1'>lattice4</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L1 -defined   the carrier of L2 -valued   Function-like   quasi_total   meet-preserving   join-preserving   for    Element of  bool [: the carrier of L1, the carrier of L2:];
</td><td><span data-href='lattice5.html#RC1'>lattice5</span></td></tr>
<tr><td>
cluster  Relation-like  [:A,A:] -defined   the carrier of L -valued   Function-like   quasi_total   symmetric   zeroed   u.t.i.   for    Element of  bool [:[:A,A:], the carrier of L:];
</td><td><span data-href='lattice5.html#RC3'>lattice5</span></td></tr>
<tr><td>
cluster [.0,1.] -valued   Function-like   quasi_total   ->  real-valued   for    Element of  bool [:X,REAL:];
</td><td><span data-href='lfuzzy_1.html#CC1'>lfuzzy_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  [:X,X:] -defined   REAL  -valued  [.0,1.] -valued   Function-like   total   quasi_total   complex-valued   ext-real-valued   real-valued   reflexive   symmetric   transitive   antisymmetric   for    Element of  bool [:[:X,X:],REAL:];
</td><td><span data-href='lfuzzy_1.html#RC1'>lfuzzy_1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   NAT  -valued   REAL  -valued   INT  -valued   non  empty   Function-like  V28( omega ) V32( omega , REAL ) V39() V40() V41()  for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#RC1'>liouvil1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   NAT  -valued   REAL  -valued   non  empty   Function-like  V28( omega ) V32( omega , REAL ) V39() V40() V41()  positive-yielding   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#RC2'>liouvil1</span></td></tr>
<tr><td>
cluster  Function-like  V32( omega , REAL )  eventually-nonzero   ->  eventually-non-zero   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#CC1'>liouvil1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   non  empty   Function-like  V28( omega ) V32( omega , REAL ) V39() V40() V41()  eventually-non-zero   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#RC3'>liouvil1</span></td></tr>
<tr><td>
cluster  non-zero   Function-like   constant  V32( omega , REAL )  ->  eventually-non-zero   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#CC2'>liouvil1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   non  empty   Function-like  V28( omega ) V32( omega , REAL ) V39() V40() V41()  nonnegative-yielding   for    Element of K21(K22(omega,REAL));
</td><td><span data-href='liouvil1.html#RC4'>liouvil1</span></td></tr>
<tr><td>
cluster  Function-like  V44( NAT , the carrier of L)  finite-Support   monic   ->  non-zero   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='liouvil2.html#CC2'>liouvil2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   INT  -valued   the carrier of F_Complex -valued   Function-like  V44( NAT , the carrier of F_Complex)  complex-valued   finite-Support   monic   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='liouvil2.html#RC3'>liouvil2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   RAT  -valued   the carrier of F_Complex -valued   Function-like  V44( NAT , the carrier of F_Complex)  complex-valued   finite-Support   monic   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='liouvil2.html#RC4'>liouvil2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   the carrier of F_Complex -valued   Function-like  V44( NAT , the carrier of F_Complex)  complex-valued   finite-Support   monic   for    Element of K19(K20(NAT, the carrier of F_Complex));
</td><td><span data-href='liouvil2.html#RC5'>liouvil2</span></td></tr>
<tr><td>
cluster  Function-like  V44( NAT , the carrier of L)  finite-Support   non-zero   ->  non  zero   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='liouvil2.html#CC3'>liouvil2</span></td></tr>
<tr><td>
cluster  Function-like  V44( NAT , the carrier of L)  finite-Support   zero   ->  non  non-zero   for    Element of K19(K20(NAT, the carrier of L));
</td><td><span data-href='liouvil2.html#CC4'>liouvil2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (product X) -defined   the carrier of Y -valued   Function-like   non  empty   total   quasi_total   Multilinear   for    Element of K19(K20( the carrier of (product X), the carrier of Y));
</td><td><span data-href='lopban10.html#RC1'>lopban10</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (product X) -defined   the carrier of Y -valued   Function-like   non  empty   total   quasi_total   Multilinear   for    Element of K19(K20( the carrier of (product X), the carrier of Y));
</td><td><span data-href='lopban10.html#RC2'>lopban10</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (product X) -defined   the carrier of Y -valued   Function-like   non  empty   total   quasi_total   Multilinear   Lipschitzian   for    Element of K19(K20( the carrier of (product X), the carrier of Y));
</td><td><span data-href='lopban10.html#RC3'>lopban10</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:X,Y:] -defined   the carrier of (product <*X,Y*>) -valued   Function-like  V11() V14( the carrier of [:X,Y:])  quasi_total   bijective  V166([:X,Y:], product <*X,Y*>) V167([:X,Y:], product <*X,Y*>)  for    Element of K19(K20( the carrier of [:X,Y:], the carrier of (product <*X,Y*>)));
</td><td><span data-href='lopban12.html#RC1'>lopban12</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (product <*X,Y*>) -defined   the carrier of [:X,Y:] -valued   Function-like  V11() V14( the carrier of (product <*X,Y*>))  quasi_total   bijective  V166( product <*X,Y*>,[:X,Y:]) V167( product <*X,Y*>,[:X,Y:])  for    Element of K19(K20( the carrier of (product <*X,Y*>), the carrier of [:X,Y:]));
</td><td><span data-href='lopban12.html#RC2'>lopban12</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of X -defined   the carrier of Y -valued   Function-like   total   quasi_total   additive   homogeneous   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='lopban_1.html#RC1'>lopban_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of X -defined   the carrier of Y -valued   Function-like   total   quasi_total   additive   homogeneous   Lipschitzian   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='lopban_1.html#RC2'>lopban_1</span></td></tr>
<tr><td>
cluster V4()  Relation-like   NAT  -defined   the carrier of X -valued   Function-like  V32( NAT ) V33( NAT , the carrier of X)  summable   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='lopban_3.html#RC1'>lopban_3</span></td></tr>
<tr><td>
cluster V4()  Relation-like   NAT  -defined   the carrier of X -valued   Function-like  V32( NAT ) V33( NAT , the carrier of X)  norm_summable   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='lopban_3.html#RC2'>lopban_3</span></td></tr>
<tr><td>
cluster  Function-like  V33( NAT , the carrier of X)  summable   ->  convergent   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='lopban_3.html#CC1'>lopban_3</span></td></tr>
<tr><td>
cluster  Function-like  V33( NAT , the carrier of X)  norm_summable   ->  summable   for    Element of K32(K33(NAT, the carrier of X));
</td><td><span data-href='lopban_3.html#CC2'>lopban_3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   homogeneous   closed   ->  Lipschitzian   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='lopban_7.html#CC1'>lopban_7</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of E, the carrier of F:] -defined   the carrier of G -valued   Function-like   total   quasi_total   Bilinear   for    Element of  bool [:[: the carrier of E, the carrier of F:], the carrier of G:];
</td><td><span data-href='lopban_8.html#RC1'>lopban_8</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:E,F:] -defined   the carrier of G -valued   non  empty   Function-like   total   quasi_total   Bilinear   for    Element of  bool [: the carrier of [:E,F:], the carrier of G:];
</td><td><span data-href='lopban_8.html#RC2'>lopban_8</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:E,F:] -defined   the carrier of G -valued   non  empty   Function-like   total   quasi_total   Bilinear   for    Element of  bool [: the carrier of [:E,F:], the carrier of G:];
</td><td><span data-href='lopban_8.html#RC3'>lopban_8</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:X,Y:] -defined   the carrier of Z -valued   non  empty   Function-like  V28( the carrier of [:X,Y:])  quasi_total   Bilinear   Lipschitzian   for    Element of  bool [: the carrier of [:X,Y:], the carrier of Z:];
</td><td><span data-href='lopban_9.html#RC1'>lopban_9</span></td></tr>
<tr><td>
cluster  consistent   complete   for    Element of [:(LTLB_WFF **),(LTLB_WFF **):];
</td><td><span data-href='ltlaxio3.html#RC1'>ltlaxio3</span></td></tr>
<tr><td>
cluster F ^  ->  non  empty  ;
</td><td><span data-href='ltlaxio4.html#FC1'>ltlaxio4</span></td></tr>
<tr><td>
cluster F ^  ->  finite  ;
</td><td><span data-href='ltlaxio4.html#FC2'>ltlaxio4</span></td></tr>
<tr><td>
cluster  comp X ->  finite  ;
</td><td><span data-href='ltlaxio4.html#FC4'>ltlaxio4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  boolean-valued   for    Element of  bool [:A,BOOLEAN:];
</td><td><span data-href='margrel1.html#CC3'>margrel1</span></td></tr>
<tr><td>
cluster  Relation-like  A *  -defined  A -valued   Function-like   non  empty   homogeneous   quasi_total   for    Element of  bool [:(A *),A:];
</td><td><span data-href='margrel1.html#RC3'>margrel1</span></td></tr>
<tr><td>
cluster  Relation-like   Seg (n + 2) -defined   Seg (n + 2) -valued   Function-like   one-to-one   non  empty   total   quasi_total   onto   bijective   finite   odd   for    Element of  bool [:(Seg (n + 2)),(Seg (n + 2)):];
</td><td><span data-href='matrix11.html#RC2'>matrix11</span></td></tr>
<tr><td>
cluster  Relation-like   Seg n -defined   Seg n -valued   Function-like   one-to-one   total   quasi_total   finite   FinSequence-like   for    Element of  bool [:(Seg n),(Seg n):];
</td><td><span data-href='matrix_9.html#RC2'>matrix_9</span></td></tr>
<tr><td>
cluster  Relation-like   Seg 2 -defined   Seg 2 -valued   Function-like   one-to-one   non  empty   total   quasi_total   onto   bijective   finite   odd   for    Element of  bool [:(Seg 2),(Seg 2):];
</td><td><span data-href='matrix_9.html#RC3'>matrix_9</span></td></tr>
<tr><td>
cluster  Relation-like   Seg n -defined   Seg n -valued   Function-like   one-to-one   total   quasi_total   onto   bijective   finite   even   for    Element of  bool [:(Seg n),(Seg n):];
</td><td><span data-href='matrix_9.html#RC4'>matrix_9</span></td></tr>
<tr><td>
cluster  Relation-like   Seg 3 -defined   Seg 3 -valued   Function-like   one-to-one   non  empty   total   quasi_total   onto   bijective   finite   odd   for    Element of  bool [:(Seg 3),(Seg 3):];
</td><td><span data-href='matrix_9.html#RC5'>matrix_9</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of V -valued   Function-like   non  empty   total  V18( the carrier of V, the carrier of V)  nilpotent   for    Element of  bool [: the carrier of V, the carrier of V:];
</td><td><span data-href='matrixj2.html#RC4'>matrixj2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of V -valued   Function-like   non  empty   total  V18( the carrier of V, the carrier of V)  additive   homogeneous   nilpotent   for    Element of  bool [: the carrier of V, the carrier of V:];
</td><td><span data-href='matrixj2.html#RC5'>matrixj2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (TOP-REAL n) -defined   the carrier of (TOP-REAL n) -valued   non  empty   Function-like   total   quasi_total   homogeneous   for    Element of  bool [: the carrier of (TOP-REAL n), the carrier of (TOP-REAL n):];
</td><td><span data-href='matrtop3.html#RC2'>matrtop3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  FinSequence-yielding   for    Element of  bool [: the carrier of (TOP-REAL n), the carrier of (TOP-REAL m):];
</td><td><span data-href='matrtop3.html#CC3'>matrtop3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (TOP-REAL n) -defined   the carrier of (TOP-REAL n) -valued   non  empty   Function-like   total   quasi_total   Function-yielding  V196()  FinSequence-yielding   base_rotation   for    Element of  bool [: the carrier of (TOP-REAL n), the carrier of (TOP-REAL n):];
</td><td><span data-href='matrtop3.html#RC3'>matrtop3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   base_rotation   ->  additive   homogeneous   being_homeomorphism   rotation   for    Element of  bool [: the carrier of (TOP-REAL n), the carrier of (TOP-REAL n):];
</td><td><span data-href='matrtop3.html#CC4'>matrtop3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   homogeneous   rotation   ->  being_homeomorphism   for    Element of  bool [: the carrier of (TOP-REAL n), the carrier of (TOP-REAL n):];
</td><td><span data-href='matrtop3.html#CC5'>matrtop3</span></td></tr>
<tr><td>
cluster  non  empty  V4() V7( the carrier of E) V8( the carrier of E)  Function-like   total   quasi_total   bijective   isometric   Affine   midpoints-preserving   for    Element of K10(K11( the carrier of E, the carrier of E));
</td><td><span data-href='mazurulm.html#RC1'>mazurulm</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   bijective   isometric   ->  midpoints-preserving   for    Element of K10(K11( the carrier of E, the carrier of F));
</td><td><span data-href='mazurulm.html#CC1'>mazurulm</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   isometric   midpoints-preserving   ->  Affine   for    Element of K10(K11( the carrier of E, the carrier of F));
</td><td><span data-href='mazurulm.html#CC2'>mazurulm</span></td></tr>
<tr><td>
cluster   ->  pair   for    Element of [:X1,X2:];
</td><td><span data-href='mcart_1.html#CC1'>mcart_1</span></td></tr>
<tr><td>
cluster  Relation-like  S -defined   ExtREAL  -valued   Function-like   non  empty  V14(S) V18(S, ExtREAL )  ext-real-valued   zeroed  V94()  additive   for    Element of  bool [:S,ExtREAL:];
</td><td><span data-href='measure1.html#RC1'>measure1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined  S -valued   Function-like   non  empty  V14( NAT ) V18( NAT ,S)  disjoint_valued   for    Element of  bool [:NAT,S:];
</td><td><span data-href='measure1.html#RC5'>measure1</span></td></tr>
<tr><td>
cluster  Relation-like  S -defined   ExtREAL  -valued   Function-like   non  empty  V14(S) V18(S, ExtREAL )  ext-real-valued   zeroed  V94()  sigma-additive   for    Element of  bool [:S,ExtREAL:];
</td><td><span data-href='measure1.html#RC6'>measure1</span></td></tr>
<tr><td>
cluster  Function-like  V18(S, ExtREAL )  zeroed  V94()  sigma-additive   ->  zeroed  V94()  additive   for    Element of  bool [:S,ExtREAL:];
</td><td><span data-href='measure1.html#CC8'>measure1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   omega  -defined  F -valued   Function-like  V30( omega )  quasi_total   disjoint_valued   for    Element of  bool [:omega,F:];
</td><td><span data-href='measure8.html#RC1'>measure8</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined  P -valued   non  empty   Function-like   total  V31( omega ,P)  disjoint_valued   for    Element of  bool [:omega,P:];
</td><td><span data-href='measure9.html#RC2'>measure9</span></td></tr>
<tr><td>
cluster  Relation-like  P -defined   ExtREAL  -valued   non  empty   Function-like   total  V31(P, ExtREAL )  ext-real-valued   zeroed  V224()  additive   for    Element of  bool [:P,ExtREAL:];
</td><td><span data-href='measure9.html#RC3'>measure9</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined  P -valued   non  empty   Function-like   total  V31( NAT ,P)  disjoint_valued   for    Element of  bool [:NAT,P:];
</td><td><span data-href='measure9.html#RC4'>measure9</span></td></tr>
<tr><td>
cluster  Relation-like   FinPartSt S -defined   FinPartSt S -valued   Function-like   Function-yielding  V38()  data-only   for    Element of K10(K11((FinPartSt S),(FinPartSt S)));
</td><td><span data-href='memstr_0.html#RC9'>memstr_0</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   REAL  -valued   Function-like  V54() V55() V56()  nonnegative   for    Element of K16(K17(X,REAL));
</td><td><span data-href='mesfun6c.html#RC1'>mesfun6c</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   ExtREAL  -valued   Function-like  V69() E -measurable   for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='mesfun13.html#RC1'>mesfun13</span></td></tr>
<tr><td>
cluster  Function-like   nonnegative   -> ()  for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='mesfunc5.html#CC1'>mesfunc5</span></td></tr>
<tr><td>
cluster  Function-like   nonpositive   -> ()  for    Element of  bool [:X,ExtREAL:];
</td><td><span data-href='mesfunc5.html#CC2'>mesfunc5</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   ExtREAL  -valued   Function-like   extreal-yielding   nonnegative   for    Element of K16(K17(X,ExtREAL));
</td><td><span data-href='mesfunc7.html#RC1'>mesfunc7</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   PFuncs (X,Y) -valued   non  empty   Function-like   total  V32( NAT , PFuncs (X,Y))  with_the_same_dom   for    Element of  bool [:NAT,(PFuncs (X,Y)):];
</td><td><span data-href='mesfunc8.html#RC1'>mesfunc8</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   PFuncs (X,ExtREAL) -valued   non  empty   Function-like   total   quasi_total   with_the_same_dom   additive   for    Element of  bool [:NAT,(PFuncs (X,ExtREAL)):];
</td><td><span data-href='mesfunc9.html#RC1'>mesfunc9</span></td></tr>
<tr><td>
cluster  MetrStruct(# A,r #) ->  non  empty  ;
</td><td><span data-href='metric_3.html#FC1'>metric_3</span></td></tr>
<tr><td>
cluster  Function-like   constant  V33( NAT , the carrier of M)  ->  convergent   for    Element of  bool [:NAT, the carrier of M:];
</td><td><span data-href='metric_6.html#CC1'>metric_6</span></td></tr>
<tr><td>
cluster  Function-like  V33( NAT , the carrier of M)  Cauchy   ->  bounded   for    Element of  bool [:NAT, the carrier of M:];
</td><td><span data-href='metric_6.html#CC2'>metric_6</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   NAT  -defined   the carrier of M -valued   Function-like   constant  V32( NAT ) V33( NAT , the carrier of M)  convergent   Cauchy   bounded   for    Element of  bool [:NAT, the carrier of M:];
</td><td><span data-href='metric_6.html#RC1'>metric_6</span></td></tr>
<tr><td>
cluster p ~  ->  non  empty  ;
</td><td><span data-href='midsp_1.html#FC2'>midsp_1</span></td></tr>
<tr><td>
cluster  connected   transitive   total   ->  beta-transitive   for    Element of  bool [:X,X:];
</td><td><span data-href='mmlquer2.html#CC1'>mmlquer2</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   reflexive   antisymmetric   connected   transitive   total   for    Element of  bool [:X,X:];
</td><td><span data-href='mmlquer2.html#RC1'>mmlquer2</span></td></tr>
<tr><td>
cluster  empty   Relation-like  X -defined  X -valued   for    Element of  bool [:X,X:];
</td><td><span data-href='mmlquer2.html#RC2'>mmlquer2</span></td></tr>
<tr><td>
cluster  reflexive   antisymmetric   transitive   total   ->  well_founded   for    Element of  bool [:X,X:];
</td><td><span data-href='mmlquer2.html#CC3'>mmlquer2</span></td></tr>
<tr><td>
cluster  reflexive   antisymmetric   connected   transitive   total   ->  connected   well-ordering   for    Element of  bool [:X,X:];
</td><td><span data-href='mmlquer2.html#CC4'>mmlquer2</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   filtering   for    Element of  bool [:X,X:];
</td><td><span data-href='mmlquery.html#RC1'>mmlquery</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   antilinear   ->  additive   unity-preserving   antimultiplicative   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC1'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   unity-preserving   antimultiplicative   ->  antilinear   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC2'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   monomorphism   ->  one-to-one   linear   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC3'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   one-to-one   quasi_total   linear   ->  monomorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC4'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   antimonomorphism   ->  one-to-one   antilinear   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC5'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   one-to-one   quasi_total   antilinear   ->  antimonomorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC6'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   epimorphism   ->  onto   linear   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC7'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   onto   linear   ->  epimorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC8'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   antiepimorphism   ->  onto   antilinear   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC9'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   onto   antilinear   ->  antiepimorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC10'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   isomorphism   ->  onto   monomorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC11'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   onto   monomorphism   ->  isomorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC12'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   antiisomorphism   ->  onto   antimonomorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC13'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   onto   antimonomorphism   ->  antiisomorphism   for    Element of  bool [: the carrier of K, the carrier of L:];
</td><td><span data-href='mod_4.html#CC14'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   endomorphism   ->  linear   for    Element of  bool [: the carrier of K, the carrier of K:];
</td><td><span data-href='mod_4.html#CC15'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   linear   ->  endomorphism   for    Element of  bool [: the carrier of K, the carrier of K:];
</td><td><span data-href='mod_4.html#CC16'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   antiendomorphism   ->  antilinear   for    Element of  bool [: the carrier of K, the carrier of K:];
</td><td><span data-href='mod_4.html#CC17'>mod_4</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   antilinear   ->  antiendomorphism   for    Element of  bool [: the carrier of K, the carrier of K:];
</td><td><span data-href='mod_4.html#CC18'>mod_4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of G -defined   the carrier of G -valued   Function-like  V17( the carrier of G)  quasi_total   bijective   additive   for    Element of  bool [: the carrier of G, the carrier of G:];
</td><td><span data-href='mod_4.html#RC1'>mod_4</span></td></tr>
<tr><td>
cluster  Relation-like  [:NAT,NAT:] -valued   Function-like   finite   DecoratedTree-like   atomic   for    Element of  MP-WFF ;
</td><td><span data-href='modal_1.html#RC1'>modal_1</span></td></tr>
<tr><td>
cluster  Relation-like  [:NAT,NAT:] -valued   Function-like   finite   DecoratedTree-like   negative   for    Element of  MP-WFF ;
</td><td><span data-href='modal_1.html#RC2'>modal_1</span></td></tr>
<tr><td>
cluster  Relation-like  [:NAT,NAT:] -valued   Function-like   finite   DecoratedTree-like   necessitive   for    Element of  MP-WFF ;
</td><td><span data-href='modal_1.html#RC3'>modal_1</span></td></tr>
<tr><td>
cluster  Relation-like  [:NAT,NAT:] -valued   Function-like   finite   DecoratedTree-like   conjunctive   for    Element of  MP-WFF ;
</td><td><span data-href='modal_1.html#RC4'>modal_1</span></td></tr>
<tr><td>
cluster  Relation-like  A -defined   NAT  -valued   Function-like   one-to-one  V18(A, NAT )  for    Element of  bool [:A,NAT:];
</td><td><span data-href='msafree4.html#RC4'>msafree4</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   bool (bool  the carrier of T) -valued   Function-like   non  empty  V14( omega )  quasi_total   sigma_discrete   for    Element of  bool [:omega,(bool (bool  the carrier of T)):];
</td><td><span data-href='nagata_1.html#RC3'>nagata_1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   bool (bool  the carrier of T) -valued   Function-like   non  empty  V14( omega )  quasi_total   sigma_locally_finite   for    Element of  bool [:omega,(bool (bool  the carrier of T)):];
</td><td><span data-href='nagata_1.html#RC4'>nagata_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of M -defined   the carrier of M -valued   non  empty   Function-like   total   quasi_total   contraction   for    Element of K16(K17( the carrier of M, the carrier of M));
</td><td><span data-href='ncfcont2.html#RC1'>ncfcont2</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of S) V6()  Function-like   total   quasi_total   non-zero   0. S -convergent   for    Element of K16(K17(NAT, the carrier of S));
</td><td><span data-href='ndiff_1.html#RC1'>ndiff_1</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of S) V6()  Function-like   total   quasi_total   0. S -convergent   for    Element of K16(K17(NAT, the carrier of S));
</td><td><span data-href='ndiff_1.html#RC2'>ndiff_1</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of S) V6()  Function-like   constant   total   quasi_total   for    Element of K16(K17(NAT, the carrier of S));
</td><td><span data-href='ndiff_1.html#RC3'>ndiff_1</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of S) V5( the carrier of T)  Function-like   RestFunc-like   for    Element of K16(K17( the carrier of S, the carrier of T));
</td><td><span data-href='ndiff_1.html#RC4'>ndiff_1</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( the carrier of F)  Function-like   RestFunc-like   for    Element of K16(K17(REAL, the carrier of F));
</td><td><span data-href='ndiff_3.html#RC1'>ndiff_3</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( the carrier of F) V6()  Function-like   total   quasi_total   linear   for    Element of K16(K17(REAL, the carrier of F));
</td><td><span data-href='ndiff_3.html#RC2'>ndiff_3</span></td></tr>
<tr><td>
cluster V1() V4( REAL ) V5( the carrier of F) V6()  Function-like   total   quasi_total   differentiable   for    Element of K16(K17(REAL, the carrier of F));
</td><td><span data-href='ndiff_3.html#RC3'>ndiff_3</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL n -valued   non  empty   Function-like   total   quasi_total   Function-yielding  V237() V238() V239()  differentiable   for    Element of K16(K17(REAL,(REAL n)));
</td><td><span data-href='ndiff_4.html#RC1'>ndiff_4</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of [:X,Y:] -defined   the carrier of (product <*X,Y*>) -valued   non  empty   Function-like   one-to-one   total   quasi_total   onto  V152([:X,Y:], product <*X,Y*>) V153([:X,Y:], product <*X,Y*>)  isometric   for    Element of  bool [: the carrier of [:X,Y:], the carrier of (product <*X,Y*>):];
</td><td><span data-href='ndiff_7.html#RC1'>ndiff_7</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of (product <*X,Y*>) -defined   the carrier of [:X,Y:] -valued   non  empty   Function-like   one-to-one   total   quasi_total   onto  V152( product <*X,Y*>,[:X,Y:]) V153( product <*X,Y*>,[:X,Y:])  isometric   for    Element of  bool [: the carrier of (product <*X,Y*>), the carrier of [:X,Y:]:];
</td><td><span data-href='ndiff_7.html#RC2'>ndiff_7</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total  V152(S,T) V153(S,T)  isometric   ->  Lipschitzian   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='ndiff_7.html#CC1'>ndiff_7</span></td></tr>
<tr><td>
cluster   ->  trivial   for    Element of  bool [:X,Y:];
</td><td><span data-href='neckla_3.html#CC1'>neckla_3</span></td></tr>
<tr><td>
cluster   ->  trivial   reflexive   symmetric   strongly_connected   transitive   for    Element of  bool [:X,X:];
</td><td><span data-href='neckla_3.html#CC2'>neckla_3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of M -defined   the carrier of M -valued   non  empty   Function-like   total   quasi_total   contraction   for    Element of K16(K17( the carrier of M, the carrier of M));
</td><td><span data-href='nfcont_2.html#RC1'>nfcont_2</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  continuous   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC1'>nfcont_3</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   the carrier of S -valued   Function-like   continuous   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#RC1'>nfcont_3</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  continuous   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC2'>nfcont_3</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  Lipschitzian   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC3'>nfcont_3</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   the carrier of S -valued   empty   Function-like   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#RC2'>nfcont_3</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  Lipschitzian   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC4'>nfcont_3</span></td></tr>
<tr><td>
cluster  Function-like   Lipschitzian   ->  continuous   for    Element of  bool [:REAL, the carrier of S:];
</td><td><span data-href='nfcont_3.html#CC5'>nfcont_3</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC1'>nfcont_4</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL n -valued   Function-like  V158() V231() V232() V233()  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#RC1'>nfcont_4</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC2'>nfcont_4</span></td></tr>
<tr><td>
cluster  empty   Function-like   ->  Lipschitzian   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC3'>nfcont_4</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL n -valued   empty   Function-like  V158() V231() V232() V233()  for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#RC2'>nfcont_4</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  Lipschitzian   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC4'>nfcont_4</span></td></tr>
<tr><td>
cluster  Function-like   Lipschitzian   ->  continuous   for    Element of  bool [:REAL,(REAL n):];
</td><td><span data-href='nfcont_4.html#CC5'>nfcont_4</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   INT  -valued   the carrier of F_Real -valued   Function-like   non  empty   total  V18( NAT , the carrier of F_Real)  complex-valued   ext-real-valued   real-valued   finite-Support   monic   for    Element of K19(K20(NAT, the carrier of F_Real));
</td><td><span data-href='niven.html#RC2'>niven</span></td></tr>
<tr><td>
cluster  Relation-like  V -defined  A -valued   Function-like   finite   for    Element of  bool [:V,A:];
</td><td><span data-href='nomin_1.html#RC1'>nomin_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   homogeneous   isomorphism   ->  one-to-one   onto   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='normsp_3.html#CC1'>normsp_3</span></td></tr>
<tr><td>
cluster  Function-like   one-to-one   quasi_total   onto   additive   homogeneous   ->  isomorphism   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='normsp_3.html#CC2'>normsp_3</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   homogeneous   isomorphism   ->  one-to-one   onto   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='normsp_3.html#CC3'>normsp_3</span></td></tr>
<tr><td>
cluster  Function-like  V22()  quasi_total   ->  contraction   for    Element of K16(K17( the carrier of X, the carrier of X));
</td><td><span data-href='ordeq_01.html#CC1'>ordeq_01</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   contraction   ->  with_unique_fixpoint   for    Element of K16(K17( the carrier of X, the carrier of X));
</td><td><span data-href='ordeq_01.html#CC2'>ordeq_01</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   REAL  -valued   Function-like   total   quasi_total  V53() V54() V55()  nonnegative-yielding   finite-support   for    Element of K16(K17(X,REAL));
</td><td><span data-href='orders_5.html#RC3'>orders_5</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   COMPLEX  -valued   Function-like   total   quasi_total  V53()  nonnegative-yielding   finite-support   for    Element of K16(K17(X,COMPLEX));
</td><td><span data-href='orders_5.html#RC4'>orders_5</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of A -defined   the carrier of A -valued   total   quasi_total   reflexive   symmetric   transitive   EqRelOf-like   for    Element of K16(K17( the carrier of A, the carrier of A));
</td><td><span data-href='orders_5.html#RC7'>orders_5</span></td></tr>
<tr><td>
cluster  Function-like  V28( On W, On W)  ->  Sequence-like   Ordinal-yielding   for    Element of  bool [:(On W),(On W):];
</td><td><span data-href='ordinal4.html#CC1'>ordinal4</span></td></tr>
<tr><td>
cluster  Relation-like   On U -defined   On U -valued   Function-like   Sequence-like   non  empty  V28( On U) V32( On U, On U)  Ordinal-yielding   normal   for    Element of  bool [:(On U),(On U):];
</td><td><span data-href='ordinal6.html#RC4'>ordinal6</span></td></tr>
<tr><td>
cluster  Function-like  V32(a, On U)  ->  Sequence-like   Ordinal-yielding   for    Element of  bool [:a,(On U):];
</td><td><span data-href='ordinal6.html#CC6'>ordinal6</span></td></tr>
<tr><td>
cluster  Function-like  V32(a,b)  ->  Sequence-like   Ordinal-yielding   for    Element of  bool [:a,b:];
</td><td><span data-href='ordinal6.html#CC7'>ordinal6</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  Y -valued   Function-like   for    Element of  bool [:X,Y:];
</td><td><span data-href='partfun1.html#RC1'>partfun1</span></td></tr>
<tr><td>
cluster   ->  total   for    Element of  bool [:X,Y:];
</td><td><span data-href='partfun1.html#CC1'>partfun1</span></td></tr>
<tr><td>
cluster   ->  non  total   for    Element of  bool [:X,Y:];
</td><td><span data-href='partfun1.html#CC2'>partfun1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   reflexive   symmetric   antisymmetric   transitive   total   for    Element of  bool [:X,X:];
</td><td><span data-href='partfun1.html#RC2'>partfun1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  Y -valued   Function-like   non  empty   for    Element of  bool [:X,Y:];
</td><td><span data-href='partfun1.html#RC3'>partfun1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   REAL  -valued   Function-like   total  V36(X, REAL )  complex-valued   ext-real-valued   real-valued   negative-yielding   for    Element of K16(K17(X,REAL));
</td><td><span data-href='partfun3.html#RC1'>partfun3</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   REAL  -valued   Function-like   total  V36(X, REAL )  complex-valued   ext-real-valued   real-valued   positive-yielding   for    Element of K16(K17(X,REAL));
</td><td><span data-href='partfun3.html#RC2'>partfun3</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of T) V5( REAL )  non  empty   Function-like  V32( the carrier of T) V36( the carrier of T, REAL ) V145() V146() V147()  continuous   positive-yielding   for    Element of K16(K17( the carrier of T,REAL));
</td><td><span data-href='partfun4.html#RC1'>partfun4</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of T) V5( REAL )  non  empty   Function-like  V32( the carrier of T) V36( the carrier of T, REAL ) V145() V146() V147()  continuous   negative-yielding   for    Element of K16(K17( the carrier of T,REAL));
</td><td><span data-href='partfun4.html#RC2'>partfun4</span></td></tr>
<tr><td>
cluster F . (p,q) ->  Relation-like   Function-like  ;
</td><td><span data-href='partpr_2.html#FC4'>partpr_2</span></td></tr>
<tr><td>
cluster F . (p,q) ->  Relation-like   Function-like  ;
</td><td><span data-href='partpr_2.html#FC5'>partpr_2</span></td></tr>
<tr><td>
cluster F . x ->  Relation-like   Function-like  ;
</td><td><span data-href='partpr_2.html#FC6'>partpr_2</span></td></tr>
<tr><td>
cluster  Function-like   RestFunc-like   ->  total   for    Element of K16(K17(REAL,REAL));
</td><td><span data-href='pdiff_3.html#CC1'>pdiff_3</span></td></tr>
<tr><td>
cluster  Relation-like   REAL m -defined   REAL n -valued   non  empty   Function-like   total  V30( REAL m, REAL n)  Function-yielding   complex-functions-valued   ext-real-functions-valued   real-functions-valued   additive   homogeneous   for    Element of K16(K17((REAL m),(REAL n)));
</td><td><span data-href='pdiff_6.html#RC1'>pdiff_6</span></td></tr>
<tr><td>
cluster  Function-like  V30( REAL m, REAL n)  additive   homogeneous   ->  Lipschitzian   for    Element of K16(K17((REAL m),(REAL n)));
</td><td><span data-href='pdiff_6.html#CC1'>pdiff_6</span></td></tr>
<tr><td>
cluster  Function-like  V30( the carrier of (REAL-NS m), the carrier of (REAL-NS n))  additive   homogeneous   ->  Lipschitzian   for    Element of K16(K17( the carrier of (REAL-NS m), the carrier of (REAL-NS n)));
</td><td><span data-href='pdiff_6.html#CC2'>pdiff_6</span></td></tr>
<tr><td>
cluster V12()  positive   for    Element of [:INT,INT:];
</td><td><span data-href='pells_eq.html#RC1'>pells_eq</span></td></tr>
<tr><td>
cluster p `1  ->  positive   for  Integer;
</td><td><span data-href='pells_eq.html#FC1'>pells_eq</span></td></tr>
<tr><td>
cluster p `2  ->  positive   for  Integer;
</td><td><span data-href='pells_eq.html#FC2'>pells_eq</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   isomorphic   for    Element of  bool [: the carrier of S, the carrier of S:];
</td><td><span data-href='pencil_2.html#RC1'>pencil_2</span></td></tr>
<tr><td>
cluster  Function-like  V28( REAL , REAL )  differentiable   ->  continuous   for    Element of K10(K11(REAL,REAL));
</td><td><span data-href='polydiff.html#CC1'>polydiff</span></td></tr>
<tr><td>
cluster  Function-like   constant  V28( REAL , REAL )  ->  differentiable   for    Element of K10(K11(REAL,REAL));
</td><td><span data-href='polydiff.html#CC2'>polydiff</span></td></tr>
<tr><td>
cluster  Relation-like   Bags n -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   finite-Support   for    Element of  bool [:(Bags n), the carrier of S:];
</td><td><span data-href='polynom1.html#RC3'>polynom1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of L -valued   Function-like   non  empty   total   quasi_total   finite-Support   with_roots   for    Element of K1(K2(NAT, the carrier of L));
</td><td><span data-href='polynom5.html#RC1'>polynom5</span></td></tr>
<tr><td>
cluster  Relation-like   Bags X -defined   the carrier of R -valued   Function-like   quasi_total   non-zero   for    Element of  bool [:(Bags X), the carrier of R:];
</td><td><span data-href='polynom7.html#RC2'>polynom7</span></td></tr>
<tr><td>
cluster  Relation-like   Bags n -defined   the carrier of R -valued   Function-like   quasi_total   finite-Support   non-zero   for    Element of  bool [:(Bags n), the carrier of R:];
</td><td><span data-href='polynom7.html#RC3'>polynom7</span></td></tr>
<tr><td>
cluster  Relation-like   Bags X -defined   the carrier of L -valued   Function-like   quasi_total   monomial-like   for    Element of  bool [:(Bags X), the carrier of L:];
</td><td><span data-href='polynom7.html#RC5'>polynom7</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   monomial-like   ->  finite-Support   for    Element of  bool [:(Bags X), the carrier of L:];
</td><td><span data-href='polynom7.html#CC2'>polynom7</span></td></tr>
<tr><td>
cluster  Relation-like   Bags X -defined   the carrier of L -valued   Function-like   quasi_total   Constant   for    Element of  bool [:(Bags X), the carrier of L:];
</td><td><span data-href='polynom7.html#RC6'>polynom7</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   Constant   ->  monomial-like   for    Element of  bool [:(Bags X), the carrier of L:];
</td><td><span data-href='polynom7.html#CC3'>polynom7</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   Bags n -defined   the carrier of R -valued   Function-like   total  V49( Bags n, the carrier of R)  non-zero   monomial-like   finite-Support   for    Element of  bool [:(Bags n), the carrier of R:];
</td><td><span data-href='polyred.html#RC1'>polyred</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of P -defined   the carrier of Q -valued   Function-like   quasi_total   continuous   for    Element of K19(K20( the carrier of P, the carrier of Q));
</td><td><span data-href='poset_1.html#RC3'>poset_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   continuous   ->  monotone   for    Element of K19(K20( the carrier of P, the carrier of Q));
</td><td><span data-href='poset_1.html#CC2'>poset_1</span></td></tr>
<tr><td>
cluster  uncurry p -> [:(dom p),J:] -defined  ;
</td><td><span data-href='pralg_1.html#FC6'>pralg_1</span></td></tr>
<tr><td>
cluster  uncurry p -> [:(dom p),J:] -defined   total   for [:(dom p),J:] -defined  Function;
</td><td><span data-href='pralg_1.html#FC7'>pralg_1</span></td></tr>
<tr><td>
cluster  ~ X -> [:J,I:] -defined  ;
</td><td><span data-href='pralg_1.html#FC8'>pralg_1</span></td></tr>
<tr><td>
cluster  ~ X -> [:J,I:] -defined   total   for [:J,I:] -defined  Function;
</td><td><span data-href='pralg_1.html#FC9'>pralg_1</span></td></tr>
<tr><td>
cluster  curry f -> X -defined  ;
</td><td><span data-href='pralg_1.html#FC10'>pralg_1</span></td></tr>
<tr><td>
cluster  curry f -> X -defined   total   for X -defined  Function;
</td><td><span data-href='pralg_1.html#FC11'>pralg_1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   total   quasi_total   reflexive   antisymmetric   transitive   well-ordering   being_linear-order   for    Element of  bool [:X,X:];
</td><td><span data-href='pre_poly.html#RC9'>pre_poly</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   NAT  -valued   Function-like   total   quasi_total   complex-valued   ext-real-valued   real-valued   natural-valued   finite-support   for    Element of  bool [:X,NAT:];
</td><td><span data-href='pre_poly.html#RC13'>pre_poly</span></td></tr>
<tr><td>
cluster V7() V10( the carrier of S) V11( the carrier of T) V12() V21( the carrier of S, the carrier of T)  continuous   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='pre_topc.html#RC8'>pre_topc</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   total   reflexive   antisymmetric   connected   transitive   being_linear-order   for    Element of  bool [:X,X:];
</td><td><span data-href='prefer_1.html#RC1'>prefer_1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   RAT  -valued   Function-like  V11() V14( omega ) V18( omega , REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K19(K20(omega,REAL));
</td><td><span data-href='prepower.html#RC1'>prepower</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( bool X)  non  empty   Function-like  V25( NAT ) V29( NAT , bool X) V126()  for    Element of  bool [:NAT,(bool X):];
</td><td><span data-href='prob_4.html#RC1'>prob_4</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5(Si) V5( bool X)  non  empty   Function-like  V25( NAT ) V29( NAT , bool X) V126()  for    Element of  bool [:NAT,(bool X):];
</td><td><span data-href='prob_4.html#RC2'>prob_4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of T -defined   REAL  -valued   Function-like  V31( the carrier of T) V32( the carrier of T, REAL )  complex-valued   ext-real-valued   real-valued   bounded   for    Element of K32(K33( the carrier of T,REAL));
</td><td><span data-href='pscomp_1.html#RC1'>pscomp_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of T -defined   REAL  -valued   Function-like  V31( the carrier of T) V32( the carrier of T, REAL )  complex-valued   ext-real-valued   real-valued   continuous   for    Element of K32(K33( the carrier of T,REAL));
</td><td><span data-href='pscomp_1.html#RC2'>pscomp_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of S -defined   REAL  -valued   Function-like  V31( the carrier of S) V32( the carrier of S, REAL )  complex-valued   ext-real-valued   real-valued   continuous   for    Element of K32(K33( the carrier of S,REAL));
</td><td><span data-href='pscomp_1.html#RC3'>pscomp_1</span></td></tr>
<tr><td>
cluster  Function-like  V32( the carrier of T, REAL )  continuous   ->  with_max   with_min   bounded   for    Element of K32(K33( the carrier of T,REAL));
</td><td><span data-href='pscomp_1.html#CC2'>pscomp_1</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( the carrier of L) V11( the carrier of L)  Function-like  V17( the carrier of L) V21( the carrier of L, the carrier of L)  inflationary   deflationary   monotone   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='quantal1.html#RC9'>quantal1</span></td></tr>
<tr><td>
cluster  Relation-like  Omega1 -defined  Omega2 -valued   non  empty   Function-like   total   quasi_total  S1,S2 -random_variable-like   for    Element of  bool [:Omega1,Omega2:];
</td><td><span data-href='random_3.html#RC1'>random_3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of W -valued   Function-like   quasi_total   additive   homogeneous   for    Element of K16(K17( the carrier of V, the carrier of W));
</td><td><span data-href='ranknull.html#RC2'>ranknull</span></td></tr>
<tr><td>
cluster V1() V4( omega ) V5( the carrier of L)  Function-like  V11()  total  V18( omega , the carrier of L)  finite-Support   zero   for    Element of K19(K20(omega, the carrier of L));
</td><td><span data-href='ratfunc1.html#RC1'>ratfunc1</span></td></tr>
<tr><td>
cluster V1() V4( omega ) V5( the carrier of L)  Function-like  V11()  total  V18( omega , the carrier of L)  finite-Support   non  zero   for    Element of K19(K20(omega, the carrier of L));
</td><td><span data-href='ratfunc1.html#RC2'>ratfunc1</span></td></tr>
<tr><td>
cluster V1() V4( omega ) V5( the carrier of L)  Function-like  V11()  total  V18( omega , the carrier of L)  finite-Support   non  zero   constant   for    Element of K19(K20(omega, the carrier of L));
</td><td><span data-href='ratfunc1.html#RC3'>ratfunc1</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of L)  finite-Support   zero   ->  constant   for    Element of K19(K20(omega, the carrier of L));
</td><td><span data-href='ratfunc1.html#CC3'>ratfunc1</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of L)  finite-Support   non  constant   ->  non  zero   for    Element of K19(K20(omega, the carrier of L));
</td><td><span data-href='ratfunc1.html#CC4'>ratfunc1</span></td></tr>
<tr><td>
cluster V1() V4( omega ) V5( the carrier of L)  Function-like  V11()  total  V18( omega , the carrier of L)  finite-Support   non  constant   for    Element of K19(K20(omega, the carrier of L));
</td><td><span data-href='ratfunc1.html#RC4'>ratfunc1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   INT  -valued  V6()  Function-like  V29( omega ) V33( omega , REAL ) V67() V68() V69()  for    Element of K16(K17(omega,REAL));
</td><td><span data-href='real_3.html#RC1'>real_3</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   strongly_reflexive   for    Element of  bool [:X,X:];
</td><td><span data-href='realalg1.html#RC1'>realalg1</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   totally_connected   for    Element of  bool [:X,X:];
</td><td><span data-href='realalg1.html#RC2'>realalg1</span></td></tr>
<tr><td>
cluster  strongly_reflexive   ->  reflexive   for    Element of  bool [:X,X:];
</td><td><span data-href='realalg1.html#CC1'>realalg1</span></td></tr>
<tr><td>
cluster  totally_connected   ->  strongly_connected   for    Element of  bool [:X,X:];
</td><td><span data-href='realalg1.html#CC2'>realalg1</span></td></tr>
<tr><td>
cluster  strongly_reflexive   ->  non  empty   for    Element of  bool [:X,X:];
</td><td><span data-href='realalg1.html#CC3'>realalg1</span></td></tr>
<tr><td>
cluster  totally_connected   ->  non  empty   for    Element of  bool [:X,X:];
</td><td><span data-href='realalg1.html#CC4'>realalg1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of R -valued   antisymmetric   transitive   strongly_reflexive   respecting_addition   respecting_multiplication   for    Element of  bool [: the carrier of R, the carrier of R:];
</td><td><span data-href='realalg1.html#RC10'>realalg1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of R -valued   antisymmetric   transitive   strongly_reflexive   totally_connected   respecting_addition   respecting_multiplication   for    Element of  bool [: the carrier of R, the carrier of R:];
</td><td><span data-href='realalg1.html#RC11'>realalg1</span></td></tr>
<tr><td>
cluster  Relation-like  [:X,X:] -defined  X -valued   Function-like  V14([:X,X:]) V18([:X,X:],X) A -subsetpreserving   for    Element of  bool [:[:X,X:],X:];
</td><td><span data-href='realset1.html#RC2'>realset1</span></td></tr>
<tr><td>
cluster [:a,b:] ->  Relation-like  ;
</td><td><span data-href='relat_1.html#FC6'>relat_1</span></td></tr>
<tr><td>
cluster   ->  Relation-like   for    Element of  bool [:X,Y:];
</td><td><span data-href='relset_1.html#CC1'>relset_1</span></td></tr>
<tr><td>
cluster   -> X -defined  Y -valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='relset_1.html#CC2'>relset_1</span></td></tr>
<tr><td>
cluster   ->  empty   for    Element of  bool [:A,B:];
</td><td><span data-href='relset_1.html#CC3'>relset_1</span></td></tr>
<tr><td>
cluster   ->  empty   for    Element of  bool [:B,A:];
</td><td><span data-href='relset_1.html#CC4'>relset_1</span></td></tr>
<tr><td>
cluster  dom f ->  Relation-like  ;
</td><td><span data-href='relset_1.html#FC8'>relset_1</span></td></tr>
<tr><td>
cluster  rng f ->  Relation-like  ;
</td><td><span data-href='relset_1.html#FC9'>relset_1</span></td></tr>
<tr><td>
cluster  empty   Relation-like  X -defined  Y -valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='relset_1.html#RC1'>relset_1</span></td></tr>
<tr><td>
cluster  Function-like   non-decreasing   ->  monotone   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC1'>rfunct_2</span></td></tr>
<tr><td>
cluster  Function-like   non-increasing   ->  monotone   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC2'>rfunct_2</span></td></tr>
<tr><td>
cluster  Function-like   non  monotone   ->  non  non-decreasing   non  non-increasing   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC3'>rfunct_2</span></td></tr>
<tr><td>
cluster  Function-like   non-decreasing   non-increasing   -> V8()  for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC4'>rfunct_2</span></td></tr>
<tr><td>
cluster  Function-like  V8()  ->  non-decreasing   non-increasing   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#CC5'>rfunct_2</span></td></tr>
<tr><td>
cluster  Relation-like   REAL  -defined   REAL  -valued   Function-like   trivial   complex-valued   ext-real-valued   real-valued   for    Element of  bool [:REAL,REAL:];
</td><td><span data-href='rfunct_2.html#RC1'>rfunct_2</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined  X -valued   Function-like   non  empty   total   quasi_total   ascending   stagnating   for    Element of  bool [:NAT,X:];
</td><td><span data-href='ring_2.html#RC1'>ring_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   additive   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_2.html#RC2'>ring_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   multiplicative   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_2.html#RC3'>ring_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   unity-preserving   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_2.html#RC4'>ring_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   additive   multiplicative   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_2.html#RC5'>ring_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty   total   quasi_total   additive   unity-preserving   multiplicative   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_2.html#RC12'>ring_2</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   unity-preserving   multiplicative   ->  monomorphism   for    Element of  bool [: the carrier of E, the carrier of F:];
</td><td><span data-href='ring_2.html#CC2'>ring_2</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ascending   ->  stagnating   for    Element of  bool [:NAT,(Ideals R):];
</td><td><span data-href='ring_2.html#CC12'>ring_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty  V14( the carrier of R)  quasi_total   unity-preserving   additive   monomorphism   multiplicative   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_3.html#RC17'>ring_3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R -defined   the carrier of S -valued   Function-like   non  empty  V14( the carrier of R)  quasi_total   unity-preserving   additive   isomorphism   multiplicative   for    Element of  bool [: the carrier of R, the carrier of S:];
</td><td><span data-href='ring_3.html#RC28'>ring_3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of R -valued   Function-like   non  empty  V14( the carrier of S)  quasi_total   unity-preserving   additive   isomorphism   multiplicative   for    Element of  bool [: the carrier of S, the carrier of R:];
</td><td><span data-href='ring_3.html#RC29'>ring_3</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of INT.Ring -defined   the carrier of R -valued   Function-like   non  empty  V14( the carrier of INT.Ring)  quasi_total   unity-preserving   additive   monomorphism   multiplicative   for    Element of  bool [: the carrier of INT.Ring, the carrier of R:];
</td><td><span data-href='ring_3.html#RC31'>ring_3</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of R)  Function-like   non  empty   total   quasi_total   finite-Support   zero   for    Element of  bool [:NAT, the carrier of R:];
</td><td><span data-href='ring_4.html#RC5'>ring_4</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of L)  Function-like   non  empty   total   quasi_total   finite-Support   non  zero   constant   for    Element of  bool [:NAT, the carrier of L:];
</td><td><span data-href='ring_4.html#RC12'>ring_4</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of L)  Function-like   non  empty   total   quasi_total   finite-Support   monic   for    Element of  bool [:NAT, the carrier of L:];
</td><td><span data-href='ring_4.html#RC13'>ring_4</span></td></tr>
<tr><td>
cluster V1() V4( NAT ) V5( the carrier of L)  Function-like   non  empty   total   quasi_total   finite-Support   non  monic   for    Element of  bool [:NAT, the carrier of L:];
</td><td><span data-href='ring_4.html#RC14'>ring_4</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of R)  finite-Support   non  zero   ->  non  zero   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#CC1'>ring_5</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of R)  finite-Support   monic   ->  non  zero   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#CC2'>ring_5</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of R)  finite-Support   non  zero   with_roots   ->  non  constant   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#CC3'>ring_5</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of R)  finite-Support   non  with_roots   ->  non  zero   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#CC4'>ring_5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   the carrier of R -valued   Function-like  V18( omega , the carrier of R)  finite-Support   non  zero   non  with_roots   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#RC2'>ring_5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   the carrier of R -valued   Function-like  V18( omega , the carrier of R)  finite-Support   non  zero   with_roots   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#RC3'>ring_5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   the carrier of R -valued   Function-like  V18( omega , the carrier of R)  finite-Support   non  constant   monic   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#RC4'>ring_5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   the carrier of R -valued   Function-like  V18( omega , the carrier of R)  finite-Support   monic   with_roots   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#RC5'>ring_5</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   the carrier of R -valued   Function-like  V18( omega , the carrier of R)  finite-Support   monic   non  with_roots   for    Element of K19(K20(omega, the carrier of R));
</td><td><span data-href='ring_5.html#RC6'>ring_5</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , the carrier of F)  finite-Support   non  constant   ->  non  constant   with_roots   for    Element of K19(K20(omega, the carrier of F));
</td><td><span data-href='ring_5.html#CC6'>ring_5</span></td></tr>
<tr><td>
cluster V6() V31( the carrier of G, the carrier of H)  linear   ->  unity-preserving   multiplicative   additive   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='ringcat1.html#CC1'>ringcat1</span></td></tr>
<tr><td>
cluster V6() V31( the carrier of G, the carrier of H)  unity-preserving   multiplicative   additive   ->  linear   for    Element of  bool [: the carrier of G, the carrier of H:];
</td><td><span data-href='ringcat1.html#CC2'>ringcat1</span></td></tr>
<tr><td>
cluster  RLTopStruct(# X,O,F,G,T #) ->  non  empty  ;
</td><td><span data-href='rltopsp1.html#FC5'>rltopsp1</span></td></tr>
<tr><td>
cluster  RLSStruct(# ZS,O,F,G #) ->  non  empty  ;
</td><td><span data-href='rlvect_1.html#FC1'>rlvect_1</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool A -defined   bool A -valued   Function-like   total  V29( bool A, bool A)  empty-preserving   universe-preserving   for    Element of  bool [:(bool A),(bool A):];
</td><td><span data-href='roughs_2.html#RC2'>roughs_2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool  the carrier of T -defined   bool  the carrier of T -valued   Function-like   total  V29( bool  the carrier of T, bool  the carrier of T)  closed-valued   for    Element of  bool [:(bool  the carrier of T),(bool  the carrier of T):];
</td><td><span data-href='roughs_2.html#RC3'>roughs_2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool  the carrier of T -defined   bool  the carrier of T -valued   Function-like   total  V29( bool  the carrier of T, bool  the carrier of T)  open-valued   for    Element of  bool [:(bool  the carrier of T),(bool  the carrier of T):];
</td><td><span data-href='roughs_2.html#RC4'>roughs_2</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool A -defined   bool A -valued   Function-like  V25( bool A)  quasi_total   \/-preserving   /\-preserving   for    Element of  bool [:(bool A),(bool A):];
</td><td><span data-href='roughs_3.html#RC1'>roughs_3</span></td></tr>
<tr><td>
cluster  Function-like  V21( bool X, bool X)  \/-preserving   ->  c=-monotone   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='roughs_4.html#CC1'>roughs_4</span></td></tr>
<tr><td>
cluster  Function-like  V21( bool X, bool X)  /\-preserving   ->  c=-monotone   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='roughs_4.html#CC2'>roughs_4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   bool X -defined   bool X -valued   Function-like  V17( bool X) V21( bool X, bool X)  closure   interior   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='roughs_4.html#RC2'>roughs_4</span></td></tr>
<tr><td>
cluster  Function-like  V21( bool X, bool X)  closure   ->  preclosure   for    Element of  bool [:(bool X),(bool X):];
</td><td><span data-href='roughs_4.html#CC3'>roughs_4</span></td></tr>
<tr><td>
cluster  NORMSTR(# X,Z,A,M,N #) ->  non  empty  ;
</td><td><span data-href='rsspace3.html#FC4'>rsspace3</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined   the carrier of Y -valued   non  empty   Function-like  V26(X)  quasi_total   bounded   for    Element of  bool [:X, the carrier of Y:];
</td><td><span data-href='rsspace4.html#RC1'>rsspace4</span></td></tr>
<tr><td>
cluster  Relation-like   empty-yielding   omega  -defined   COMPLEX  -valued   non  empty   Function-like  V32( omega ) V33( omega , COMPLEX )  complex-valued   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#RC1'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   empty-yielding   omega  -defined   REAL  -valued   non  empty   Function-like  V32( omega ) V33( omega , REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K16(K17(omega,REAL));
</td><td><span data-href='rvsum_4.html#RC2'>rvsum_4</span></td></tr>
<tr><td>
cluster  empty-yielding   Function-like  V33( omega , COMPLEX )  ->  natural-valued   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#CC1'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   COMPLEX  -valued   non  empty   Function-like   constant  V32( omega ) V33( omega , COMPLEX )  complex-valued   real-valued   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#RC3'>rvsum_4</span></td></tr>
<tr><td>
cluster  empty-yielding   Function-like  V33( omega , COMPLEX )  ->  absolutely_summable   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#CC2'>rvsum_4</span></td></tr>
<tr><td>
cluster  empty-yielding   Function-like  V33( omega , REAL )  ->  absolutely_summable   for    Element of K16(K17(omega,REAL));
</td><td><span data-href='rvsum_4.html#CC3'>rvsum_4</span></td></tr>
<tr><td>
cluster  Function-like  V33( omega , COMPLEX )  ->  Sequence-like   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#CC4'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   COMPLEX  -valued   non  empty   Function-like  V32( omega ) V33( omega , COMPLEX )  complex-valued   summable   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#RC4'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   empty-yielding   omega  -defined   REAL  -valued   non  empty   Function-like  V32( omega ) V33( omega , REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K16(K17(omega,REAL));
</td><td><span data-href='rvsum_4.html#RC7'>rvsum_4</span></td></tr>
<tr><td>
cluster  Function-like  V33( omega , REAL )  ->  Sequence-like   for    Element of K16(K17(omega,REAL));
</td><td><span data-href='rvsum_4.html#CC5'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   COMPLEX  -valued   non  empty   Sequence-like   Function-like  V32( omega ) V33( omega , COMPLEX )  complex-valued   ext-real-valued   real-valued   summable   for    Element of K16(K17(omega,COMPLEX));
</td><td><span data-href='rvsum_4.html#RC9'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   non-zero   complex-valued   ext-real-valued   real-valued   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seq_1.html#RC1'>seq_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   constant   non  empty   total  V18( NAT , REAL )  complex-valued   ext-real-valued   real-valued   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seq_1.html#RC2'>seq_1</span></td></tr>
<tr><td>
cluster  Function-like   constant  V32( NAT , REAL )  ->  convergent   for    Element of K21(K22(NAT,REAL));
</td><td><span data-href='seq_2.html#CC3'>seq_2</span></td></tr>
<tr><td>
cluster  Function-like  V32( NAT , REAL )  convergent   ->  bounded   for    Element of K21(K22(NAT,REAL));
</td><td><span data-href='seq_2.html#CC4'>seq_2</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , REAL ) V47()  bounded_above   ->  convergent   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='seq_4.html#CC1'>seq_4</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , REAL ) V48()  bounded_below   ->  convergent   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='seq_4.html#CC2'>seq_4</span></td></tr>
<tr><td>
cluster  Function-like  V18( NAT , REAL )  monotone   bounded   ->  convergent   for    Element of  bool [:NAT,REAL:];
</td><td><span data-href='seq_4.html#CC3'>seq_4</span></td></tr>
<tr><td>
cluster  Function-like   constant   ->  non-decreasing   non-increasing   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seqm_3.html#CC1'>seqm_3</span></td></tr>
<tr><td>
cluster  Function-like   non-decreasing   non-increasing   ->  constant   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seqm_3.html#CC2'>seqm_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   REAL  -valued   Function-like   non  empty   total  V18( NAT , REAL )  complex-valued   ext-real-valued   real-valued   natural-valued   increasing   for    Element of K19(K20(NAT,REAL));
</td><td><span data-href='seqm_3.html#RC1'>seqm_3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   NAT  -valued   Function-like   non  empty   total  V18( NAT , NAT )  complex-valued   ext-real-valued   real-valued   natural-valued   increasing   for    Element of K19(K20(NAT,NAT));
</td><td><span data-href='seqm_3.html#RC2'>seqm_3</span></td></tr>
<tr><td>
cluster  Function-like  V18( omega , REAL )  absolutely_summable   ->  summable   for    Element of K19(K20(omega,REAL));
</td><td><span data-href='series_1.html#CC1'>series_1</span></td></tr>
<tr><td>
cluster  StackSystem(# a1,a2,a3,a4,a5,a6 #) ->  non  empty  ;
</td><td><span data-href='stacks_1.html#FC1'>stacks_1</span></td></tr>
<tr><td>
cluster  StackSystem(# a1,a2,a3,a4,a5,a6 #) ->  non  void  ;
</td><td><span data-href='stacks_1.html#FC2'>stacks_1</span></td></tr>
<tr><td>
cluster  CQC-WFF-like   for    Element of [:(QC-Sub-WFF Al),(bound_QC-variables Al):];
</td><td><span data-href='sublemma.html#RC1'>sublemma</span></td></tr>
<tr><td>
cluster [:X1,X2:] ->  non  empty  ;
</td><td><span data-href='subset_1.html#FC10'>subset_1</span></td></tr>
<tr><td>
cluster  Function-like  V18(X,Y)  bounded   ->  bounded_above   bounded_below   for    Element of K19(K20(X,Y));
</td><td><span data-href='supinf_2.html#CC1'>supinf_2</span></td></tr>
<tr><td>
cluster  Function-like  V18(X,Y)  bounded_above   bounded_below   ->  bounded   for    Element of K19(K20(X,Y));
</td><td><span data-href='supinf_2.html#CC2'>supinf_2</span></td></tr>
<tr><td>
cluster  SymStr(# X,md,o,mF,mo #) ->  non  empty  ;
</td><td><span data-href='symsp_1.html#FC1'>symsp_1</span></td></tr>
<tr><td>
cluster  Function-like  V35( omega , the carrier of M)  convergent   ->  Cauchy   for    Element of K10(K11(omega, the carrier of M));
</td><td><span data-href='tbsp_1.html#CC1'>tbsp_1</span></td></tr>
<tr><td>
cluster  Relation-like   Bags n -defined   Bags n -valued   total  V18( Bags n, Bags n)  reflexive   antisymmetric   connected   transitive   admissible   for    Element of K19(K20((Bags n),(Bags n)));
</td><td><span data-href='termord.html#RC3'>termord</span></td></tr>
<tr><td>
cluster  total   reflexive   antisymmetric   transitive   admissible   ->  well_founded   admissible   for    Element of K19(K20((Bags n),(Bags n)));
</td><td><span data-href='termord.html#CC1'>termord</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   NAT  -defined   REAL  -valued   Function-like   constant   total   quasi_total   complex-valued   ext-real-valued   real-valued   summable   convergent   for    Element of K10(K11(NAT,REAL));
</td><td><span data-href='tietze.html#RC1'>tietze</span></td></tr>
<tr><td>
cluster  Function-like   constant   quasi_total   ->  continuous   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='topalg_6.html#CC1'>topalg_6</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of R^1 -defined   the carrier of T -valued   Function-like   parametrized-curve   for    Element of  bool [: the carrier of R^1, the carrier of T:];
</td><td><span data-href='topalg_6.html#RC2'>topalg_6</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   Function-like   one-to-one  V14(X)  quasi_total   onto   for    Element of  bool [:X,X:];
</td><td><span data-href='topgrp_1.html#RC1'>topgrp_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   being_homeomorphism   ->  one-to-one   onto   continuous   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='topgrp_1.html#CC2'>topgrp_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   being_homeomorphism   ->  open   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='topgrp_1.html#CC3'>topgrp_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of T -defined   the carrier of T -valued   Function-like  V14( the carrier of T)  quasi_total   being_homeomorphism   for    Element of  bool [: the carrier of T, the carrier of T:];
</td><td><span data-href='topgrp_1.html#RC4'>topgrp_1</span></td></tr>
<tr><td>
cluster V1() V21() V30( the carrier of (TOP-REAL n), the carrier of (TOP-REAL n))  continuous   additive   homogeneous   for    Element of K16(K17( the carrier of (TOP-REAL n), the carrier of (TOP-REAL n)));
</td><td><span data-href='topreal9.html#RC1'>topreal9</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  continuous   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='topreala.html#CC3'>topreala</span></td></tr>
<tr><td>
cluster  Function-like   empty   quasi_total   ->  continuous   for    Element of  bool [: the carrier of X, the carrier of Y:];
</td><td><span data-href='topreala.html#CC4'>topreala</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   the carrier of T -defined   the carrier of R^1 -valued   Function-like   non  empty   total  V18( the carrier of T, the carrier of R^1)  complex-valued   ext-real-valued   real-valued   continuous   for    Element of  bool [: the carrier of T, the carrier of R^1:];
</td><td><span data-href='toprealc.html#RC3'>toprealc</span></td></tr>
<tr><td>
cluster  Relation-like   non  empty   for    Element of  bool [:a,b:];
</td><td><span data-href='trees_2.html#RC9'>trees_2</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   ->  DecoratedTree-like   for    Element of  bool [:T,D:];
</td><td><span data-href='trees_3.html#CC12'>trees_3</span></td></tr>
<tr><td>
cluster <:T1,T2:> -> [:D1,D2:] -valued  ;
</td><td><span data-href='trees_3.html#FC20'>trees_3</span></td></tr>
<tr><td>
cluster   ->  Relation-like   for    Element of cB;
</td><td><span data-href='uniform2.html#CC1'>uniform2</span></td></tr>
<tr><td>
cluster  non  empty   cap-closed   ->  non  empty   quasi_basis   for    Element of  bool (bool [:X,X:]);
</td><td><span data-href='uniform2.html#CC7'>uniform2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of US1 -defined   the carrier of US2 -valued   Function-like  V31( the carrier of US1, the carrier of US2)  uniformly_continuous   for    Element of  bool [: the carrier of US1, the carrier of US2:];
</td><td><span data-href='uniform3.html#RC3'>uniform3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the carrier of L -valued   Function-like   non  empty   total   quasi_total   finite-Support   non-zero   for    Element of  bool [:NAT, the carrier of L:];
</td><td><span data-href='uproots.html#RC1'>uproots</span></td></tr>
<tr><td>
cluster   ->  complex-valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='valued_0.html#CC16'>valued_0</span></td></tr>
<tr><td>
cluster   ->  ext-real-valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='valued_0.html#CC17'>valued_0</span></td></tr>
<tr><td>
cluster   ->  real-valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='valued_0.html#CC18'>valued_0</span></td></tr>
<tr><td>
cluster   ->  RAT  -valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='valued_0.html#CC19'>valued_0</span></td></tr>
<tr><td>
cluster   ->  INT  -valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='valued_0.html#CC20'>valued_0</span></td></tr>
<tr><td>
cluster   ->  natural-valued   for    Element of  bool [:X,Y:];
</td><td><span data-href='valued_0.html#CC21'>valued_0</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  complex-valued  ;
</td><td><span data-href='valued_0.html#FC85'>valued_0</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  ext-real-valued  ;
</td><td><span data-href='valued_0.html#FC86'>valued_0</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  real-valued  ;
</td><td><span data-href='valued_0.html#FC87'>valued_0</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  RAT  -valued  ;
</td><td><span data-href='valued_0.html#FC88'>valued_0</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  INT  -valued  ;
</td><td><span data-href='valued_0.html#FC89'>valued_0</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  natural-valued  ;
</td><td><span data-href='valued_0.html#FC90'>valued_0</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   NAT  -valued   Function-like   non  empty   total   quasi_total   complex-valued   ext-real-valued   real-valued   natural-valued   increasing   for    Element of  bool [:omega,NAT:];
</td><td><span data-href='valued_0.html#RC3'>valued_0</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined  X -valued   Function-like   constant   quasi_total   for    Element of  bool [:omega,X:];
</td><td><span data-href='valued_0.html#RC4'>valued_0</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   omega  -defined  X -valued   Function-like   non  empty   total   quasi_total   for    Element of  bool [:omega,X:];
</td><td><span data-href='valued_0.html#RC5'>valued_0</span></td></tr>
<tr><td>
cluster  Function-like   ->  complex-functions-valued   for    Element of K19(K20(X,Y));
</td><td><span data-href='valued_2.html#CC28'>valued_2</span></td></tr>
<tr><td>
cluster  Function-like   ->  ext-real-functions-valued   for    Element of K19(K20(X,Y));
</td><td><span data-href='valued_2.html#CC29'>valued_2</span></td></tr>
<tr><td>
cluster  Function-like   ->  real-functions-valued   for    Element of K19(K20(X,Y));
</td><td><span data-href='valued_2.html#CC30'>valued_2</span></td></tr>
<tr><td>
cluster  Function-like   ->  rational-functions-valued   for    Element of K19(K20(X,Y));
</td><td><span data-href='valued_2.html#CC31'>valued_2</span></td></tr>
<tr><td>
cluster  Function-like   ->  integer-functions-valued   for    Element of K19(K20(X,Y));
</td><td><span data-href='valued_2.html#CC32'>valued_2</span></td></tr>
<tr><td>
cluster  Function-like   ->  natural-functions-valued   for    Element of K19(K20(X,Y));
</td><td><span data-href='valued_2.html#CC33'>valued_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of V -valued   non  empty   Function-like   total   quasi_total   onto   isometric   for    Element of  bool [: the carrier of V, the carrier of V:];
</td><td><span data-href='vectmetr.html#RC2'>vectmetr</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   isometric   ->  one-to-one   for    Element of  bool [: the carrier of V, the carrier of V:];
</td><td><span data-href='vectmetr.html#CC2'>vectmetr</span></td></tr>
<tr><td>
cluster  RLSMetrStruct(# X,F,O,B,G #) ->  non  empty  ;
</td><td><span data-href='vectmetr.html#FC5'>vectmetr</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of K)  Function-like   non  empty  V14( the carrier of V)  quasi_total   additive   0-preserving   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#RC5'>vectsp10</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#CC1'>vectsp10</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#CC2'>vectsp10</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of K)  Function-like   constant   non  empty  V14( the carrier of V)  quasi_total   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#RC6'>vectsp10</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of K)  Function-like   constant   non  empty  V14( the carrier of V)  quasi_total   additive   0-preserving   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#RC7'>vectsp10</span></td></tr>
<tr><td>
cluster V1() V4( the carrier of V) V5( the carrier of K)  Function-like   non  constant   non  empty   non  trivial  V14( the carrier of V)  quasi_total   additive   homogeneous   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#RC8'>vectsp10</span></td></tr>
<tr><td>
cluster  Function-like   trivial   quasi_total   ->  constant   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#CC3'>vectsp10</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   0-preserving   non  degenerated   ->  non  constant   for    Element of  bool [: the carrier of V, the carrier of K:];
</td><td><span data-href='vectsp10.html#CC4'>vectsp10</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of V -valued   Function-like   non  empty   total   quasi_total   additive   homogeneous   with_eigenvalues   for    Element of  bool [: the carrier of V, the carrier of V:];
</td><td><span data-href='vectsp11.html#RC2'>vectsp11</span></td></tr>
<tr><td>
cluster  ModuleStr(# A,a,Z,l #) ->  non  empty  ;
</td><td><span data-href='vectsp_1.html#FC9'>vectsp_1</span></td></tr>
<tr><td>
cluster  RightModStr(# A,a,Z,r #) ->  non  empty  ;
</td><td><span data-href='vectsp_2.html#FC1'>vectsp_2</span></td></tr>
<tr><td>
cluster  BiModStr(# A,a,Z,l,r #) ->  non  empty  ;
</td><td><span data-href='vectsp_2.html#FC2'>vectsp_2</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like  V24( the carrier of S)  quasi_total   monotone   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel10.html#RC1'>waybel10</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   projection   ->  idempotent   monotone   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel10.html#CC1'>waybel10</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L -defined   the carrier of L -valued   Function-like  V7()  non  empty  V24( the carrier of L)  quasi_total   infs-preserving   sups-preserving   closure   kernel   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel10.html#RC2'>waybel10</span></td></tr>
<tr><td>
cluster  Function-like  V21( the carrier of L1, the carrier of L2)  isomorphic   ->  infs-preserving   sups-preserving   for    Element of K32(K33( the carrier of L1, the carrier of L2));
</td><td><span data-href='waybel13.html#CC1'>waybel13</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   directed-sups-preserving   ->  monotone   for    Element of K32(K33( the carrier of S, the carrier of T));
</td><td><span data-href='waybel17.html#CC1'>waybel17</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   continuous   ->  monotone   for    Element of K32(K33( the carrier of S, the carrier of T));
</td><td><span data-href='waybel17.html#CC2'>waybel17</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   continuous   ->  directed-sups-preserving   for    Element of K32(K33( the carrier of S, the carrier of T));
</td><td><span data-href='waybel17.html#CC3'>waybel17</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   directed-sups-preserving   ->  continuous   for    Element of K32(K33( the carrier of S, the carrier of T));
</td><td><span data-href='waybel17.html#CC4'>waybel17</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of L -defined   the carrier of L -valued   Function-like  V17( the carrier of L) V28( the carrier of L, the carrier of L)  directed-sups-preserving   kernel   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel20.html#RC1'>waybel20</span></td></tr>
<tr><td>
cluster  Function-like  V29( the carrier of S, the carrier of T)  meet-preserving   ->  monotone   for    Element of K22(K23( the carrier of S, the carrier of T));
</td><td><span data-href='waybel21.html#CC1'>waybel21</span></td></tr>
<tr><td>
cluster  Function-like   constant   quasi_total   ->  monotone   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel24.html#CC1'>waybel24</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like  V14( the carrier of S)  quasi_total   antitone   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel24.html#RC1'>waybel24</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   continuous   ->  monotone   for    Element of  bool [: the carrier of (Omega X), the carrier of (Omega Y):];
</td><td><span data-href='waybel25.html#CC3'>waybel25</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   continuous   ->  directed-sups-preserving   for    Element of  bool [: the carrier of (Omega X), the carrier of (Omega Y):];
</td><td><span data-href='waybel25.html#CC9'>waybel25</span></td></tr>
<tr><td>
cluster  Relation-like   Funcs ([:X,Y:],Z) -defined   Function-like  V27( Funcs ([:X,Y:],Z))  currying   for    set ;
</td><td><span data-href='waybel27.html#RC3'>waybel27</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of N -defined   the carrier of N -valued   Function-like  V37( the carrier of N) V38( the carrier of N, the carrier of N)  greater_or_equal_to_id   for    Element of  bool [: the carrier of N, the carrier of N:];
</td><td><span data-href='waybel28.html#RC1'>waybel28</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of N -defined   the carrier of N -valued   Function-like  V37( the carrier of N) V38( the carrier of N, the carrier of N)  greater_or_equal_to_id   for    Element of  bool [: the carrier of N, the carrier of N:];
</td><td><span data-href='waybel28.html#RC2'>waybel28</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like   non  empty  V22( the carrier of S)  quasi_total   infs-preserving   directed-sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#RC2'>waybel34</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like   non  empty  V22( the carrier of S)  quasi_total   sups-preserving   filtered-infs-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#RC3'>waybel34</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   sups-preserving   ->  bottom-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#CC1'>waybel34</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like   non  empty  V22( the carrier of S)  quasi_total   sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#RC4'>waybel34</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   sups-preserving   ->  finite-sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#CC6'>waybel34</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   finite-sups-preserving   ->  join-preserving   bottom-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#CC7'>waybel34</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like   non  empty  V22( the carrier of S)  quasi_total   sups-preserving   finite-sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel34.html#RC6'>waybel34</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L -defined   the carrier of L -valued   auxiliary(i)   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#RC1'>waybel35</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L -defined   the carrier of L -valued   auxiliary(i)   auxiliary(ii)   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#RC2'>waybel35</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L -defined   the carrier of L -valued   auxiliary(iii)   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#RC3'>waybel35</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L -defined   the carrier of L -valued   auxiliary(iv)   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#RC4'>waybel35</span></td></tr>
<tr><td>
cluster  extra-order   ->  auxiliary(i)   auxiliary(ii)   auxiliary(iv)   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#CC1'>waybel35</span></td></tr>
<tr><td>
cluster  auxiliary(i)   auxiliary(ii)   auxiliary(iv)   ->  extra-order   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#CC2'>waybel35</span></td></tr>
<tr><td>
cluster  auxiliary(iii)   extra-order   ->  auxiliary   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#CC3'>waybel35</span></td></tr>
<tr><td>
cluster  auxiliary   ->  extra-order   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#CC4'>waybel35</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of L -defined   the carrier of L -valued   extra-order   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel35.html#RC5'>waybel35</span></td></tr>
<tr><td>
cluster  Function-like  V21( the carrier of L1, the carrier of L2)  infs-preserving   ->  meet-preserving   filtered-infs-preserving   for    Element of K10(K11( the carrier of L1, the carrier of L2));
</td><td><span data-href='waybel_0.html#CC7'>waybel_0</span></td></tr>
<tr><td>
cluster  Function-like  V21( the carrier of L1, the carrier of L2)  sups-preserving   ->  join-preserving   directed-sups-preserving   for    Element of K10(K11( the carrier of L1, the carrier of L2));
</td><td><span data-href='waybel_0.html#CC8'>waybel_0</span></td></tr>
<tr><td>
cluster  Function-like  V21( the carrier of S, the carrier of T)  isomorphic   ->  one-to-one   monotone   for    Element of K10(K11( the carrier of S, the carrier of T));
</td><td><span data-href='waybel_0.html#CC9'>waybel_0</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   upper_adjoint   ->  infs-preserving   for   M3( bool [: the carrier of S, the carrier of T:]);
</td><td><span data-href='waybel_1.html#CC1'>waybel_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   lower_adjoint   ->  sups-preserving   for   M3( bool [: the carrier of S, the carrier of T:]);
</td><td><span data-href='waybel_1.html#CC2'>waybel_1</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( the carrier of L) V11( the carrier of L)  Function-like  V27( the carrier of L)  quasi_total   projection   for   M3( bool [: the carrier of L, the carrier of L:]);
</td><td><span data-href='waybel_1.html#RC1'>waybel_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   closure   ->  projection   for   M3( bool [: the carrier of L, the carrier of L:]);
</td><td><span data-href='waybel_1.html#CC3'>waybel_1</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( the carrier of L) V11( the carrier of L)  Function-like  V27( the carrier of L)  quasi_total   closure   for   M3( bool [: the carrier of L, the carrier of L:]);
</td><td><span data-href='waybel_1.html#RC2'>waybel_1</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   kernel   ->  projection   for   M3( bool [: the carrier of L, the carrier of L:]);
</td><td><span data-href='waybel_1.html#CC4'>waybel_1</span></td></tr>
<tr><td>
cluster  non  empty  V7() V10( the carrier of L) V11( the carrier of L)  Function-like  V27( the carrier of L)  quasi_total   kernel   for   M3( bool [: the carrier of L, the carrier of L:]);
</td><td><span data-href='waybel_1.html#RC3'>waybel_1</span></td></tr>
<tr><td>
cluster  auxiliary   ->  auxiliary(i)   auxiliary(ii)   auxiliary(iii)   auxiliary(iv)   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#CC1'>waybel_4</span></td></tr>
<tr><td>
cluster  auxiliary(i)   auxiliary(ii)   auxiliary(iii)   auxiliary(iv)   ->  auxiliary   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#CC2'>waybel_4</span></td></tr>
<tr><td>
cluster  Relation-like   auxiliary   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#RC1'>waybel_4</span></td></tr>
<tr><td>
cluster  auxiliary(i)   auxiliary(ii)   ->  transitive   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#CC3'>waybel_4</span></td></tr>
<tr><td>
cluster  Relation-like   auxiliary   approximating   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#RC2'>waybel_4</span></td></tr>
<tr><td>
cluster  satisfying_SI   ->  satisfying_INT   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#CC5'>waybel_4</span></td></tr>
<tr><td>
cluster  auxiliary   approximating   satisfying_INT   ->  auxiliary   approximating   satisfying_SI   for    Element of  bool [: the carrier of L, the carrier of L:];
</td><td><span data-href='waybel_4.html#CC6'>waybel_4</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like  V35( the carrier of S, the carrier of T)  sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='waybel_6.html#RC2'>waybel_6</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   isomorphic   ->  onto   for    Element of K6(K7( the carrier of S, the carrier of T));
</td><td><span data-href='yellow14.html#CC2'>yellow14</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like   non  empty  V24( the carrier of S)  quasi_total   monotone   directed-sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='yellow16.html#RC1'>yellow16</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of S -defined   the carrier of S -valued   Function-like  V24( the carrier of S)  quasi_total   idempotent   for    Element of  bool [: the carrier of S, the carrier of S:];
</td><td><span data-href='yellow16.html#RC2'>yellow16</span></td></tr>
<tr><td>
cluster  Relation-like  X -defined  X -valued   well-ordering   reflexive   antisymmetric   transitive  V24(X)  quasi_total   upper-bounded   for    Element of  bool [:X,X:];
</td><td><span data-href='yellow21.html#RC4'>yellow21</span></td></tr>
<tr><td>
cluster [:D1,D2:] ->  directed   for  Subset of [:S1,S2:];
</td><td><span data-href='yellow_3.html#FC9'>yellow_3</span></td></tr>
<tr><td>
cluster [:D1,D2:] ->  filtered   for  Subset of [:S1,S2:];
</td><td><span data-href='yellow_3.html#FC10'>yellow_3</span></td></tr>
<tr><td>
cluster [:D1,D2:] ->  upper   for  Subset of [:S1,S2:];
</td><td><span data-href='yellow_3.html#FC11'>yellow_3</span></td></tr>
<tr><td>
cluster [:D1,D2:] ->  lower   for  Subset of [:S1,S2:];
</td><td><span data-href='yellow_3.html#FC12'>yellow_3</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like  V27( the carrier of S)  quasi_total   infs-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='yellow_9.html#RC2'>yellow_9</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like   the carrier of S -defined   the carrier of T -valued   Function-like  V27( the carrier of S)  quasi_total   sups-preserving   for    Element of  bool [: the carrier of S, the carrier of T:];
</td><td><span data-href='yellow_9.html#RC3'>yellow_9</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  empty  ;
</td><td><span data-href='zfmisc_1.html#FC2'>zfmisc_1</span></td></tr>
<tr><td>
cluster [:X,Y:] ->  empty  ;
</td><td><span data-href='zfmisc_1.html#FC3'>zfmisc_1</span></td></tr>
<tr><td>
cluster [:A,B:] ->  trivial  ;
</td><td><span data-href='zfmisc_1.html#FC4'>zfmisc_1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   non  empty   total   quasi_total  V53() V54() V55()  additive   homogeneous   0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC3'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   non  empty   total   quasi_total  V53() V54() V55()  additive   0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC4'>zmatrlin</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   additive   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#CC1'>zmatrlin</span></td></tr>
<tr><td>
cluster  Function-like   quasi_total   homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#CC2'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   constant   non  empty   total   quasi_total  V53() V54() V55()  for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC5'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   constant   non  empty   total   quasi_total  V53() V54() V55()  additive   0-preserving   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC6'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of INT.Ring -valued   Function-like   non  constant   non  empty   non  trivial   total   quasi_total  V53() V54() V55()  additive   homogeneous   for    Element of  bool [: the carrier of V, the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC7'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of INT.Ring -valued   Function-like   non  empty   total   quasi_total  V53() V54() V55()  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC8'>zmatrlin</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of INT.Ring -valued   Function-like   non  constant   non  empty   non  trivial   total   quasi_total  V53() V54() V55()  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of INT.Ring:];
</td><td><span data-href='zmatrlin.html#RC9'>zmatrlin</span></td></tr>
<tr><td>
cluster  LatticeStr(# D,a,Z,m,s #) ->  non  empty  ;
</td><td><span data-href='zmodlat1.html#FC1'>zmodlat1</span></td></tr>
<tr><td>
cluster  GenLat (V,sc) ->  non  empty   right_complementable   vector-distributive   scalar-distributive   scalar-associative   scalar-unital   Abelian   add-associative   right_zeroed  ;
</td><td><span data-href='zmodlat1.html#FC2'>zmodlat1</span></td></tr>
<tr><td>
cluster  GenLat (V,sc) ->  non  empty   free  ;
</td><td><span data-href='zmodlat1.html#FC3'>zmodlat1</span></td></tr>
<tr><td>
cluster  GenLat (V,sc) ->  non  empty   finite-rank  ;
</td><td><span data-href='zmodlat1.html#FC4'>zmodlat1</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, the carrier of F_Real)  homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#CC3'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of F_Real -valued   Function-like   non  empty   total  V18( the carrier of V, the carrier of F_Real) V71() V72() V73()  additive   homogeneous   0-preserving   for    Element of  bool [: the carrier of V, the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC14'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of F_Real -valued   Function-like   non  empty   total  V18([: the carrier of V, the carrier of W:], the carrier of F_Real) V71() V72() V73()  additiveFAF   additiveSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC15'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of F_Real -valued   Function-like   non  empty   total  V18([: the carrier of V, the carrier of W:], the carrier of F_Real) V71() V72() V73()  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC16'>zmodlat1</span></td></tr>
<tr><td>
cluster  Function-like  V18( the carrier of V, the carrier of F_Real)  homogeneous   ->  0-preserving   for    Element of  bool [: the carrier of V, the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#CC4'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of F_Real -valued   Function-like   non  empty   total  V18( the carrier of V, the carrier of F_Real) V71() V72() V73()  additive   homogeneous   0-preserving   for    Element of  bool [: the carrier of V, the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC17'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like   the carrier of V -defined   the carrier of F_Real -valued   Function-like   non  constant   non  empty   non  trivial   total  V18( the carrier of V, the carrier of F_Real) V71() V72() V73()  additive   homogeneous   for    Element of  bool [: the carrier of V, the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC18'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of W:] -defined   the carrier of F_Real -valued   Function-like   non  constant   non  empty   non  trivial   total  V18([: the carrier of V, the carrier of W:], the carrier of F_Real) V71() V72() V73()  additiveFAF   additiveSAF   homogeneousFAF   homogeneousSAF   for    Element of  bool [:[: the carrier of V, the carrier of W:], the carrier of F_Real:];
</td><td><span data-href='zmodlat1.html#RC19'>zmodlat1</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of F_Real -valued   Function-like   non  empty   total   quasi_total  V71() V72() V73()  symmetric   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Real:];
</td><td><span data-href='zmodlat2.html#RC2'>zmodlat2</span></td></tr>
<tr><td>
cluster  Relation-like  [: the carrier of V, the carrier of V:] -defined   the carrier of F_Real -valued   Function-like   non  empty   total   quasi_total  V71() V72() V73() V252(V,V) V253(V,V) V254(V,V) V255(V,V)  symmetric   for    Element of  bool [:[: the carrier of V, the carrier of V:], the carrier of F_Real:];
</td><td><span data-href='zmodlat2.html#RC3'>zmodlat2</span></td></tr>
<tr><td>
cluster [: the carrier of V,(INT \ {0}):] ->  non  empty  ;
</td><td><span data-href='zmodul04.html#FC1'>zmodul04</span></td></tr>
</tbody>
</table>
</div>
<div class='related-reduce'>
<table class='pure-table'>
<thead><tr><th colspan='2'>reduce</th></tr></thead>
<tbody>
<tr><td>
reduce  proj1 [:X,Y:] to X;
</td><td><span data-href='fomodel0.html#RD3'>fomodel0</span></td></tr>
<tr><td>
reduce  proj2 [:Y,X:] to X;
</td><td><span data-href='fomodel0.html#RD4'>fomodel0</span></td></tr>
<tr><td>
reduce  In ([n,k],[:NAT,NAT:]) to [n,k];
</td><td><span data-href='pre_ff.html#RD1'>pre_ff</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM30581'>
<h2>31.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='zfmisc_1.html#K3'>zfmisc_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X1</font>, <font color="Maroon" title="c2">X2</font>, <font color="Maroon" title="c3">X3</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K3"><span class="kw">func</span> </a><span class="p1"><span title="ZFMISC_1:func.3" data-link="395.html#ELM30581">[:</span><span class="default"><font color="Maroon" title="c1">X1</font>,<font color="Maroon" title="c2">X2</font>,<font color="Maroon" title="c3">X3</font></span><span title="ZFMISC_1:func.3" data-link="395.html#ELM30581">:]</span></span><span class="kw"> -&gt; </span>   <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> <span class="kw"> equals </span><a name="D3"><span class="comment"><font color="firebrick">:: ZFMISC_1:def 3</font></span><br></a><span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><span class="p2"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><font color="Maroon" title="c1">X1</font>,<font color="Maroon" title="c2">X2</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>,<font color="Maroon" title="c3">X3</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>;<br>
</div>
<span class="kw">coherence</span> <br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster [:A,B,C:] ->  finite  ;
</td><td><span data-href='finset_1.html#FC15'>finset_1</span></td></tr>
<tr><td>
cluster   ->  triple   for    Element of [:X1,X2,X3:];
</td><td><span data-href='mcart_1.html#CC2'>mcart_1</span></td></tr>
<tr><td>
cluster F . (p,f,g) ->  Relation-like   Function-like  ;
</td><td><span data-href='partpr_2.html#FC8'>partpr_2</span></td></tr>
<tr><td>
cluster F . [p,f,g] ->  Relation-like   Function-like  ;
</td><td><span data-href='partpr_2.html#FC9'>partpr_2</span></td></tr>
<tr><td>
cluster F . (p,f,q) ->  Relation-like   Function-like  ;
</td><td><span data-href='partpr_2.html#FC10'>partpr_2</span></td></tr>
<tr><td>
cluster F . [p,f,q] ->  Relation-like   Function-like  ;
</td><td><span data-href='partpr_2.html#FC11'>partpr_2</span></td></tr>
<tr><td>
cluster F . (p,f,g) ->  Relation-like   Function-like  ;
</td><td><span data-href='partpr_2.html#FC12'>partpr_2</span></td></tr>
<tr><td>
cluster [:X1,X2,X3:] ->  non  empty  ;
</td><td><span data-href='subset_1.html#FC11'>subset_1</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM30582'>
<h2>32.   <span data-link='395.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='zfmisc_1.html#K4'>zfmisc_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">X1</font>, <font color="Maroon" title="c2">X2</font>, <font color="Maroon" title="c3">X3</font>, <font color="Maroon" title="c4">X4</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><div about="#D0" typeof="oo:Definition" class="main-sentence">
<a name="K4"><span class="kw">func</span> </a><span class="p1"><span title="ZFMISC_1:func.4" data-link="395.html#ELM30582">[:</span><span class="default"><font color="Maroon" title="c1">X1</font>,<font color="Maroon" title="c2">X2</font>,<font color="Maroon" title="c3">X3</font>,<font color="Maroon" title="c4">X4</font></span><span title="ZFMISC_1:func.4" data-link="395.html#ELM30582">:]</span></span><span class="kw"> -&gt; </span>   <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> <span class="kw"> equals </span><a name="D4"><span class="comment"><font color="firebrick">:: ZFMISC_1:def 4</font></span><br></a><span class="p1"><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">[:</span><span class="default"><span class="p2"><span title="ZFMISC_1:func.3" data-link="395.html#ELM30581">[:</span><span class="default"><font color="Maroon" title="c1">X1</font>,<font color="Maroon" title="c2">X2</font>,<font color="Maroon" title="c3">X3</font></span><span title="ZFMISC_1:func.3" data-link="395.html#ELM30581">:]</span></span>,<font color="Maroon" title="c4">X4</font></span><span title="ZFMISC_1:func.2" data-link="395.html#ELM30580">:]</span></span>;<br>
</div>
<span class="kw">coherence</span> <br>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster [:A,B,C,D:] ->  finite  ;
</td><td><span data-href='finset_1.html#FC16'>finset_1</span></td></tr>
<tr><td>
cluster   ->  quadruple   for    Element of [:X1,X2,X3,X4:];
</td><td><span data-href='mcart_1.html#CC3'>mcart_1</span></td></tr>
<tr><td>
cluster [:X1,X2,X3,X4:] ->  non  empty  ;
</td><td><span data-href='subset_1.html#FC12'>subset_1</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
</body>
</html>
