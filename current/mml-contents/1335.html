<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<title>-element</title>
</head>
<body>
<div class='mml-summary'>
<h1>attr -element</h1>
<h2>List of Definitions (2)</h2>
<ol>
<li><span data-link='1335.html#ELM3240'>-element</span> [<span data-href='card_1.html#V3'>card_1</span>]</li>
<li><span data-link='1335.html#ELM25781'>-element</span> [<span data-href='struct_0.html#V13'>struct_0</span>]</li>
</ol>
</div>
<div class='mml-element' id='ELM3240'>
<h2>1.   <span data-link='1335.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='card_1.html#V3'>card_1</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">N</font> be    <span title="HIDDEN:mode.1" data-link="4140.html#ELM11935">object</span> ;<br><span class="kw">let </span><font color="Maroon" title="c2">X</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><div about="#D49" typeof="oo:Definition" class="main-sentence">
<a name="V3"><span class="kw">attr</span> </a><font color="Maroon" title="c2">X</font> is <font color="Maroon" title="c1">N</font> <span title="CARD_1:attr.3" data-link="1335.html#ELM3240">-element</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E49">Def6</font></span>: <a name="D7"><span class="comment"><font color="firebrick">:: CARD_1:def 7</font></span><br></a> <span title="CARD_1:func.1" data-link="1329.html#ELM3233">card</span> <font color="Maroon" title="c2">X</font> <span title="HIDDEN:pred.1" data-link="1122.html#ELM11932">=</span> <font color="Maroon" title="c1">N</font>;<br>
</div>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster <%x%> -> 1 -element  ;
</td><td><span data-href='afinsq_1.html#FC14'>afinsq_1</span></td></tr>
<tr><td>
cluster <%x,y%> -> 2 -element  ;
</td><td><span data-href='afinsq_1.html#FC15'>afinsq_1</span></td></tr>
<tr><td>
cluster <%x,y,z%> -> 3 -element  ;
</td><td><span data-href='afinsq_1.html#FC16'>afinsq_1</span></td></tr>
<tr><td>
cluster  Relation-like   Sequence-like   Function-like   finite  n -element   -> n -defined   for    set ;
</td><td><span data-href='afinsq_1.html#CC2'>afinsq_1</span></td></tr>
<tr><td>
cluster  Relation-like   Sequence-like   Function-like   finite  n -element   for    set ;
</td><td><span data-href='afinsq_1.html#RC4'>afinsq_1</span></td></tr>
<tr><td>
cluster  Relation-like  n -defined   Sequence-like   Function-like   finite  n -element   -> n -defined   total  n -element   for    set ;
</td><td><span data-href='afinsq_1.html#CC3'>afinsq_1</span></td></tr>
<tr><td>
cluster  JUMP (SCM-goto i1) -> 1 -element  ;
</td><td><span data-href='ami_6.html#FC12'>ami_6</span></td></tr>
<tr><td>
cluster  JUMP (a =0_goto i1) -> 1 -element  ;
</td><td><span data-href='ami_6.html#FC13'>ami_6</span></td></tr>
<tr><td>
cluster  JUMP (a >0_goto i1) -> 1 -element  ;
</td><td><span data-href='ami_6.html#FC14'>ami_6</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the InstructionsF of S -valued   Function-like   finite  1 -element   countable  V107()  lower   for    set ;
</td><td><span data-href='ami_wstd.html#RC2'>ami_wstd</span></td></tr>
<tr><td>
cluster <*a1,a2,a3,a4,a5,a6*> -> 6 -element  ;
</td><td><span data-href='aofa_a00.html#FC3'>aofa_a00</span></td></tr>
<tr><td>
cluster <*a1,a2,a3,a4,a5,a6,a7*> -> 7 -element  ;
</td><td><span data-href='aofa_a00.html#FC4'>aofa_a00</span></td></tr>
<tr><td>
cluster <*a1,a2,a3,a4,a5,a6,a7,a8*> -> 8 -element  ;
</td><td><span data-href='aofa_a00.html#FC5'>aofa_a00</span></td></tr>
<tr><td>
cluster f ^2  ->  len f -element  ;
</td><td><span data-href='basel_1.html#FC2'>basel_1</span></td></tr>
<tr><td>
cluster f "  ->  len f -element  ;
</td><td><span data-href='basel_1.html#FC3'>basel_1</span></td></tr>
<tr><td>
cluster c + f ->  len f -element  ;
</td><td><span data-href='basel_1.html#FC4'>basel_1</span></td></tr>
<tr><td>
cluster  cot f ->  len f -element  ;
</td><td><span data-href='basel_1.html#FC20'>basel_1</span></td></tr>
<tr><td>
cluster  cosec f ->  len f -element  ;
</td><td><span data-href='basel_1.html#FC21'>basel_1</span></td></tr>
<tr><td>
cluster N -element   for    set ;
</td><td><span data-href='card_1.html#RC7'>card_1</span></td></tr>
<tr><td>
cluster  0  -element   ->  empty   for    set ;
</td><td><span data-href='card_1.html#CC7'>card_1</span></td></tr>
<tr><td>
cluster  empty   ->  0  -element   for    set ;
</td><td><span data-href='card_1.html#CC8'>card_1</span></td></tr>
<tr><td>
cluster {x} -> 1 -element  ;
</td><td><span data-href='card_1.html#FC16'>card_1</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like  N -element   for    set ;
</td><td><span data-href='card_1.html#RC8'>card_1</span></td></tr>
<tr><td>
cluster  dom f -> N -element  ;
</td><td><span data-href='card_1.html#FC17'>card_1</span></td></tr>
<tr><td>
cluster 1 -element   ->  non  empty   trivial   for    set ;
</td><td><span data-href='card_1.html#CC9'>card_1</span></td></tr>
<tr><td>
cluster  non  empty   trivial   -> 1 -element   for    set ;
</td><td><span data-href='card_1.html#CC10'>card_1</span></td></tr>
<tr><td>
cluster 1 -element   for    Element of  bool X;
</td><td><span data-href='card_1.html#RC9'>card_1</span></td></tr>
<tr><td>
cluster k -element   ->  non  empty   for    set ;
</td><td><span data-href='card_1.html#CC11'>card_1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   empty-yielding   the carrier of C -defined   the carrier of D -valued   empty   trivial   non  proper  V9() V10() V11() V13() V14() V15() V16() V17() V18()  Function-like   one-to-one   constant   functional   total  V28( the carrier of C, the carrier of D) V31() V35() V36() V39()  cardinal   0  -element  V43() V44() V45() V98() V99() V100() V101() V102() V105() V106() V107() V108() V109() V110() V111() V112()  identity-preserving   multiplicative   antimultiplicative   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC15'>cat_6</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   empty-yielding   the carrier of C -defined   the carrier of D -valued   empty   trivial   non  proper  V9() V10() V11() V13() V14() V15() V16() V17() V18()  Function-like   one-to-one   constant   functional   total  V28( the carrier of C, the carrier of D) V31() V35() V36() V39()  cardinal   0  -element  V43() V44() V45() V98() V99() V100() V101() V102() V105() V106() V107() V108() V109() V110() V111() V112()  covariant   contravariant   for    Element of  bool [: the carrier of C, the carrier of D:];
</td><td><span data-href='cat_6.html#RC17'>cat_6</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   Function-like   one-to-one   finite  V45(n)  FinSequence-like   FinSubsequence-like  V98()  natural-valued   for    set ;
</td><td><span data-href='circcmb3.html#RC7'>circcmb3</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   the InstructionsF of S -valued   Function-like  1 -element   initial   for    set ;
</td><td><span data-href='compos_1.html#RC2'>compos_1</span></td></tr>
<tr><td>
cluster  Subst (l,f) -> k -element  ;
</td><td><span data-href='cqc_lang.html#FC1'>cqc_lang</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   QC-variables A -valued   bound_QC-variables A -valued   Function-like  k -element   FinSequence-like   for    FinSequence of  QC-variables A;
</td><td><span data-href='cqc_lang.html#RC1'>cqc_lang</span></td></tr>
<tr><td>
cluster  Rev f -> n -element  ;
</td><td><span data-href='descip_1.html#FC1'>descip_1</span></td></tr>
<tr><td>
cluster 1 -element   ->  strong-chain   for    Element of  bool  the carrier of R;
</td><td><span data-href='dilworth.html#CC12'>dilworth</span></td></tr>
<tr><td>
cluster   -> n -element   for    Element of  REAL n;
</td><td><span data-href='euclid.html#CC1'>euclid</span></td></tr>
<tr><td>
cluster   -> n -element   for    Element of  the carrier of (TOP-REAL n);
</td><td><span data-href='euclid.html#CC4'>euclid</span></td></tr>
<tr><td>
cluster  - f -> n -element  ;
</td><td><span data-href='euclid_9.html#FC5'>euclid_9</span></td></tr>
<tr><td>
cluster f "  -> n -element  ;
</td><td><span data-href='euclid_9.html#FC6'>euclid_9</span></td></tr>
<tr><td>
cluster f ^2  -> n -element  ;
</td><td><span data-href='euclid_9.html#FC7'>euclid_9</span></td></tr>
<tr><td>
cluster |.f.| -> n -element  ;
</td><td><span data-href='euclid_9.html#FC8'>euclid_9</span></td></tr>
<tr><td>
cluster f + g -> n -element  ;
</td><td><span data-href='euclid_9.html#FC9'>euclid_9</span></td></tr>
<tr><td>
cluster f - g -> n -element  ;
</td><td><span data-href='euclid_9.html#FC10'>euclid_9</span></td></tr>
<tr><td>
cluster f (#) g -> n -element  ;
</td><td><span data-href='euclid_9.html#FC11'>euclid_9</span></td></tr>
<tr><td>
cluster f /" g -> n -element  ;
</td><td><span data-href='euclid_9.html#FC12'>euclid_9</span></td></tr>
<tr><td>
cluster c + f -> n -element  ;
</td><td><span data-href='euclid_9.html#FC13'>euclid_9</span></td></tr>
<tr><td>
cluster f - c -> n -element  ;
</td><td><span data-href='euclid_9.html#FC14'>euclid_9</span></td></tr>
<tr><td>
cluster c (#) f -> n -element  ;
</td><td><span data-href='euclid_9.html#FC15'>euclid_9</span></td></tr>
<tr><td>
cluster f +* (x,y) -> n -element  ;
</td><td><span data-href='euclid_9.html#FC18'>euclid_9</span></td></tr>
<tr><td>
cluster   -> n -element   for    Element of  the carrier of (Euclid n);
</td><td><span data-href='euclid_9.html#CC2'>euclid_9</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   Function-like   one-to-one   finite  n -element   FinSequence-like   FinSubsequence-like   countable   nonpair-yielding   for    set ;
</td><td><span data-href='facirc_1.html#RC3'>facirc_1</span></td></tr>
<tr><td>
cluster  Seg n -> n -element  ;
</td><td><span data-href='finseq_1.html#FC4'>finseq_1</span></td></tr>
<tr><td>
cluster f | 1 -> 1 -element  ;
</td><td><span data-href='finseq_1.html#FC22'>finseq_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   Function-like   finite  n -element   FinSequence-like   FinSubsequence-like   for    set ;
</td><td><span data-href='finseq_1.html#RC7'>finseq_1</span></td></tr>
<tr><td>
cluster <*x*> -> 1 -element  ;
</td><td><span data-href='finseq_1.html#FC25'>finseq_1</span></td></tr>
<tr><td>
cluster <*x,y*> -> 2 -element  ;
</td><td><span data-href='finseq_1.html#FC26'>finseq_1</span></td></tr>
<tr><td>
cluster <*x,y,z*> -> 3 -element  ;
</td><td><span data-href='finseq_1.html#FC27'>finseq_1</span></td></tr>
<tr><td>
cluster f ^ g -> n + m -element  ;
</td><td><span data-href='finseq_1.html#FC29'>finseq_1</span></td></tr>
<tr><td>
cluster  idseq k -> k -element  ;
</td><td><span data-href='finseq_2.html#FC1'>finseq_2</span></td></tr>
<tr><td>
cluster k |-> a -> k -element  ;
</td><td><span data-href='finseq_2.html#FC4'>finseq_2</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined  D -valued   Function-like  V49() i -element   FinSequence-like   FinSubsequence-like   countable   for    FinSequence of D;
</td><td><span data-href='finseq_2.html#RC2'>finseq_2</span></td></tr>
<tr><td>
cluster   -> i -element   for    Element of i -tuples_on D;
</td><td><span data-href='finseq_2.html#CC1'>finseq_2</span></td></tr>
<tr><td>
cluster <*x1,x2,x3,x4*> -> 4 -element  ;
</td><td><span data-href='finseq_4.html#FC5'>finseq_4</span></td></tr>
<tr><td>
cluster <*x1,x2,x3,x4,x5*> -> 5 -element  ;
</td><td><span data-href='finseq_4.html#FC6'>finseq_4</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined  D -valued   Function-like   finite  1 -element   FinSequence-like   FinSubsequence-like   circular   for    FinSequence of D;
</td><td><span data-href='finseq_6.html#RC1'>finseq_6</span></td></tr>
<tr><td>
cluster  Relation-like   empty-yielding   omega  -defined   NAT  -valued   Function-like  V32() n -element   FinSequence-like   FinSubsequence-like   complex-valued   ext-real-valued   real-valued   natural-valued   for    set ;
</td><td><span data-href='finseq_9.html#RC3'>finseq_9</span></td></tr>
<tr><td>
cluster x + f ->  len f -element  ;
</td><td><span data-href='finseq_9.html#FC7'>finseq_9</span></td></tr>
<tr><td>
cluster f - x ->  len f -element  ;
</td><td><span data-href='finseq_9.html#FC8'>finseq_9</span></td></tr>
<tr><td>
cluster |.f.| ->  len f -element  ;
</td><td><span data-href='finseq_9.html#FC9'>finseq_9</span></td></tr>
<tr><td>
cluster  - f ->  len f -element  ;
</td><td><span data-href='finseq_9.html#FC10'>finseq_9</span></td></tr>
<tr><td>
cluster f "  ->  len f -element  ;
</td><td><span data-href='finseq_9.html#FC11'>finseq_9</span></td></tr>
<tr><td>
cluster f + g ->  min (n,m) -element  ;
</td><td><span data-href='finseq_9.html#FC12'>finseq_9</span></td></tr>
<tr><td>
cluster f (#) g ->  min (n,m) -element  ;
</td><td><span data-href='finseq_9.html#FC13'>finseq_9</span></td></tr>
<tr><td>
cluster f - g ->  min (n,m) -element  ;
</td><td><span data-href='finseq_9.html#FC14'>finseq_9</span></td></tr>
<tr><td>
cluster f /" g ->  min (n,m) -element  ;
</td><td><span data-href='finseq_9.html#FC15'>finseq_9</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like   len f -element   FinSequence-like   ->  dom f -defined   for    set ;
</td><td><span data-href='finseq_9.html#CC13'>finseq_9</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like  n -element   FinSequence-like   ->  Seg n -defined   for    set ;
</td><td><span data-href='finseq_9.html#CC14'>finseq_9</span></td></tr>
<tr><td>
cluster  Relation-like   Seg n -defined   Function-like   FinSequence-like   total   -> n -element   for    set ;
</td><td><span data-href='finseq_9.html#CC15'>finseq_9</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined  X -valued   Function-like  V32() n -element   FinSequence-like   FinSubsequence-like   for    set ;
</td><td><span data-href='finseq_9.html#RC8'>finseq_9</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined  X -valued   Function-like  V32() n -element   FinSequence-like   FinSubsequence-like   for    FinSequence of X;
</td><td><span data-href='finseq_9.html#RC9'>finseq_9</span></td></tr>
<tr><td>
cluster  delneg f ->  len f -element   complex-valued  ;
</td><td><span data-href='finseq_9.html#FC51'>finseq_9</span></td></tr>
<tr><td>
cluster  delpos f ->  len f -element   complex-valued  ;
</td><td><span data-href='finseq_9.html#FC52'>finseq_9</span></td></tr>
<tr><td>
cluster r |^ f ->  len f -element   real-valued  ;
</td><td><span data-href='flexary1.html#FC6'>flexary1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined  D *  -valued   Function-like   finite  n -element   Function-yielding  V68()  FinSequence-like   FinSubsequence-like   FinSequence-yielding   finite-support   double-one-to-one   for    DoubleReorganization of D;
</td><td><span data-href='flexary1.html#RC3'>flexary1</span></td></tr>
<tr><td>
cluster (g *. f) . x ->  len (f . x) -element  ;
</td><td><span data-href='flexary1.html#FC14'>flexary1</span></td></tr>
<tr><td>
cluster g *. f ->  len f -element  ;
</td><td><span data-href='flexary1.html#FC16'>flexary1</span></td></tr>
<tr><td>
cluster  Sum f ->  len f -element   complex-valued  ;
</td><td><span data-href='flexary1.html#FC20'>flexary1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined  D -valued   Function-like   finite  m -element   FinSequence-like   FinSubsequence-like   countable   finite-support   for    Element of D * ;
</td><td><span data-href='fomodel0.html#RC2'>fomodel0</span></td></tr>
<tr><td>
cluster <:f,g:> -> m -element  ;
</td><td><span data-href='fomodel0.html#FC13'>fomodel0</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined  D -valued   Function-like   finite  m -element   FinSequence-like   FinSubsequence-like   countable   finite-support   for    set ;
</td><td><span data-href='fomodel0.html#RC6'>fomodel0</span></td></tr>
<tr><td>
cluster p >*> f -> m -element   for   set ;
</td><td><span data-href='fomodel0.html#FC20'>fomodel0</span></td></tr>
<tr><td>
cluster f AppliedPairwiseTo (p,q) -> m -element   for   set ;
</td><td><span data-href='fomodel0.html#FC21'>fomodel0</span></td></tr>
<tr><td>
cluster (x,y) -SymbolSubstIn p -> m -element   for  FinSequence;
</td><td><span data-href='fomodel0.html#FC36'>fomodel0</span></td></tr>
<tr><td>
cluster (x SubstWith u) . p -> m -element   for  FinSequence;
</td><td><span data-href='fomodel0.html#FC40'>fomodel0</span></td></tr>
<tr><td>
cluster {(p . m1)} \ U ->  empty   for   set ;
</td><td><span data-href='fomodel0.html#FC43'>fomodel0</span></td></tr>
<tr><td>
cluster {(p . (m + 1))} \ U ->  empty   for   set ;
</td><td><span data-href='fomodel0.html#FC44'>fomodel0</span></td></tr>
<tr><td>
cluster ((p | (Seg m)) ^ <*(p . (m + 1))*>) \+\ p ->  empty   for   set ;
</td><td><span data-href='fomodel0.html#FC46'>fomodel0</span></td></tr>
<tr><td>
cluster p | (Seg m) -> m -element   for  FinSequence;
</td><td><span data-href='fomodel0.html#FC47'>fomodel0</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   Function-like   finite  n -element   FinSequence-like   FinSubsequence-like   countable   finite-support   for    Element of (X *) \ {{}};
</td><td><span data-href='fomodel0.html#RC8'>fomodel0</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like  m1 + 0 -element   FinSequence-like   ->  non  empty   for    set ;
</td><td><span data-href='fomodel0.html#CC10'>fomodel0</span></td></tr>
<tr><td>
cluster p null x ->  len p -element   for  FinSequence;
</td><td><span data-href='fomodel0.html#FC59'>fomodel0</span></td></tr>
<tr><td>
cluster p null n ->  Seg (m + n) -defined   for  Relation;
</td><td><span data-href='fomodel0.html#FC64'>fomodel0</span></td></tr>
<tr><td>
cluster p ^ q -> m + n -element   for  FinSequence;
</td><td><span data-href='fomodel0.html#FC65'>fomodel0</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like  m + 1 -element   FinSequence-like   ->  non  empty   for    set ;
</td><td><span data-href='fomodel0.html#CC13'>fomodel0</span></td></tr>
<tr><td>
cluster p null m0 ->  Seg (m + m0) -defined   total   for  Seg (m + m0) -defined  Relation;
</td><td><span data-href='fomodel0.html#FC92'>fomodel0</span></td></tr>
<tr><td>
cluster  0  -termal   -> 1 -element   for    Element of ((AllSymbolsOf S) *) \ {{}};
</td><td><span data-href='fomodel1.html#CC19'>fomodel1</span></td></tr>
<tr><td>
cluster  SubTerms t -> |.(ar t).| -element   for   Element of (AllTermsOf S) * ;
</td><td><span data-href='fomodel1.html#FC20'>fomodel1</span></td></tr>
<tr><td>
cluster  SubTerms phi -> |.(ar ((S -firstChar) . phi)).| -element   for  FinSequence;
</td><td><span data-href='fomodel1.html#FC23'>fomodel1</span></td></tr>
<tr><td>
cluster  SubTerms phi0 -> (TermSymbolsOf S) *  -valued  |.(ar ((S -firstChar) . phi0)).| -element  ;
</td><td><span data-href='fomodel1.html#FC38'>fomodel1</span></td></tr>
<tr><td>
cluster h (*) p ->  len p -element   for  FinSequence;
</td><td><span data-href='fomodel2.html#FC6'>fomodel2</span></td></tr>
<tr><td>
cluster h (*) p -> n -element   for   FinSequence of E;
</td><td><span data-href='fomodel2.html#FC8'>fomodel2</span></td></tr>
<tr><td>
cluster s -compound V -> mm + 1 -termal   for  string of S;
</td><td><span data-href='fomodel3.html#FC1'>fomodel3</span></td></tr>
<tr><td>
cluster s -compound V ->  termal   for  string of S;
</td><td><span data-href='fomodel3.html#FC2'>fomodel3</span></td></tr>
<tr><td>
cluster s -compound V ->  0wff   for  string of S;
</td><td><span data-href='fomodel3.html#FC3'>fomodel3</span></td></tr>
<tr><td>
cluster  PairWiseEq (T,U) ->  finite  ;
</td><td><span data-href='fomodel4.html#FC48'>fomodel4</span></td></tr>
<tr><td>
cluster {[((PairWiseEq (T1,T2)) \/ {(s -compound T1)}),(s -compound T2)]} ->  {} ,{(R#3e S)} -derivable  ;
</td><td><span data-href='fomodel4.html#FC49'>fomodel4</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined  X -valued   Function-like   Sequence-like   finite  n -element   finite-support  V268()  for    set ;
</td><td><span data-href='hilb10_2.html#RC1'>hilb10_2</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   Function-like   Sequence-like   finite  n -element   real-valued   finite-support  V268()  for    set ;
</td><td><span data-href='hilb10_2.html#RC2'>hilb10_2</span></td></tr>
<tr><td>
cluster p ^ q -> n + m -element  ;
</td><td><span data-href='hilb10_2.html#FC1'>hilb10_2</span></td></tr>
<tr><td>
cluster   -> D -valued  n -element   for    Element of n -xtuples_of D;
</td><td><span data-href='hilb10_2.html#CC1'>hilb10_2</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   Sequence-like   Function-like   natural-valued  V55() n -element  V213()  for    set ;
</td><td><span data-href='hilb10_4.html#RC1'>hilb10_4</span></td></tr>
<tr><td>
cluster  eval (p,(@ x)) ->  integer  ;
</td><td><span data-href='hilb10_5.html#FC2'>hilb10_5</span></td></tr>
<tr><td>
cluster (Mx2Tran M) . f -> m -element  ;
</td><td><span data-href='matrtop1.html#FC12'>matrtop1</span></td></tr>
<tr><td>
cluster  support (pfexp (p |^ a)) -> 1 -element  ;
</td><td><span data-href='nat_3.html#FC19'>nat_3</span></td></tr>
<tr><td>
cluster  support (pfexp p) -> 1 -element  ;
</td><td><span data-href='nat_3.html#FC20'>nat_3</span></td></tr>
<tr><td>
cluster   ->  len G -element   for    Element of  the carrier of (product G);
</td><td><span data-href='ndiff_5.html#CC1'>ndiff_5</span></td></tr>
<tr><td>
cluster  Rev f ->  len f -element  ;
</td><td><span data-href='newton04.html#FC31'>newton04</span></td></tr>
<tr><td>
cluster a * f ->  len f -element  ;
</td><td><span data-href='newton04.html#FC33'>newton04</span></td></tr>
<tr><td>
cluster (a,b) In_Power n -> n + 1 -element  ;
</td><td><span data-href='newton04.html#FC34'>newton04</span></td></tr>
<tr><td>
cluster  Newton_Coeff n -> n + 1 -element  ;
</td><td><span data-href='newton04.html#FC36'>newton04</span></td></tr>
<tr><td>
cluster (a,b) Subnomial n -> n + 1 -element  ;
</td><td><span data-href='newton04.html#FC37'>newton04</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   Function-like   finite  n -element   FinSequence-like   FinSubsequence-like  V,A -FPrg-yielding   for    set ;
</td><td><span data-href='nomin_2.html#RC2'>nomin_2</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty   empty-yielding   NAT  -defined   RAT  -valued   empty   trivial   proper  V9() V10() V11() V13() V14() V15()  zero  V17() V18()  complex  V20()  Function-like   one-to-one   constant   functional   finite   finite-yielding  V36()  cardinal   0  -element   FinSequence-like   FinSubsequence-like   FinSequence-membered   ext-real   non  positive   non  negative  V53() V54() V55() V56() V57() V58() V59() V60() V63() V64() V65() V66() V67() V68() V69()  Function-yielding   reflexive   irreflexive   symmetric   antisymmetric   asymmetric   connected   strongly_connected   transitive   FinSequence-yielding   finite-support  V107()  for    a_partition of A;
</td><td><span data-href='orders_5.html#RC2'>orders_5</span></td></tr>
<tr><td>
cluster 2 -element   ->  non  empty   for    set ;
</td><td><span data-href='prefer_1.html#CC1'>prefer_1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   QC-variables A -valued   Function-like  V41() k -element   FinSequence-like   FinSubsequence-like   for    FinSequence of  QC-variables A;
</td><td><span data-href='qc_lang1.html#RC1'>qc_lang1</span></td></tr>
<tr><td>
cluster 1 -element   affinely-independent   for    Element of K19( the carrier of V);
</td><td><span data-href='rlaffin1.html#RC1'>rlaffin1</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined  D -valued   Function-like   finite  n -element   FinSequence-like   FinSubsequence-like   for    set ;
</td><td><span data-href='rlvect_x.html#RC1'>rlvect_x</span></td></tr>
<tr><td>
cluster 1 -element   ->  finite   for    Element of K21(E);
</td><td><span data-href='rpr_1.html#CC1'>rpr_1</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   Function-like   natural-valued  V64() n -element   FinSequence-like   FinSubsequence-like   for    set ;
</td><td><span data-href='rvsum_1.html#RC1'>rvsum_1</span></td></tr>
<tr><td>
cluster x | n -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC3'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   REAL  -valued   Sequence-like   Function-like   finite  n -element  V61()  complex-valued   ext-real-valued   real-valued   natural-valued   for    set ;
</td><td><span data-href='rvsum_4.html#RC5'>rvsum_4</span></td></tr>
<tr><td>
cluster n --> k -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC9'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   omega  -defined   Sequence-like   Function-like   finite  n -element  V61()  for    set ;
</td><td><span data-href='rvsum_4.html#RC6'>rvsum_4</span></td></tr>
<tr><td>
cluster  Re f ->  len f -element  ;
</td><td><span data-href='rvsum_4.html#FC14'>rvsum_4</span></td></tr>
<tr><td>
cluster  Im f ->  len f -element  ;
</td><td><span data-href='rvsum_4.html#FC15'>rvsum_4</span></td></tr>
<tr><td>
cluster  Relation-like   Function-like   finite  n -element   for    set ;
</td><td><span data-href='rvsum_4.html#RC8'>rvsum_4</span></td></tr>
<tr><td>
cluster  Shift (f,n) ->  len f -element  ;
</td><td><span data-href='rvsum_4.html#FC21'>rvsum_4</span></td></tr>
<tr><td>
cluster f ^ g -> n + m -element  ;
</td><td><span data-href='rvsum_4.html#FC24'>rvsum_4</span></td></tr>
<tr><td>
cluster g ^ f -> n + m -element  ;
</td><td><span data-href='rvsum_4.html#FC25'>rvsum_4</span></td></tr>
<tr><td>
cluster f | n -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC30'>rvsum_4</span></td></tr>
<tr><td>
cluster  - p -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC31'>rvsum_4</span></td></tr>
<tr><td>
cluster p "  -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC32'>rvsum_4</span></td></tr>
<tr><td>
cluster p ^2  -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC33'>rvsum_4</span></td></tr>
<tr><td>
cluster |.p.| -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC34'>rvsum_4</span></td></tr>
<tr><td>
cluster  Rev p -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC35'>rvsum_4</span></td></tr>
<tr><td>
cluster p + q -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC36'>rvsum_4</span></td></tr>
<tr><td>
cluster p - q -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC37'>rvsum_4</span></td></tr>
<tr><td>
cluster p (#) q -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC38'>rvsum_4</span></td></tr>
<tr><td>
cluster p /" q -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC39'>rvsum_4</span></td></tr>
<tr><td>
cluster p + q -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC40'>rvsum_4</span></td></tr>
<tr><td>
cluster p - q -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC41'>rvsum_4</span></td></tr>
<tr><td>
cluster p (#) q -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC42'>rvsum_4</span></td></tr>
<tr><td>
cluster p /" q -> n -element  ;
</td><td><span data-href='rvsum_4.html#FC43'>rvsum_4</span></td></tr>
<tr><td>
cluster  JUMP (goto i1) -> 1 -element  ;
</td><td><span data-href='scmfsa10.html#FC12'>scmfsa10</span></td></tr>
<tr><td>
cluster  JUMP (a =0_goto i1) -> 1 -element  ;
</td><td><span data-href='scmfsa10.html#FC13'>scmfsa10</span></td></tr>
<tr><td>
cluster  JUMP (a >0_goto i1) -> 1 -element  ;
</td><td><span data-href='scmfsa10.html#FC14'>scmfsa10</span></td></tr>
<tr><td>
cluster  JUMP (goto (i1,R)) -> 1 -element  ;
</td><td><span data-href='scmring3.html#FC12'>scmring3</span></td></tr>
<tr><td>
cluster  JUMP (a =0_goto i1) -> 1 -element  ;
</td><td><span data-href='scmring3.html#FC13'>scmring3</span></td></tr>
<tr><td>
cluster 1 -element   affinely-independent   for    Element of  bool  the carrier of V;
</td><td><span data-href='simplex1.html#RC3'>simplex1</span></td></tr>
<tr><td>
cluster  Relation-like   non-empty  K42() -defined   Function-like   finite  n -element   FinSequence-like   FinSubsequence-like   countable   for    set ;
</td><td><span data-href='srings_4.html#RC3'>srings_4</span></td></tr>
<tr><td>
cluster  non  empty   Relation-like  K42() -defined   Function-like   finite  n -element   FinSequence-like   FinSubsequence-like   countable   cap-closed-yielding   for    SemiringFamily of X;
</td><td><span data-href='srings_4.html#RC4'>srings_4</span></td></tr>
<tr><td>
cluster  SemiringProduct S ->  cap-closed  ;
</td><td><span data-href='srings_4.html#FC11'>srings_4</span></td></tr>
<tr><td>
cluster   -> n -element   for    Element of  RAT n;
</td><td><span data-href='srings_5.html#CC1'>srings_5</span></td></tr>
<tr><td>
cluster  the carrier of X -> C -element  ;
</td><td><span data-href='struct_0.html#FC19'>struct_0</span></td></tr>
<tr><td>
cluster  CQC_Subst (ll,Sub) ->  bound_QC-variables Al -valued  k -element  ;
</td><td><span data-href='sublemma.html#FC1'>sublemma</span></td></tr>
<tr><td>
cluster  proper   ->  empty   for    Element of  bool S;
</td><td><span data-href='tex_2.html#CC1'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   ->  non  proper   for    Element of  bool S;
</td><td><span data-href='tex_2.html#CC2'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   non  proper   ->  non  empty   trivial   for    Element of  bool S;
</td><td><span data-href='tex_2.html#CC3'>tex_2</span></td></tr>
<tr><td>
cluster  proj (J,i) ->  one-to-one  ;
</td><td><span data-href='tops_5.html#FC4'>tops_5</span></td></tr>
<tr><td>
cluster  Relation-like   NAT  -defined   Function-like   finite  1 -element   for    set ;
</td><td><span data-href='valued_1.html#RC4'>valued_1</span></td></tr>
<tr><td>
cluster  CutLastLoc F ->  empty  ;
</td><td><span data-href='valued_1.html#FC110'>valued_1</span></td></tr>
<tr><td>
cluster 1 -element   for    strict_chain of R;
</td><td><span data-href='waybel35.html#RC6'>waybel35</span></td></tr>
<tr><td>
cluster 1 -element   for    strict_chain of R;
</td><td><span data-href='waybel35.html#RC7'>waybel35</span></td></tr>
</tbody>
</table>
</div>
<div class='related-reduce'>
<table class='pure-table'>
<thead><tr><th colspan='2'>reduce</th></tr></thead>
<tbody>
<tr><td>
reduce f + g to f;
</td><td><span data-href='finseq_9.html#RD9'>finseq_9</span></td></tr>
<tr><td>
reduce f + g to f;
</td><td><span data-href='finseq_9.html#RD10'>finseq_9</span></td></tr>
<tr><td>
reduce ((len f) |-> a) . k to a;
</td><td><span data-href='finseq_9.html#RD13'>finseq_9</span></td></tr>
<tr><td>
reduce (f ^ <*a*>) . (n + 1) to a;
</td><td><span data-href='finseq_9.html#RD23'>finseq_9</span></td></tr>
<tr><td>
reduce (f ^ <*a*>) | n to f;
</td><td><span data-href='finseq_9.html#RD24'>finseq_9</span></td></tr>
<tr><td>
reduce <*(f . 1)*> to f;
</td><td><span data-href='rvsum_4.html#RD6'>rvsum_4</span></td></tr>
<tr><td>
reduce <*(f . 1),(f . 2)*> to f;
</td><td><span data-href='rvsum_4.html#RD7'>rvsum_4</span></td></tr>
<tr><td>
reduce <*(f . 1),(f . 2),(f . 3)*> to f;
</td><td><span data-href='rvsum_4.html#RD8'>rvsum_4</span></td></tr>
<tr><td>
reduce f | n to f;
</td><td><span data-href='rvsum_4.html#RD13'>rvsum_4</span></td></tr>
<tr><td>
reduce f | (n + m) to f;
</td><td><span data-href='rvsum_4.html#RD14'>rvsum_4</span></td></tr>
<tr><td>
reduce <%(f . 0)%> to f;
</td><td><span data-href='rvsum_4.html#RD15'>rvsum_4</span></td></tr>
<tr><td>
reduce <%(f . 0),(f . 1)%> to f;
</td><td><span data-href='rvsum_4.html#RD16'>rvsum_4</span></td></tr>
<tr><td>
reduce <%(f . 0),(f . 1),(f . 2)%> to f;
</td><td><span data-href='rvsum_4.html#RD17'>rvsum_4</span></td></tr>
<tr><td>
reduce (dom p) /\ (dom q) to  dom p;
</td><td><span data-href='rvsum_4.html#RD30'>rvsum_4</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
<div class='mml-element' id='ELM25781'>
<h2>2.   <span data-link='1335.html'>[Back to top]</span></h2>
<div class='source'>
<h3>Source <span class='defined-in'> [<span data-href='struct_0.html#V13'>struct_0</span>]</span></h3>
<div class='source-box'>
<div>
<span class="kw">definition</span><div class="add">
<span class="kw">let </span><font color="Maroon" title="c1">C</font> be    <span title="HIDDEN:mode.2" data-link="4141.html#ELM11936">set</span> ;<br><span class="kw">let </span><font color="Maroon" title="c2">X</font> be    <span title="STRUCT_0:struct.1" data-link="8048.html#ELM25742">1-sorted</span> ;<br><div about="#D8" typeof="oo:Definition" class="main-sentence">
<a name="V13"><span class="kw">attr</span> </a><font color="Maroon" title="c2">X</font> is <font color="Maroon" title="c1">C</font> <span title="STRUCT_0:attr.13" data-link="1335.html#ELM25781">-element</span> <span class="kw"> means </span>:<span class="lab"><font color="Green" title="E8">Def19</font></span>: <a name="D19"><span class="comment"><font color="firebrick">:: STRUCT_0:def 19</font></span><br></a> the <span title="STRUCT_0:sel.1" data-href="struct_0.html#U1">carrier</span> of <font color="Maroon" title="c2">X</font> is <font color="Maroon" title="c1">C</font> <span title="CARD_1:attr.3" data-link="1335.html#ELM3240">-element</span> ;<br>
</div>
</div>
<span class="kw">end;</span>
</div>

</div>
</div>
<div class='reference'>
<h3>Referenced In</h3>
<div class='related-cluster'>
<table class='pure-table'>
<thead><tr><th colspan='2'>cluster</th></tr></thead>
<tbody>
<tr><td>
cluster 1 -element   reflexive   -> 1 -element   complete   for    RelStr ;
</td><td><span data-href='abcmiz_0.html#CC1'>abcmiz_0</span></td></tr>
<tr><td>
cluster 1 -element   -> 1 -element   Noetherian   for    RelStr ;
</td><td><span data-href='abcmiz_0.html#CC2'>abcmiz_0</span></td></tr>
<tr><td>
cluster 1 -element   reflexive   non  void   involutive   without_fixpoints   strict   for    TA-structure ;
</td><td><span data-href='abcmiz_0.html#RC5'>abcmiz_0</span></td></tr>
<tr><td>
cluster  non  empty   trivial   finite  1 -element   reflexive   transitive   antisymmetric   with_suprema   with_infima   complete   lower-bounded   upper-bounded  V145()  connected   up-complete   /\-complete   Noetherian   Mizar-widening-like   non  void   involutive   without_fixpoints   strict   consistent   adj-structured   adjs-typed   for    TA-structure ;
</td><td><span data-href='abcmiz_0.html#RC6'>abcmiz_0</span></td></tr>
<tr><td>
cluster 1 -element   reflexive   non  void   strict   for    TAS-structure ;
</td><td><span data-href='abcmiz_0.html#RC8'>abcmiz_0</span></td></tr>
<tr><td>
cluster  non  empty   trivial   finite  1 -element   reflexive   transitive   antisymmetric   with_suprema   with_infima   complete   lower-bounded   upper-bounded  V145()  connected   up-complete   /\-complete   Noetherian   Mizar-widening-like   non  void   involutive   without_fixpoints   consistent   adj-structured   adjs-typed   strict   non-absorbing   subjected   commutative   for    TAS-structure ;
</td><td><span data-href='abcmiz_0.html#RC9'>abcmiz_0</span></td></tr>
<tr><td>
cluster  Trivial-addMagma  -> 1 -element   strict  ;
</td><td><span data-href='algstr_0.html#FC4'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    addMagma ;
</td><td><span data-href='algstr_0.html#RC2'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   strict   add-cancelable   for    addMagma ;
</td><td><span data-href='algstr_0.html#RC3'>algstr_0</span></td></tr>
<tr><td>
cluster  Trivial-addLoopStr  -> 1 -element   strict  ;
</td><td><span data-href='algstr_0.html#FC9'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    addLoopStr ;
</td><td><span data-href='algstr_0.html#RC5'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   add-cancelable   strict   complementable   for    addLoopStr ;
</td><td><span data-href='algstr_0.html#RC6'>algstr_0</span></td></tr>
<tr><td>
cluster  Trivial-multMagma  -> 1 -element   strict  ;
</td><td><span data-href='algstr_0.html#FC15'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    multMagma ;
</td><td><span data-href='algstr_0.html#RC8'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   strict   mult-cancelable   for    multMagma ;
</td><td><span data-href='algstr_0.html#RC9'>algstr_0</span></td></tr>
<tr><td>
cluster  Trivial-multLoopStr  -> 1 -element   strict  ;
</td><td><span data-href='algstr_0.html#FC20'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    multLoopStr ;
</td><td><span data-href='algstr_0.html#RC11'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   mult-cancelable   strict   invertible   for    multLoopStr ;
</td><td><span data-href='algstr_0.html#RC12'>algstr_0</span></td></tr>
<tr><td>
cluster  Trivial-multLoopStr_0  -> 1 -element   strict  ;
</td><td><span data-href='algstr_0.html#FC26'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    multLoopStr_0 ;
</td><td><span data-href='algstr_0.html#RC14'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   strict   almost_cancelable   for    multLoopStr_0 ;
</td><td><span data-href='algstr_0.html#RC15'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   strict   almost_cancelable   almost_invertible   for    multLoopStr_0 ;
</td><td><span data-href='algstr_0.html#RC16'>algstr_0</span></td></tr>
<tr><td>
cluster  Trivial-doubleLoopStr  -> 1 -element   strict  ;
</td><td><span data-href='algstr_0.html#FC32'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    doubleLoopStr ;
</td><td><span data-href='algstr_0.html#RC18'>algstr_0</span></td></tr>
<tr><td>
cluster 1 -element   -> 1 -element   right_complementable   Abelian   add-associative   right_zeroed   for    addLoopStr ;
</td><td><span data-href='algstr_1.html#CC7'>algstr_1</span></td></tr>
<tr><td>
cluster 1 -element   -> 1 -element   Group-like   associative   commutative   for    multMagma ;
</td><td><span data-href='algstr_1.html#CC9'>algstr_1</span></td></tr>
<tr><td>
cluster 1 -element   ->  quasi-discrete   for    AltCatStr ;
</td><td><span data-href='altcat_1.html#CC3'>altcat_1</span></td></tr>
<tr><td>
cluster  BCI-EXAMPLE  -> 1 -element   strict  ;
</td><td><span data-href='bcialg_1.html#FC1'>bcialg_1</span></td></tr>
<tr><td>
cluster  BCI_S-EXAMPLE  -> 1 -element   strict  ;
</td><td><span data-href='bcialg_4.html#FC1'>bcialg_4</span></td></tr>
<tr><td>
cluster  Trivial-CLSStruct  -> 1 -element   strict  ;
</td><td><span data-href='clvect_1.html#FC2'>clvect_1</span></td></tr>
<tr><td>
cluster  Trivial-AMI N -> 1 -element   strict  ;
</td><td><span data-href='extpro_1.html#FC1'>extpro_1</span></td></tr>
<tr><td>
cluster 1 -element   with_non-empty_values   for    AMI-Struct over N;
</td><td><span data-href='extpro_1.html#RC3'>extpro_1</span></td></tr>
<tr><td>
cluster  non  empty   trivial  V58() 1 -element   with_non-empty_values   IC-Ins-separated   strict   halting   for    AMI-Struct over N;
</td><td><span data-href='extpro_1.html#RC7'>extpro_1</span></td></tr>
<tr><td>
cluster  non  empty   trivial  V52() 1 -element   right_complementable   strict   right-distributive   right_unital   Abelian   add-associative   right_zeroed   associative   commutative   for    doubleLoopStr ;
</td><td><span data-href='funcsdom.html#RC1'>funcsdom</span></td></tr>
<tr><td>
cluster 1 -element   -> 1 -element   Abelian   add-associative   addGroup-like   for    addMagma ;
</td><td><span data-href='group_1a.html#CC5'>group_1a</span></td></tr>
<tr><td>
cluster 1 -element   TopSpace-like   strict   for    TopaddGrStr ;
</td><td><span data-href='group_1a.html#RC9'>group_1a</span></td></tr>
<tr><td>
cluster  non  empty   trivial   finite  1 -element   Abelian   add-associative   TopSpace-like   compact   homogeneous   add-unital   addGroup-like   strict   UnContinuous   BinContinuous   for    TopaddGrStr ;
</td><td><span data-href='group_1a.html#RC10'>group_1a</span></td></tr>
<tr><td>
cluster  non  empty  1 -element   strict   join-commutative   join-associative   meet-commutative   meet-associative   meet-absorbing   join-absorbing   Lattice-like   for    LattStr ;
</td><td><span data-href='lattice6.html#RC4'>lattice6</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    \/-SemiLattStr ;
</td><td><span data-href='lattices.html#RC4'>lattices</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    /\-SemiLattStr ;
</td><td><span data-href='lattices.html#RC5'>lattices</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    LattStr ;
</td><td><span data-href='lattices.html#RC6'>lattices</span></td></tr>
<tr><td>
cluster  Trivial-Mem N -> 1 -element   strict  ;
</td><td><span data-href='memstr_0.html#FC1'>memstr_0</span></td></tr>
<tr><td>
cluster 1 -element   for    Mem-Struct over N;
</td><td><span data-href='memstr_0.html#RC2'>memstr_0</span></td></tr>
<tr><td>
cluster  non  empty  V116()  finite  1 -element   strict   with_non-empty_values   IC-Ins-separated   for    Mem-Struct over N;
</td><td><span data-href='memstr_0.html#RC4'>memstr_0</span></td></tr>
<tr><td>
cluster  non  void  1 -element   strict   segmental   for    ManySortedSign ;
</td><td><span data-href='msualg_1.html#RC8'>msualg_1</span></td></tr>
<tr><td>
cluster  MSSign A ->  trivial   non  void  1 -element   strict   segmental  ;
</td><td><span data-href='msualg_1.html#FC2'>msualg_1</span></td></tr>
<tr><td>
cluster  the_sort_of A ->  non  empty  ;
</td><td><span data-href='msualg_1.html#FC4'>msualg_1</span></td></tr>
<tr><td>
cluster  TrivOrthoRelStr  -> 1 -element   strict  ;
</td><td><span data-href='oposet_1.html#FC2'>oposet_1</span></td></tr>
<tr><td>
cluster 1 -element   strict   total   reflexive   transitive   antisymmetric   for    RelStr ;
</td><td><span data-href='orders_2.html#RC2'>orders_2</span></td></tr>
<tr><td>
cluster  empty   trivial  V53()  0  -element   strict   PI-preference-like   for    PIStr ;
</td><td><span data-href='prefer_1.html#RC14'>prefer_1</span></td></tr>
<tr><td>
cluster  empty   trivial  V53()  0  -element   void   preference-like   tournament-like   for    PreferenceStr ;
</td><td><span data-href='prefer_1.html#RC15'>prefer_1</span></td></tr>
<tr><td>
cluster  empty   trivial  V53()  0  -element   void   preference-like   tournament-like   total   for    PreferenceStr ;
</td><td><span data-href='prefer_1.html#RC17'>prefer_1</span></td></tr>
<tr><td>
cluster  Closed-Interval-TSpace (r,r) -> 1 -element  ;
</td><td><span data-href='rcomp_3.html#FC14'>rcomp_3</span></td></tr>
<tr><td>
cluster  Trivial-RLSStruct  -> 1 -element   strict  ;
</td><td><span data-href='rlvect_1.html#FC2'>rlvect_1</span></td></tr>
<tr><td>
cluster  TrivComplLat  -> 1 -element   strict  ;
</td><td><span data-href='robbins1.html#FC1'>robbins1</span></td></tr>
<tr><td>
cluster  TrivOrtLat  -> 1 -element   strict  ;
</td><td><span data-href='robbins1.html#FC2'>robbins1</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    OrthoLattStr ;
</td><td><span data-href='robbins1.html#RC5'>robbins1</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    ComplLLattStr ;
</td><td><span data-href='robbins1.html#RC6'>robbins1</span></td></tr>
<tr><td>
cluster  ComplStr(#  the carrier of L, the Compl of L #) -> 1 -element  ;
</td><td><span data-href='robbins1.html#FC3'>robbins1</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    ComplStr ;
</td><td><span data-href='robbins1.html#RC7'>robbins1</span></td></tr>
<tr><td>
cluster  TrivLattRelStr  -> 1 -element  ;
</td><td><span data-href='robbins3.html#FC1'>robbins3</span></td></tr>
<tr><td>
cluster  TrivCLRelStr  -> 1 -element  ;
</td><td><span data-href='robbins3.html#FC5'>robbins3</span></td></tr>
<tr><td>
cluster  non  empty   trivial  V52() 1 -element   join-commutative   join-associative   meet-commutative   meet-associative   meet-absorbing   join-absorbing   Lattice-like   distributive   modular   lower-bounded   upper-bounded  V161()  complemented   Boolean   de_Morgan   upper-bounded'   lower-bounded'   distributive'   complemented'   join-Associative   meet-Associative   meet-Absorbing   involutive   with_Top   for    OrthoLattStr ;
</td><td><span data-href='robbins3.html#RC11'>robbins3</span></td></tr>
<tr><td>
cluster 1 -element   reflexive   for    LattRelStr ;
</td><td><span data-href='robbins3.html#RC13'>robbins3</span></td></tr>
<tr><td>
cluster 1 -element   reflexive   for    OrthoLattRelStr ;
</td><td><span data-href='robbins3.html#RC14'>robbins3</span></td></tr>
<tr><td>
cluster 1 -element   reflexive   for    OrthoRelStr ;
</td><td><span data-href='robbins3.html#RC15'>robbins3</span></td></tr>
<tr><td>
cluster 1 -element   -> 1 -element   well-complemented   de_Morgan   involutive   with_Top   for    OrthoLattStr ;
</td><td><span data-href='robbins3.html#CC11'>robbins3</span></td></tr>
<tr><td>
cluster 1 -element   reflexive   -> 1 -element   reflexive   PartialOrdered   Pure   OrderInvolutive   for    OrthoRelStr ;
</td><td><span data-href='robbins3.html#CC12'>robbins3</span></td></tr>
<tr><td>
cluster 1 -element   reflexive   -> 1 -element   reflexive   naturally_sup-generated   naturally_inf-generated   for    LattRelStr ;
</td><td><span data-href='robbins3.html#CC13'>robbins3</span></td></tr>
<tr><td>
cluster 1 -element   -> 1 -element   meet-Absorbing   for    OrthoLattStr ;
</td><td><span data-href='robbins4.html#CC1'>robbins4</span></td></tr>
<tr><td>
cluster  non  empty  V48() V49() 1 -element   Lattice-like   Boolean   join-idempotent   upper-bounded'   lower-bounded'   distributive'   complemented'   for    LattStr ;
</td><td><span data-href='sheffer1.html#RC1'>sheffer1</span></td></tr>
<tr><td>
cluster 1 -element   for    ShefferStr ;
</td><td><span data-href='sheffer1.html#RC5'>sheffer1</span></td></tr>
<tr><td>
cluster 1 -element   for    ShefferLattStr ;
</td><td><span data-href='sheffer1.html#RC6'>sheffer1</span></td></tr>
<tr><td>
cluster 1 -element   for    ShefferOrthoLattStr ;
</td><td><span data-href='sheffer1.html#RC7'>sheffer1</span></td></tr>
<tr><td>
cluster 1 -element   -> 1 -element   satisfying_Sheffer_1   satisfying_Sheffer_2   satisfying_Sheffer_3   for    ShefferStr ;
</td><td><span data-href='sheffer1.html#CC3'>sheffer1</span></td></tr>
<tr><td>
cluster 1 -element   -> 1 -element   join-commutative   join-associative   for    \/-SemiLattStr ;
</td><td><span data-href='sheffer1.html#CC4'>sheffer1</span></td></tr>
<tr><td>
cluster 1 -element   -> 1 -element   meet-commutative   meet-associative   for    /\-SemiLattStr ;
</td><td><span data-href='sheffer1.html#CC5'>sheffer1</span></td></tr>
<tr><td>
cluster 1 -element   -> 1 -element   meet-absorbing   join-absorbing   Boolean   for    LattStr ;
</td><td><span data-href='sheffer1.html#CC6'>sheffer1</span></td></tr>
<tr><td>
cluster  TrivShefferOrthoLattStr  -> 1 -element  ;
</td><td><span data-href='sheffer1.html#FC1'>sheffer1</span></td></tr>
<tr><td>
cluster C -element   for    1-sorted ;
</td><td><span data-href='struct_0.html#RC23'>struct_0</span></td></tr>
<tr><td>
cluster  the carrier of X -> C -element  ;
</td><td><span data-href='struct_0.html#FC19'>struct_0</span></td></tr>
<tr><td>
cluster  empty   ->  0  -element   for    1-sorted ;
</td><td><span data-href='struct_0.html#CC8'>struct_0</span></td></tr>
<tr><td>
cluster  0  -element   ->  empty   for    1-sorted ;
</td><td><span data-href='struct_0.html#CC9'>struct_0</span></td></tr>
<tr><td>
cluster  non  empty   trivial   -> 1 -element   for    1-sorted ;
</td><td><span data-href='struct_0.html#CC10'>struct_0</span></td></tr>
<tr><td>
cluster 1 -element   ->  non  empty   trivial   for    1-sorted ;
</td><td><span data-href='struct_0.html#CC11'>struct_0</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    TopStruct ;
</td><td><span data-href='tex_1.html#RC1'>tex_1</span></td></tr>
<tr><td>
cluster 1 -element   strict   TopSpace-like   for    TopStruct ;
</td><td><span data-href='tex_1.html#RC3'>tex_1</span></td></tr>
<tr><td>
cluster 1 -element   TopSpace-like   -> 1 -element   discrete   anti-discrete   for    TopStruct ;
</td><td><span data-href='tex_1.html#CC1'>tex_1</span></td></tr>
<tr><td>
cluster  non  empty   ->  non  empty   non  proper   for    Element of  bool  the carrier of Y;
</td><td><span data-href='tex_2.html#CC6'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   non  proper   ->  non  empty   trivial   for    Element of  bool  the carrier of Y;
</td><td><span data-href='tex_2.html#CC7'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   ->  non  empty   non  proper   for    SubSpace of Y;
</td><td><span data-href='tex_2.html#CC10'>tex_2</span></td></tr>
<tr><td>
cluster  non  empty   non  proper   ->  non  empty   trivial   for    SubSpace of Y;
</td><td><span data-href='tex_2.html#CC11'>tex_2</span></td></tr>
<tr><td>
cluster 1 -element   strict   for    SubSpace of Y;
</td><td><span data-href='tex_2.html#RC7'>tex_2</span></td></tr>
<tr><td>
cluster  Sspace y ->  non  empty  1 -element   strict  ;
</td><td><span data-href='tex_2.html#FC2'>tex_2</span></td></tr>
<tr><td>
cluster 1 -element   for    SubSpace of Y;
</td><td><span data-href='tex_2.html#RC9'>tex_2</span></td></tr>
<tr><td>
cluster 1 -element   -> 1 -element   homogeneous   for    TopStruct ;
</td><td><span data-href='topgrp_1.html#CC5'>topgrp_1</span></td></tr>
<tr><td>
cluster 1 -element   -> 1 -element   Group-like   associative   commutative   for    multMagma ;
</td><td><span data-href='topgrp_1.html#CC6'>topgrp_1</span></td></tr>
<tr><td>
cluster 1 -element   TopSpace-like   strict   for    TopGrStr ;
</td><td><span data-href='topgrp_1.html#RC7'>topgrp_1</span></td></tr>
<tr><td>
cluster  non  empty   trivial  V46() 1 -element   TopSpace-like   compact   unital   Group-like   associative   commutative   homogeneous   strict   UnContinuous   BinContinuous   for    TopGrStr ;
</td><td><span data-href='topgrp_1.html#RC8'>topgrp_1</span></td></tr>
<tr><td>
cluster  finite  1 -element   strict   reflexive   transitive   antisymmetric   with_suprema   with_infima   for    RelStr ;
</td><td><span data-href='waybel11.html#RC2'>waybel11</span></td></tr>
<tr><td>
cluster   ->  upper   for    Element of  bool  the carrier of R;
</td><td><span data-href='waybel11.html#CC3'>waybel11</span></td></tr>
<tr><td>
cluster  non  empty  1 -element   TopSpace-like   reflexive   transitive   antisymmetric   with_suprema   with_infima   complete   strict   Scott   for    TopRelStr ;
</td><td><span data-href='waybel11.html#RC4'>waybel11</span></td></tr>
<tr><td>
cluster 1 -element   TopSpace-like   reflexive   -> 1 -element   TopSpace-like   reflexive   lower   for    TopRelStr ;
</td><td><span data-href='waybel19.html#CC1'>waybel19</span></td></tr>
<tr><td>
cluster   ->  trivial   for    TopAugmentation of R;
</td><td><span data-href='waybel30.html#CC1'>waybel30</span></td></tr>
<tr><td>
cluster 1 -element   TopSpace-like   reflexive   -> 1 -element   reflexive   Scott   for    TopRelStr ;
</td><td><span data-href='waybel30.html#CC2'>waybel30</span></td></tr>
<tr><td>
cluster 1 -element   TopSpace-like   reflexive   -> 1 -element   with_compact_semilattices   for    TopRelStr ;
</td><td><span data-href='waybel30.html#CC9'>waybel30</span></td></tr>
<tr><td>
cluster  finite  1 -element   strict   reflexive   transitive   antisymmetric   lower-bounded   with_suprema   with_infima   for    RelStr ;
</td><td><span data-href='waybel31.html#RC1'>waybel31</span></td></tr>
<tr><td>
cluster 1 -element   TopSpace-like   reflexive   -> 1 -element   TopSpace-like   reflexive   upper   for    TopRelStr ;
</td><td><span data-href='waybel32.html#CC1'>waybel32</span></td></tr>
<tr><td>
cluster 1 -element   reflexive   -> 1 -element   reflexive   distributive   complemented   for    RelStr ;
</td><td><span data-href='waybel_2.html#CC2'>waybel_2</span></td></tr>
<tr><td>
cluster  non  empty  1 -element   strict   reflexive   transitive   antisymmetric   non  void   with_suprema   with_infima   for    RelStr ;
</td><td><span data-href='waybel_2.html#RC1'>waybel_2</span></td></tr>
<tr><td>
cluster 1 -element   reflexive   -> 1 -element   reflexive   satisfying_MC   for    RelStr ;
</td><td><span data-href='waybel_2.html#CC3'>waybel_2</span></td></tr>
<tr><td>
cluster 1 -element   reflexive   -> 1 -element   reflexive   satisfying_axiom_of_approximation   for    RelStr ;
</td><td><span data-href='waybel_3.html#CC3'>waybel_3</span></td></tr>
<tr><td>
cluster 1 -element   reflexive   transitive   antisymmetric   -> 1 -element   completely-distributive   for    RelStr ;
</td><td><span data-href='waybel_5.html#CC2'>waybel_5</span></td></tr>
<tr><td>
cluster  non  empty  1 -element   strict   reflexive   transitive   antisymmetric   with_suprema   with_infima   for    RelStr ;
</td><td><span data-href='waybel_8.html#RC1'>waybel_8</span></td></tr>
<tr><td>
cluster  TopRelStr(# {x},R,T #) -> 1 -element  ;
</td><td><span data-href='waybel_9.html#FC34'>waybel_9</span></td></tr>
<tr><td>
cluster  finite  1 -element   discrete   reflexive   strict   for    TopRelStr ;
</td><td><span data-href='waybel_9.html#RC3'>waybel_9</span></td></tr>
<tr><td>
cluster  non  empty   finite  1 -element   TopSpace-like   Hausdorff   discrete   reflexive   transitive   antisymmetric   with_suprema   with_infima   compact   strict   for    TopRelStr ;
</td><td><span data-href='waybel_9.html#RC4'>waybel_9</span></td></tr>
<tr><td>
cluster 1 -element   TopSpace-like   reflexive   -> 1 -element   TopSpace-like   topological_semilattice   for    TopRelStr ;
</td><td><span data-href='yellow13.html#CC9'>yellow13</span></td></tr>
<tr><td>
cluster 1 -element   reflexive   -> 1 -element   reflexive   transitive   antisymmetric   complete   for    RelStr ;
</td><td><span data-href='yellow_0.html#CC2'>yellow_0</span></td></tr>
<tr><td>
cluster  RelStr(# {x},R #) -> 1 -element  ;
</td><td><span data-href='yellow_0.html#FC1'>yellow_0</span></td></tr>
<tr><td>
cluster 1 -element   strict   reflexive   for    RelStr ;
</td><td><span data-href='yellow_0.html#RC1'>yellow_0</span></td></tr>
<tr><td>
cluster Y |^ {} -> 1 -element   strict  ;
</td><td><span data-href='yellow_1.html#FC13'>yellow_1</span></td></tr>
<tr><td>
cluster  non  empty  V56()  finite  1 -element   strict   reflexive   transitive   antisymmetric   with_suprema   with_infima   complete   lower-bounded   upper-bounded   bounded   connected   up-complete   /\-complete   distributive  V225()  completely-distributive   for    RelStr ;
</td><td><span data-href='yellow_7.html#RC1'>yellow_7</span></td></tr>
<tr><td>
cluster  non  empty  1 -element   correct   reflexive   transitive   antisymmetric   with_suprema   with_infima   complete   strict   for    TopRelStr ;
</td><td><span data-href='yellow_9.html#RC1'>yellow_9</span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
<hr/>
</body>
</html>
